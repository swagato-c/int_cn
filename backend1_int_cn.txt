OMODULO ONOTModeOCOLONOCOLON "TeXOCOLONUTFOMINUS8"
OBACKSLASHchapterOPENCURLY后端1CLOSECURLY
OBACKSLASHlabelOPENCURLYcptOCOLONbackend1CLOSECURLY
OBACKSLASHbeginOPENCURLYmdframedCLOSECURLY  
	OBACKSLASHtextbfOPENCURLY主要目标CLOSECURLY
	OBACKSLASHbeginOPENCURLYenumerateCLOSECURLYOPENSQUARElabelindentOASSIGN0emOCOMMAleftmarginOASSIGN1ODOT5emCLOSESQUARE
		OBACKSLASHitem 理解后端的概念。
		OBACKSLASHitem 理解以EKF为代表的滤波器后端工作原理。
		OBACKSLASHitem 理解非线性优化的后端，明白稀疏性是如何利用的。
		OBACKSLASHitem 使用g2o和Ceres实际操作后端优化。
	OBACKSLASHendOPENCURLYenumerateCLOSECURLY
OBACKSLASHendOPENCURLYmdframedCLOSECURLY

本讲开始，我们转入SLAM系统的另一个重要模块：后端优化。

我们看到，前端视觉里程计能给出一个短时间内的轨迹和地图，但由于不可避免的误差累积，这个地图在长时间内是不准确的。所以，在视觉里程计的基础上，我们还希望构建一个尺度、规模更大的优化问题，以考虑长时间内的最优轨迹和地图。不过，考虑到精度与性能的平衡，实际当中存在着许多不同的做法。

OBACKSLASHnewpage
OBACKSLASHincludepdfOPENCURLYresourcesODIVIDEotherODIVIDEch10ODOTpdfCLOSECURLY

OBACKSLASHnewpage
OBACKSLASHsectionOPENCURLY概述CLOSECURLY
OBACKSLASHsubsectionOPENCURLY状态估计的概率解释CLOSECURLY
第2讲中提到，视觉里程计只有短暂的记忆，而我们希望整个运动轨迹在较长时间内都能保持最优的状态。我们可能会用最新的知识，更新较久远的状态——站在“久远的状态”的角度上看，仿佛是未来的信息告诉它“你应该在哪里”。所以，在后端优化中，我们通常考虑一段更长时间内（或所有时间内）的状态估计问题，而且不仅使用过去的信息更新自己的状态，也会用未来的信息来更新自己，这种处理方式不妨称为“批量的”（Batch）。否则，如果当前的状态只由过去的时刻决定，甚至只由前一个时刻决定，那不妨称为“渐进的”（Incremental）。

我们已经知道SLAM过程可以由运动方程和观测方程来描述。那么，假设在ODOLLARtOASSIGN0ODOLLAR到ODOLLARtOASSIGNNODOLLAR的时间内，有位姿ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0ODOLLAR到ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORENODOLLAR，并且有路标ODOLLAROBACKSLASHbmOPENCURLYyCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHcdotsOCOMMA OBACKSLASHbmOPENCURLYyCLOSECURLYOUNDERSCOREMODOLLAR。按照之前的写法，运动和观测方程为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHleftOBACKSLASHOPENCURLY OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLY OASSIGN fOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OBACKSLASHbmOPENCURLYwCLOSECURLYOUNDERSCOREk OBACKSLASHOBACKSLASH
OPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLYkOCOMMAjCLOSECURLYCLOSECURLY OASSIGN hOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLY OBACKSLASHbmOPENCURLYyCLOSECURLYOUNDERSCOREjCLOSECURLYOCOMMAOPENCURLY OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY  OBACKSLASHrightCLOSEBRACKETOPLUS OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREOPENCURLYkOCOMMAjCLOSECURLY
   OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightODOT OBACKSLASHquad kOASSIGN1OCOMMA OBACKSLASHldotsOCOMMA NOCOMMA OBACKSLASH  jOASSIGN1OCOMMA OBACKSLASHldotsOCOMMA MODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

注意以下几点：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 观测方程中，只有当ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkODOLLAR看到了ODOLLAROBACKSLASHbmOPENCURLYyCLOSECURLYOUNDERSCOREjODOLLAR时，才会产生观测数据，否则就没有。事实上，在一个位置通常只能看到一小部分路标。而且，由于视觉SLAM特征点数量众多，所以实际当中观测方程的数量会远远大于运动方程。
	OBACKSLASHitem 我们可能没有测量运动的装置，所以也可能没有运动方程。在这个情况下，有若干种处理方式：认为确实没有运动方程，或假设相机不动，或假设相机匀速运动。这几种方式都是可行的。在没有运动方程的情况下，整个优化问题就只由许多个观测方程组成。这就非常类似于SfM（Structure from Motion）问题，相当于我们通过一组图像来恢复运动和结构。与SfM中不同的是，SLAM中的图像有时间上的先后顺序，而SfM中允许使用完全无关的图像。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

我们知道每个方程都受噪声影响，所以要把这里的位姿ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR和路标ODOLLAROBACKSLASHbmOPENCURLYyCLOSECURLYODOLLAR看成OBACKSLASHtextbfOPENCURLY服从某种概率分布的随机变量CLOSECURLY，而不是单独的一个数。因此，我们关心的问题就变成：当我拥有某些运动数据ODOLLAROBACKSLASHbmOPENCURLYuCLOSECURLYODOLLAR和观测数据ODOLLAROBACKSLASHbmOPENCURLYzCLOSECURLYODOLLAR时，如何来确定状态量ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYyCLOSECURLYODOLLAR的分布？进而，如果得到了新时刻的数据，那么它们的分布又将发生怎样的变化？在比较常见且合理的情况下，我们假设状态量和噪声项服从高斯分布——这意味着在程序中只需要储存它们的均值和协方差矩阵即可。均值可看作是对变量最优值的估计，而协方差矩阵则度量了它的不确定性。那么，问题就转变为：当存在一些运动数据和观测数据时，我们如何去估计状态量的高斯分布？

我们依然设身处地地扮演一下小萝卜。只有运动方程时，相当于我们蒙着眼睛在一个未知的地方走路。尽管我们知道自己每一步走了多远，但是随着时间增长，我们将对自己的位置越来越不确定——内心也就越不安。这说明在输入数据受噪声影响时，OBACKSLASHtextbfOPENCURLY误差是逐渐累积的CLOSECURLY，我们对位置方差的估计将越来越大。但是，当我们睁开眼睛时，由于能够不断地观测到外部场景，使得位置估计的不确定性变小，我们就会越来越自信。如果用椭圆或椭球直观地表达协方差阵，那么这个过程有点像是在手机地图软件中走路的感觉。以OBACKSLASHautorefOPENCURLYfigOCOLONuncertaintyCLOSECURLYOTILDE为例，读者可以想象，当没有观测数据时，这个圆会随着运动越来越大；而如果有正确的观测，圆就会缩小至一定的大小，保持稳定。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT66OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEuncertaintyODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLY不确定性的直观描述。左侧：只有运动方程时，由于下一时刻的位姿是在上一时刻基础上添加了噪声，所以不确定性越来越大。右侧：存在路标点时，不确定性会明显减小。不过请注意，这只是一个直观的示意图，并非实际数据。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONuncertaintyCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

上面的过程以比喻的形式解释了状态估计中的问题，下面我们要以定量的方式来看待它。在第OBACKSLASHrefOPENCURLYcptOCOLON6CLOSECURLY讲中，我们介绍了最大似然估计，提到OBACKSLASHtextbfOPENCURLY批量状态估计问题可以转化为最大似然估计问题，并使用最小二乘法进行求解。CLOSECURLY在本节，我们将探讨如何将该结论应用于渐进式问题，得到一些经典的结论。同时，在视觉SLAM里，最小二乘法又有何特殊的结构。

首先，由于位姿和路标点都是待估计的变量，我们改变一下记号，令ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkODOLLAR为ODOLLARkODOLLAR时刻的所有未知量。它包含了当前时刻的相机位姿与ODOLLARmODOLLAR个路标点。在这种记号的意义下（虽然与之前稍有不同，但含义是清楚的），写成：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREk  OBACKSLASHbuildrel OBACKSLASHDelta OBACKSLASHover OASSIGN  OBACKSLASHOPENCURLY OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkOCOMMA OBACKSLASHbmOPENCURLYyCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHldotsOCOMMA OBACKSLASHbmOPENCURLYyCLOSECURLYOUNDERSCOREm OBACKSLASHCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

同时，把ODOLLARkODOLLAR时刻的所有观测记作ODOLLAROBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkODOLLAR。于是，运动方程与观测方程的形式可写得更加简洁。这里不会出现ODOLLAROBACKSLASHbmOPENCURLYyCLOSECURLYODOLLAR，但我们心里要明白这时ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR中已经包含了之前的ODOLLAROBACKSLASHbmOPENCURLYyCLOSECURLYODOLLAR：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHleftOBACKSLASHOPENCURLY OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLY OASSIGN fOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OBACKSLASHbmOPENCURLYwCLOSECURLYOUNDERSCOREk OBACKSLASHOBACKSLASH
OPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLYkCLOSECURLYCLOSECURLY OASSIGN hOBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREk  OBACKSLASHrightCLOSEBRACKETOPLUS OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREOPENCURLYkCLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightODOT OBACKSLASHquad kOASSIGN1OCOMMA OBACKSLASHldotsOCOMMA N ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

现在考虑第ODOLLARkODOLLAR时刻的情况。我们希望用过去ODOLLAR0ODOLLAR到ODOLLARkODOLLAR中的数据来估计现在的状态分布：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
POPENBRACKETOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREk OBBOR OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0OCOMMA OBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

下标ODOLLAR0OCOLONkODOLLAR表示从ODOLLAR0ODOLLAR时刻到ODOLLARkODOLLAR时刻的所有数据。请注意，ODOLLAROBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkODOLLAR表示所有在ODOLLARkODOLLAR时刻的观测数据，它可能不止一个，只是这种记法更加方便。同时，ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkODOLLAR实际上和ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS2CLOSECURLYODOLLAR这些量都有关，但是此式没有显式地将它们写出来。

下面我们来看如何对状态进行估计。按照贝叶斯法则，把ODOLLAROBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkODOLLAR与ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkODOLLAR交换位置，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLON10OMINUS5CLOSECURLY
POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OBACKSLASHpropto POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

读者应该不会感到陌生。这里第一项称为OBACKSLASHtextbfOPENCURLY似然CLOSECURLY，第二项称为OBACKSLASHtextbfOPENCURLY先验CLOSECURLY。似然由观测方程给定，而先验部分，我们要明白当前状态ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkODOLLAR是基于过去所有的状态估计得来的。至少，它会受ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLYODOLLAR影响，于是按照ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLYODOLLAR时刻为条件概率展开：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONbayesOMINUSestimatorCLOSECURLY
POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OASSIGN OBACKSLASHint OPENCURLYPOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETPOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OBACKSLASHmathrmOPENCURLYdCLOSECURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLY CLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

如果考虑更久之前的状态，也可以继续对此式进行展开，但现在我们只关心ODOLLARkODOLLAR时刻和ODOLLARkOMINUS1ODOLLAR时刻的情况。至此，我们给出了贝叶斯估计，虽然上式还没有具体的概率分布形式，所以还没法实际地操作它。对这一步的后续处理，方法上产生了一些分歧。大体上讲，存在若干种选择：其一是假设OBACKSLASHtextbfOPENCURLY马尔可夫性CLOSECURLY，简单的一阶马氏性认为，ODOLLARkODOLLAR时刻状态只与ODOLLARkOMINUS1ODOLLAR时刻状态有关，而与再之前的无关。如果做出这样的假设，我们就会得到以OBACKSLASHtextbfOPENCURLY扩展卡尔曼滤波CLOSECURLY（EKF）为代表的滤波器方法。在滤波方法中，我们会从某时刻的状态估计，推导到下一个时刻。另外一种方法是依然考虑ODOLLARkODOLLAR时刻状态与之前OBACKSLASHtextbfOPENCURLY所有CLOSECURLY状态的关系，此时将得到OBACKSLASHtextbfOPENCURLY非线性优化CLOSECURLY为主体的优化框架。非线性优化的基本知识已在前文介绍过。目前视觉SLAM的主流为非线性优化方法。不过，为了让本书更全面，我们要先介绍一下卡尔曼滤波器和EKF的原理。

OBACKSLASHsubsectionOPENCURLY线性系统和KFCLOSECURLY
我们首先来看滤波器模型。当我们假设了马尔可夫性，从数学角度会发生哪些变化呢？首先，当前时刻状态只和上一个时刻有关，式OBACKSLASHeqrefOPENCURLYeqOCOLONbayesOMINUSestimatorCLOSECURLY中右侧第一部分可进一步简化：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OASSIGN POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这里，由于ODOLLARkODOLLAR时刻状态与ODOLLARkOMINUS1ODOLLAR之前的无关，所以就简化成只与ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkODOLLAR有关的形式，与ODOLLAROPENCURLYkCLOSECURLYODOLLAR时刻的运动方程对应。第二部分可简化为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OASSIGN POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONk OMINUS 1CLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这是考虑到ODOLLARkODOLLAR时刻的输入量ODOLLAROBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkODOLLAR与ODOLLARkOMINUS1ODOLLAR时刻的状态无关，所以我们把ODOLLAROBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkODOLLAR拿掉。可以看到，这一项实际上是ODOLLARkOMINUS1ODOLLAR时刻的状态分布。于是，这一系列方程说明，我们实际在做的是“如何把ODOLLARkOMINUS1ODOLLAR时刻的状态分布推导至ODOLLARkODOLLAR时刻”这样一件事。也就是说，在程序运行期间，我们只要维护一个状态量，对它不断地进行迭代和更新即可。进一步，如果假设状态量服从高斯分布，那么我们只需考虑维护状态量的均值和协方差即可。你可以想象成小萝卜上的定位系统一直在向外输出两个定位信息：一是自己的位姿，二是自己的不确定性。实际当中往往也是如此。

我们从形式最简单的线性高斯系统开始，最后我们将得到卡尔曼滤波器。明确了起点和终点之后，我们再来考虑中间的路线。线性高斯系统是说，运动方程和观测方程可以由线性方程来描述：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHleftOBACKSLASHOPENCURLY OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYACLOSECURLYOUNDERSCOREk OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOPLUSOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYwCLOSECURLYOUNDERSCOREk OBACKSLASHOBACKSLASH
OPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLYkCLOSECURLYCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREk  OPENCURLY OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREOPENCURLYkCLOSECURLY OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightODOT OBACKSLASHquad kOASSIGN1OCOMMA OBACKSLASHldotsOCOMMA N ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
并假设所有的状态和噪声均满足高斯分布。记这里的噪声服从零均值高斯分布：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYwCLOSECURLYOUNDERSCOREk OBACKSLASHsim NOPENBRACKETOBACKSLASHbmOPENCURLY0CLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYRCLOSECURLYCLOSEBRACKETODOT OBACKSLASHquad OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREk OBACKSLASHsim NOPENBRACKET OBACKSLASHbmOPENCURLY0CLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYQCLOSECURLYCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

为了简洁，笔者省略了ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYQCLOSECURLYODOLLAR的下标。现在，利用马尔可夫性，假设我们知道了ODOLLARkOMINUS1ODOLLAR时刻的后验（在ODOLLARkOMINUS1ODOLLAR时刻看来）状态估计ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLYODOLLAR及其协方差ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLYODOLLAR，现在要根据ODOLLARkODOLLAR时刻的输入和观测数据，确定ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkODOLLAR的后验分布。为区分推导中的先验和后验，我们在记号上做一点区别：以上帽子ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREkODOLLAR表示后验，以下帽子ODOLLAROBACKSLASHcheckOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREkODOLLAR表示先验分布，请读者不要混淆。

卡尔曼滤波器的第一步，通过运动方程确定ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkODOLLAR的先验分布。这一步是线性的，而高斯分布的线性变换仍是高斯分布。所以显然有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OASSIGN NOBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYACLOSECURLYOUNDERSCOREk OPENCURLYOPENCURLYOBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLY OPLUS OPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYACLOSECURLYOUNDERSCOREkOBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYACLOSECURLYOUNDERSCOREkOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYRCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这一步称为OBACKSLASHtextbfOPENCURLY预测CLOSECURLY，原理见附录OBACKSLASHrefOPENCURLYsecOCOLONgaussOMINUSexampleCLOSECURLY。它显示了如何从上一个时刻的状态，根据输入信息（但是有噪声）推断当前时刻的状态分布。这个分布也就是先验。记：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHcheckOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREk OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYACLOSECURLYOUNDERSCOREk OPENCURLYOPENCURLYOBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLY OPLUS OPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLYOCOMMA OBACKSLASHquad OBACKSLASHcheckOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREk OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYACLOSECURLYOUNDERSCOREk OBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLY OPENCURLY OBACKSLASHbmOPENCURLYACLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOUNDERSCOREkCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYRCLOSECURLYCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这非常自然。显然这一步状态的不确定度要变大，因为系统中添加了噪声。另一方面，由观测方程，我们可以计算在某个状态下应该产生怎样的观测数据：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OASSIGN NOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYQCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

为了得到后验概率，我们想要计算它们的乘积，也就是由式OBACKSLASHeqrefOPENCURLYeqOCOLON10OMINUS5CLOSECURLY给出的贝叶斯公式。然而，虽然我们知道最后会得到一个关于ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkODOLLAR的高斯分布，但计算上是有一点点麻烦的，我们先把结果设为ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREk OBACKSLASHsim NOPENBRACKETOBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREkOCOMMA OBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREk CLOSEBRACKETODOLLAR，那么：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
NOPENBRACKETOBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREkOCOMMA OBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREk CLOSEBRACKET OASSIGN OBACKSLASHeta NOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYQCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OBACKSLASHcdot NOPENBRACKET OBACKSLASHbmOPENCURLYOBACKSLASHcheckOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREkOCOMMA OBACKSLASHbmOPENCURLYOBACKSLASHcheckOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSEBRACKETODOT 
OBACKSLASHendOPENCURLYequationCLOSECURLY

这里我们稍微用点讨巧的方法。既然我们已经知道等式两侧都是高斯分布，那就只需比较指数部分即可，而无须理会高斯分布前面的因子部分。指数部分很像是一个二次型的配方，我们来推导一下。首先把指数部分展开，有OBACKSLASHfootnoteOPENCURLY这里的等号并不严格，实际允许相差与ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkODOLLAR无关的常数。CLOSECURLY：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLY OMINUS OPENCURLYOPENCURLYOBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOPENCURLY OMINUS 1CLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLY OMINUS OPENCURLYOPENCURLYOBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OASSIGN OPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkCLOSECURLY OMINUS OPENCURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkCLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYQCLOSECURLYOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkCLOSECURLY OMINUS OPENCURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLY OMINUS OPENCURLYOPENCURLYOBACKSLASHcheckOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOBACKSLASHcheckOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOPENCURLY OMINUS 1CLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREk OMINUS OPENCURLYOPENCURLYOBACKSLASHcheckOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

为了求左侧的ODOLLAROBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREkODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkODOLLAR，我们把两边展开，并比较ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkODOLLAR的二次和一次系数。对于二次系数，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONkalmanOMINUScovCLOSECURLY
OBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOPENCURLY OMINUS 1CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYQCLOSECURLYOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkCLOSECURLY OPLUS OBACKSLASHcheck OPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOPENCURLY OMINUS 1CLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

该式给出了协方差的计算过程。为了便于后面列写式子，定义一个中间变量：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONkalmanOMINUSKCLOSECURLY
OBACKSLASHbmOPENCURLYKCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREk OBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYQCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

根据此定义，在式OBACKSLASHeqrefOPENCURLYeqOCOLONkalmanOMINUScovCLOSECURLY的左右各乘ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkODOLLAR，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYICLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREk OBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYQCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLY OBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREk OPLUS OBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREk OBACKSLASHbmOPENCURLYOBACKSLASHcheckOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOPENCURLYOMINUS1CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREk OPLUS OBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREk OBACKSLASHbmOPENCURLYOBACKSLASHcheckOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOPENCURLYOMINUS1CLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

于是有OBACKSLASHfootnoteOPENCURLY这里看似有一点儿循环定义的意思。我们由ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkODOLLAR定义了ODOLLAROBACKSLASHbmOPENCURLYKCLOSECURLYODOLLAR，又把ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkODOLLAR写成了ODOLLAROBACKSLASHbmOPENCURLYKCLOSECURLYODOLLAR的表达式。然而，实际当中ODOLLAROBACKSLASHbmOPENCURLYKCLOSECURLYODOLLAR可以不依靠ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkODOLLAR算得，但是这需要引入ShermanOMINUSMorrisonOMINUSWoodbury恒等式OBACKSLASHciteOPENCURLYSherman1950CLOSECURLY，参见本讲的习题。CLOSECURLY：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREk OASSIGN OPENBRACKET OBACKSLASHbmOPENCURLYICLOSECURLY OMINUS OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREk CLOSEBRACKET OBACKSLASHbmOPENCURLYOBACKSLASHcheckOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

然后再比较一次项的系数，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMINUS 2OBACKSLASHhat OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOPENCURLY OMINUS 1CLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLY OASSIGN  OMINUS 2OBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYQCLOSECURLYOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLY OMINUS 2OBACKSLASHbmOPENCURLYOBACKSLASHcheck OPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYOBACKSLASHcheck OPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOPENCURLY OMINUS 1CLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

整理（取系数并转置）得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHhat OPENCURLY OBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOPENCURLY OMINUS 1CLOSECURLYOPENCURLYOPENCURLYOBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYQCLOSECURLYOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkCLOSECURLY OPLUS OBACKSLASHcheckOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOPENCURLY OMINUS 1CLOSECURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheckOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

两侧乘以ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkODOLLAR并代入式OBACKSLASHeqrefOPENCURLYeqOCOLONkalmanOMINUSKCLOSECURLY，得：
OBACKSLASHbeginOPENCURLYalignCLOSECURLY
OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHhat OPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLY OBANDOASSIGN OPENCURLYOPENCURLYOBACKSLASHhat OPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLY OBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OPENCURLY OBACKSLASHbmOPENCURLYQCLOSECURLYOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkCLOSECURLY OPLUS OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLY PCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYOBACKSLASHcheck OPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkOHATOPENCURLY OMINUS 1CLOSECURLYOPENCURLYOPENCURLYOBACKSLASHcheck OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYOBACKSLASHOBACKSLASH
OBANDOASSIGN OBACKSLASHbmOPENCURLYKCLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkCLOSECURLY OPLUS OBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLY OMINUS OBACKSLASHbmOPENCURLYKCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheck OPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLY OASSIGN OPENCURLYOPENCURLYOBACKSLASHcheck OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREk OMINUS OPENCURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheckOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYalignCLOSECURLY

于是我们又得到了后验均值的表达。总而言之，上面的两个步骤可以归纳为“预测”（Predict）和“更新”（Update）两个步骤：

OBACKSLASHbeginOPENCURLYmdframedCLOSECURLY
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 预测：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHcheckOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREk OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYACLOSECURLYOUNDERSCOREk OPENCURLYOPENCURLYOBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLY OPLUS OPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLYOCOMMA OBACKSLASHquad OBACKSLASHcheckOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREk OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYACLOSECURLYOUNDERSCOREk OBACKSLASHhatOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLY OPENCURLY OBACKSLASHbmOPENCURLYACLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOUNDERSCOREkCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYRCLOSECURLYCLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	OBACKSLASHitem 更新：
	先计算ODOLLAROBACKSLASHbmOPENCURLYKCLOSECURLYODOLLAR，它又称为卡尔曼增益。
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHlabelOPENCURLYeqOCOLONkalmanOMINUSKOMINUSanotherCLOSECURLY
	OBACKSLASHbmOPENCURLYKCLOSECURLY OASSIGN OPENCURLYOPENCURLYOBACKSLASHcheck OPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLY OBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHcheck OPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OPLUS OPENCURLYOBACKSLASHbmOPENCURLYQCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	然后计算后验概率的分布。
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
	OBACKSLASHhat OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREk OASSIGN OPENCURLYOPENCURLYOBACKSLASHcheck OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREk OMINUS OPENCURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheckOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHhat OPENCURLYPCLOSECURLYCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLY OASSIGN OBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLY OMINUS OBACKSLASHbmOPENCURLYKCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OBACKSLASHcheckOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkODOT
	OBACKSLASHendOPENCURLYarrayCLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
OBACKSLASHendOPENCURLYenumerateCLOSECURLY
OBACKSLASHendOPENCURLYmdframedCLOSECURLY

至此，我们推导了经典的卡尔曼滤波器的整个过程。事实上，卡尔曼滤波器有若干种推导方式，而我们使用的是从概率角度出发的最大后验概率估计的形式。我们看到，在线性高斯系统中，卡尔曼滤波器构成了该系统中的最大后验概率估计。而且，由于高斯分布经过线性变换后仍服从高斯分布，所以整个过程中我们没有进行任何的近似。可以说，卡尔曼滤波器构成了线性系统的最优无偏估计。

OBACKSLASHsubsectionOPENCURLY非线性系统和EKFCLOSECURLY
在理解了卡尔曼滤波之后，我们必须要澄清一点：SLAM中的运动方程和观测方程通常是非线性函数，尤其是视觉SLAM中的相机模型，需要使用相机内参模型及李代数表示的位姿，更不可能是一个线性系统。一个高斯分布，经过非线性变换后，往往不再是高斯分布，所以在非线性系统中，我们必须取一定的近似，将一个非高斯分布近似成高斯分布。

我们希望把卡尔曼滤波器的结果拓展到非线性系统中，称为扩展卡尔曼滤波器（Extended Kalman Filter，EKF）。通常的做法是，在某个点附近考虑运动方程及观测方程的一阶泰勒展开，只保留一阶项，即线性的部分，然后按照线性系统进行推导。令ODOLLARkOMINUS1ODOLLAR时刻的均值与协方差矩阵为ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLYODOLLAR。在ODOLLARkODOLLAR时刻，我们把运动方程和观测方程在ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLYODOLLAR处进行OBACKSLASHtextbfOPENCURLY线性化CLOSECURLY（相当于一阶泰勒展开），有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLY OBACKSLASHapprox fOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHhat xCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OPENCURLYOBACKSLASHleftODOT OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial fCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightOBBOROUNDERSCOREOPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHhat xCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLY OMINUS OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHhat xCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OPENCURLYOBACKSLASHbmOPENCURLYwCLOSECURLYOUNDERSCOREkCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

记这里的偏导数为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYFCLOSECURLY OASSIGN OBACKSLASHleftODOT OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial fCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightOBBOROUNDERSCOREOPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHhat xCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

同样，对于观测方程，亦有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkCLOSECURLY OBACKSLASHapprox hOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheck xCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OPENCURLYOBACKSLASHleftODOT OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial hCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightOBBOROUNDERSCOREOPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheck xCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLYCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREk OMINUS OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheck xCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OPENCURLYOBACKSLASHbmOPENCURLYnCLOSECURLYOUNDERSCOREkCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

记这里的偏导数为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYHCLOSECURLY OASSIGN OBACKSLASHleftODOT OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial hCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightOBBOROUNDERSCOREOPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheck xCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

那么，在OBACKSLASHtextbfOPENCURLY预测CLOSECURLY步骤中，根据运动方程有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE0CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREOPENCURLY1OCOLONkCLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLY0OCOLONk OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET
 OASSIGN NOPENBRACKETfOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHhat xCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOCOMMA OBACKSLASHbmOPENCURLYFCLOSECURLYOBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLY OBACKSLASHbmOPENCURLYFCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCOREkCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这些推导和卡尔曼滤波是十分相似的。为方便表述，记这里的先验和协方差的均值为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYOBACKSLASHcheck OPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREk OASSIGN fOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHhat xCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYk OMINUS 1CLOSECURLYCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOCOMMA OBACKSLASHquad OBACKSLASHbmOPENCURLYOBACKSLASHcheckOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREk OASSIGN OBACKSLASHbmOPENCURLYFCLOSECURLYOBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLY OBACKSLASHbmOPENCURLYFCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCOREkODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

然后，考虑在观测中我们有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
POBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkCLOSECURLYOBBOROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OASSIGN NOPENBRACKET hOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheck xCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OBACKSLASHbmOPENCURLYHCLOSECURLY OBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREk OMINUS OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheck xCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOCOMMA OBACKSLASHbmOPENCURLYQCLOSECURLYOUNDERSCOREk CLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

最后，根据最开始的贝叶斯展开式，可以推导出ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREkODOLLAR的后验概率形式。我们略去中间的推导过程，只介绍其结果。读者可以仿照卡尔曼滤波器的方式，推导EKF的预测与更新方程。简而言之，我们会先定义一个OBACKSLASHtextbfOPENCURLY卡尔曼增益CLOSECURLYODOLLAROBACKSLASHbmOPENCURLYKCLOSECURLYOUNDERSCOREkODOLLAR：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYKCLOSECURLYOUNDERSCOREk OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheckOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkCLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYHCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYHCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheck PCLOSECURLYOUNDERSCOREkCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYHCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OPLUS OPENCURLYOBACKSLASHbmOPENCURLYQCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

在卡尔曼增益的基础上，后验概率的形式为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHhat xCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLY OASSIGN OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheck xCLOSECURLYCLOSECURLYOUNDERSCOREkCLOSECURLY OPLUS OPENCURLYOBACKSLASHbmOPENCURLYKCLOSECURLYOUNDERSCOREkCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREkCLOSECURLY OMINUS hOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHcheck xCLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHrightCLOSEBRACKETOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHhat PCLOSECURLYOUNDERSCOREkCLOSECURLY OASSIGN OBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLY OMINUS OPENCURLYOBACKSLASHbmOPENCURLYKCLOSECURLYOUNDERSCOREkCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYHCLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OBACKSLASHbmOPENCURLYOBACKSLASHcheckOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREkODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

卡尔曼滤波器给出了在线性化之后状态变量分布的变化过程。在线性系统和高斯噪声下，卡尔曼滤波器给出了无偏最优估计。而在SLAM这种非线性的情况下，它给出了单次线性近似下的最大后验估计（MAP）。

OBACKSLASHsubsectionOPENCURLYEKF的讨论CLOSECURLY
EKF以形式简洁、应用广泛著称。当想要在某段时间内估计某个不确定量时，我们首先想到的就是EKF。在早期的SLAM中，EKF占据了很长一段时间的主导地位，研究者们讨论了各种各样的滤波器在SLAM中的应用，如IF（信息滤波器）OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYSujan2005CLOSECURLYCLOSECURLY、IKFOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYJanabiOMINUSSharifi2010CLOSECURLYCLOSECURLY（Iterated KF）、UKFOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYLi2010CLOSECURLYCLOSECURLY（Unscented KF）和粒子滤波器OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYSim2007OCOMMA Lee2011OCOMMA Gil2010aCLOSECURLYCLOSECURLY、SWF（Sliding Window OBACKSLASHmboxOPENCURLYFilter）OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYSibley2010CLOSECURLYCLOSECURLYCLOSECURLY，等等OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYChen2012CLOSECURLYCLOSECURLYOBACKSLASHfootnoteOPENCURLY粒子滤波器的原理与卡尔曼滤波有较大不同。CLOSECURLY，或者用分治法等思路改进EKF的效率OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYPaz2008OCOMMA Grasa2011CLOSECURLYCLOSECURLY。直至今日，尽管我们认识到非线性优化比滤波器占有明显的优势，但是在计算资源受限，或待估计量比较简单的场合，EKF仍不失为一种有效的方式。

EKF有哪些局限呢？

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 首先，滤波器方法在一定程度上假设了OBACKSLASHtextbfOPENCURLY马尔可夫性CLOSECURLY，也就是ODOLLARkODOLLAR时刻的状态只与ODOLLARkOMINUS1ODOLLAR时刻相关，而与ODOLLARkOMINUS1ODOLLAR之前的状态和观测都无关（或者和前几个有限时刻的状态相关）。这有点像是在视觉里程计中只考虑相邻两帧关系一样。如果当前帧确实与很久之前的数据有关（例如回环），那么滤波器就会难以处理。

	而非线性优化方法则倾向于使用所有的历史数据。它不光考虑邻近时刻的特征点与轨迹关系，更会把很久之前的状态也考虑进来，称为全体时间上的SLAM（FullOMINUSSLAM）。在这种意义下，非线性优化方法使用了更多信息，当然也需要更多的计算。
	
	OBACKSLASHitem 与第6讲介绍的优化方法相比，EKF滤波器仅在ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHhatOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYkOMINUS1CLOSECURLYODOLLAR处做了OBACKSLASHtextbfOPENCURLY一次CLOSECURLY线性化，然后就直接根据这次线性化结果，把后验概率给算了出来。这相当于在说，我们认为OBACKSLASHtextbfOPENCURLY该点处的线性化近似在后验概率处仍然是有效的CLOSECURLY。而实际上，当我们离开工作点较远时，一阶泰勒展开并不一定能够近似整个函数，这取决于运动模型和观测模型的非线性情况。如果它们有强烈的非线性，那么线性近似就只在很小范围内成立，不能认为在很远的地方仍能用线性来近似。这就是EKF的OBACKSLASHtextbfOPENCURLY非线性误差CLOSECURLY，也是它的主要问题所在。

	在优化问题中，尽管我们也做一阶（最速下降）或二阶（高斯牛顿法或列文伯格—马夸尔特方法）的近似，但每迭代一次，状态估计发生改变之后，我们会重新对新的估计点做泰勒展开，而不像EKF那样只在固定点上做一次泰勒展开。这就使得优化方法适用范围更广，在状态变化较大时亦能适用。所以大体来说，可以粗略地认为OBACKSLASHtextbfOPENCURLYEKF仅是优化当中的一次迭代CLOSECURLYOBACKSLASHfootnoteOPENCURLY更仔细地说，比一次迭代要好一些，因为更新步骤的线性化是在预测基础之上。如果在预测时刻就同时线性化运动和观测模型，就完全和一次迭代一样了。CLOSECURLY。
	
	OBACKSLASHitem 从程序实现上来说，EKF需要存储状态量的均值和方差，并对它们进行维护和更新。如果把路标也放进状态，由于视觉SLAM中路标数量很大，这个存储量是相当可观的，且与状态量呈平方增长（因为要存储协方差矩阵）。因此，普遍认为EKF SLAM不适用于大型场景。
	
	OBACKSLASHitem 最后，EKF等滤波器方法没有异常检测机制，导致系统在存在异常值的时候很容易发散。而在视觉SLAM中，异常值却是很常见的：无论特征匹配还是光流法，都容易追踪或匹配到错误的点。没有异常值检测机制会让系统在实用中非常不稳定。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

由于EKF存在这些明显的缺点，我们通常认为，在同等计算量的情况下，非线性优化能取得更好的效果OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYStrasdat2012CLOSECURLYCLOSECURLY。这里“更好”是指精度和鲁棒性同时达到更好的意思。下面我们来讨论以非线性优化为主的后端。我们将主要介绍图优化，并用g2o和Ceres演示一下后端优化。

OBACKSLASHsectionOPENCURLYBA与图优化CLOSECURLY
如果你做过视觉三维重建，那么应该对这个概念再熟悉不过了。所谓的Bundle AdjustmentOBACKSLASHfootnoteOPENCURLY也译为光束法平差、捆集调整等，但笔者觉得没有Bundle Adjustment这个英文来得直观，所以这里保留英文名称。CLOSECURLY，是指从视觉图像中提炼出最优的3D模型和相机参数（内参数和外参数）。考虑从任意特征点发射出来的几束光线（bundles of light rays），它们会在几个相机的成像平面上变成像素或是检测到的特征点。如果我们调整（adjustment）各相机姿态和各特征点空间位置，使得这些光线最终收束到相机的光心OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYTriggs2000CLOSECURLYCLOSECURLY，就称为BA。

我们在第OBACKSLASHrefOPENCURLYcptOCOLON5CLOSECURLY讲和第OBACKSLASHrefOPENCURLYcptOCOLON7CLOSECURLY讲已经简单介绍过BA的原理，本节的重点是介绍它对应的图模型结构的特点，然后介绍一些通用的快速求解方法。

OBACKSLASHsubsectionOPENCURLY投影模型和BA代价函数CLOSECURLY
首先我们复习一下整个投影的过程。从一个世界坐标系中的点ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYODOLLAR出发，把相机的内外参数和畸变都考虑进来，最后投影成像素坐标，需要如下步骤。

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 首先，把世界坐标转换到相机坐标，这里将用到相机外参数ODOLLAROPENBRACKETOBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYCLOSEBRACKETODOLLAR：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHbmOPENCURLYPCLOSECURLY' OASSIGN OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLY OASSIGN OPENSQUAREX'OCOMMA Y'OCOMMA Z'CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	OBACKSLASHitem 然后，将ODOLLAROBACKSLASHbmOPENCURLYPCLOSECURLY'ODOLLAR投至归一化平面，得到归一化坐标：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREc OASSIGN OPENSQUAREuOUNDERSCOREcOCOMMA vOUNDERSCOREcOCOMMA 1CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OASSIGN OPENSQUAREX'ODIVIDEZ'OCOMMA Y'ODIVIDEZ'OCOMMA 1CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	OBACKSLASHitem 考虑归一化坐标的畸变情况，得到去畸变前的原始像素坐标。
这里暂时只考虑径向畸变：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHleftOBACKSLASHOPENCURLY
	OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
	uOUNDERSCOREc' OASSIGN OPENCURLYuOUNDERSCOREcCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLY1 OPLUS OPENCURLYkOUNDERSCORE1CLOSECURLYrOUNDERSCOREcOHAT2 OPLUS OPENCURLYkOUNDERSCORE2CLOSECURLYrOUNDERSCOREcOHAT4CLOSECURLY OBACKSLASHrightCLOSEBRACKETOBACKSLASHOBACKSLASH
	vOUNDERSCOREc' OASSIGN OPENCURLYvOUNDERSCOREcCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLY1 OPLUS OPENCURLYkOUNDERSCORE1CLOSECURLYrOUNDERSCOREcOHAT2 OPLUS OPENCURLYkOUNDERSCORE2CLOSECURLYrOUNDERSCOREcOHAT4CLOSECURLY OBACKSLASHrightCLOSEBRACKET
	OBACKSLASHendOPENCURLYarrayCLOSECURLY
	OBACKSLASHrightODOT ODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	OBACKSLASHitem 最后，根据内参模型，计算像素坐标：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHleftOBACKSLASHOPENCURLY OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
	OPENCURLYuOUNDERSCOREsCLOSECURLY OASSIGN OPENCURLYfOUNDERSCORExCLOSECURLYuOUNDERSCOREc' OPLUS OPENCURLYcOUNDERSCORExCLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLYvOUNDERSCOREsCLOSECURLY OASSIGN OPENCURLYfOUNDERSCOREyCLOSECURLYvOUNDERSCOREc' OPLUS OPENCURLYcOUNDERSCOREyCLOSECURLY 
	OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightODOT ODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

这一系列计算流程看似有些复杂。我们用流程OBACKSLASHautorefOPENCURLYfigOCOLONcalculationflowCLOSECURLYOTILDE形象化地表示整个过程，以帮助读者理解。读者应该能领会到，这个过程也就是前面讲的OBACKSLASHtextbfOPENCURLY观测方程CLOSECURLY，之前我们把它抽象地记成：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYzCLOSECURLY OASSIGN hOPENBRACKETOBACKSLASHbmOPENCURLYxCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYyCLOSECURLYCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1ODOT0OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEcalculationflowCLOSECURLY
	OBACKSLASHcaptionOPENCURLY计算流程示意图。左侧的ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYODOLLAR是全局坐标系下的三维坐标点，右侧的ODOLLARuOUNDERSCOREsOCOMMAvOUNDERSCOREsODOLLAR是该点在图像平面上的最终像素坐标。中间畸变模块中的ODOLLARrOUNDERSCOREcOHAT2OASSIGNuOUNDERSCOREcOHAT2 OPLUS vOUNDERSCOREcOHAT2ODOLLAR。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONcalculationflowCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

现在，我们给出了它的详细参数化过程。具体地说，这里的ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR指代此时相机的位姿，即外参ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR，它对应的李群为ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR，李代数为ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYODOLLAR。路标ODOLLAROBACKSLASHbmOPENCURLYyCLOSECURLYODOLLAR即这里的三维点ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYODOLLAR，而观测数据则是像素坐标ODOLLAROBACKSLASHbmOPENCURLYzCLOSECURLY OBACKSLASHbuildrel OBACKSLASHDelta OBACKSLASHover OASSIGN OPENSQUAREuOUNDERSCOREsOCOMMA vOUNDERSCOREsCLOSESQUAREOHATT ODOLLAR。以最小二乘的角度来考虑，那么可以列写关于此次观测的误差：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYeCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYzCLOSECURLY OMINUS hOPENBRACKETOBACKSLASHbmOPENCURLYTCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

然后，把其他时刻的观测量也考虑进来，我们可以给误差添加一个下标。设ODOLLAROBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYODOLLAR为在位姿ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREiODOLLAR处观察路标ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREjODOLLAR产生的数据，那么整体的OBACKSLASHtextbfOPENCURLY代价函数CLOSECURLY（Cost Function）为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONBAcostfunctionCLOSECURLY
OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOUNDERSCOREOPENCURLYiOASSIGN1CLOSECURLYOHATm OBACKSLASHsumOUNDERSCOREOPENCURLYjOASSIGN1CLOSECURLYOHATn OBACKSLASHOBBOR OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLY OBACKSLASHOBBOROHAT2 OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOUNDERSCOREOPENCURLYiOASSIGN1CLOSECURLYOHATmOBACKSLASHsumOUNDERSCOREOPENCURLYjOASSIGN1CLOSECURLYOHATn OBACKSLASHOBBOR
OBACKSLASHbmOPENCURLYOPENCURLYzCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLY OMINUS hOPENBRACKETOBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYiCLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREjCLOSEBRACKET OBACKSLASHOBBOROHAT2 ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

对这个最小二乘进行求解，相当于对位姿和路标同时做了调整，也就是所谓的BA。接下来，我们会根据该目标函数和第OBACKSLASHrefOPENCURLYcptOCOLON6CLOSECURLY讲介绍的非线性优化内容，逐步深入探讨该模型的求解。

OBACKSLASHsubsectionOPENCURLYBA的求解CLOSECURLY
观察在上一节中的观测模型ODOLLARhOPENBRACKETOBACKSLASHbmOPENCURLYTCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYCLOSEBRACKETODOLLAR，很容易判断该函数不是线性函数。所以我们希望使用OBACKSLASHrefOPENCURLYsecOCOLON6ODOT2CLOSECURLY节介绍的一些非线性优化手段来优化它。根据非线性优化的思想，我们应该从某个初始值开始，不断地寻找下降方向ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR来找到目标函数的最优解，即不断地求解增量方程OBACKSLASHeqrefOPENCURLYeqOCOLONminimizeOMINUSdeltaxCLOSECURLY中的增量ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR。尽管误差项都是针对单个位姿和路标点的，但在整体BA目标函数上，我们应该把自变量定义成所有待优化的变量：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYxCLOSECURLY OASSIGN OPENSQUARE OBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHldotsOCOMMA OBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREmOCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHldotsOCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREn CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

相应地，增量方程中的ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR则是对整体自变量的增量。在这个意义下，当我们给自变量一个增量时，目标函数变为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONtangentbundleindetailCLOSECURLY
OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHleftOBACKSLASHVert fOPENBRACKETOBACKSLASHbmOPENCURLYxCLOSECURLY OPLUS OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYCLOSEBRACKET OBACKSLASHrightOBACKSLASHVert OHAT2 OBACKSLASHapprox OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOUNDERSCOREOPENCURLYiOASSIGN1CLOSECURLYOHATOPENCURLYmCLOSECURLYOBACKSLASHsumOUNDERSCOREOPENCURLYjOASSIGN1CLOSECURLYOHATn OBACKSLASHleftOBACKSLASHVert OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYFCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLY OBACKSLASHDelta OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYOUNDERSCOREOPENCURLYiCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYECLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLY OBACKSLASHDelta OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREj OBACKSLASHrightOBACKSLASHVertOHAT2 ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

其中ODOLLAROBACKSLASHbmOPENCURLYFCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYODOLLAR表示整个代价函数在当前状态下对相机姿态的偏导数，而ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYODOLLAR表示该函数对路标点位置的偏导。我们曾在OTILDEOBACKSLASHrefOPENCURLYsecOCOLONBAOMINUSvo1CLOSECURLYOTILDE节中介绍了它们的具体形式，所以这里就不再展开推导了。现在，把相机位姿变量放在一起：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREcOASSIGNOPENSQUARE OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYOUNDERSCORE2OCOMMA OBACKSLASHldotsOCOMMA OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYOUNDERSCOREm CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHin OBACKSLASHmathbbOPENCURLYRCLOSECURLYOHATOPENCURLY6mCLOSECURLYOCOMMA
OBACKSLASHendOPENCURLYequationCLOSECURLY
并把空间点的变量也放在一起：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREpOASSIGNOPENSQUARE OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2OCOMMA OBACKSLASHldots OCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREn CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHin OBACKSLASHmathbbOPENCURLYRCLOSECURLYOHATOPENCURLY3nCLOSECURLYOCOMMA
OBACKSLASHendOPENCURLYequationCLOSECURLY
那么，式OBACKSLASHeqrefOPENCURLYeqOCOLONtangentbundleindetailCLOSECURLY可以简化表达如下：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONBAleastsquareCLOSECURLY
OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLY
OBACKSLASHleftOBACKSLASHVert 
fOPENBRACKETOBACKSLASHbmOPENCURLYxCLOSECURLYOPLUS OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLY CLOSEBRACKET
OBACKSLASHrightOBACKSLASHVert OHAT2 OASSIGN 
OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLY 
OBACKSLASHleftOBACKSLASHVert 
OBACKSLASHbmOPENCURLYeCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYFCLOSECURLYOBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREc OPLUS OBACKSLASHbmOPENCURLYECLOSECURLY OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREp 
OBACKSLASHright OBACKSLASHVert OHAT2 ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

需要注意的是，该式从一个由很多个小型二次项之和，变成了一个更整体的样子。这里的雅可比矩阵ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR必须是整体目标函数对整体变量的导数，它将是一个很大块的矩阵，而里头每个小分块，需要由每个误差项的导数ODOLLAROBACKSLASHbmOPENCURLYFCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYODOLLAR“拼凑”起来。然后，无论我们使用高斯牛顿法还是列文伯格—马夸尔特方法，最后都将面对增量线性方程：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYHCLOSECURLY OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYgCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

根据第OBACKSLASHrefOPENCURLYcptOCOLON6CLOSECURLY讲的知识，我们知道高斯牛顿法和列文伯格—马夸尔特方法的主要差别在于，这里的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR是取ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYJCLOSECURLYODOLLAR还是ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYJCLOSECURLYOPLUS OBACKSLASHlambda OBACKSLASHbmOPENCURLYICLOSECURLYODOLLAR的形式。由于我们把变量归类成了位姿和空间点两种，所以雅可比矩阵可以分块为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYJCLOSECURLYOASSIGNOPENSQUAREOBACKSLASHbmOPENCURLYFCLOSECURLY OBACKSLASH OBACKSLASHbmOPENCURLYECLOSECURLYCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

那么，以高斯牛顿法为例，则ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵为
OBACKSLASHbeginOPENCURLYequationCLOSECURLYOBACKSLASHlabelOPENCURLYeqOCOLONHessianMatrixCLOSECURLY
OBACKSLASHbmOPENCURLYHCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYJCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYJCLOSECURLY OASSIGN
OBACKSLASHbeginOPENCURLYbmatrixCLOSECURLY
         OBACKSLASHbmOPENCURLYFCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYFCLOSECURLY   OBAND   OBACKSLASHbmOPENCURLYFCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYECLOSECURLY   OBACKSLASHOBACKSLASH 
         OBACKSLASHbmOPENCURLYECLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYFCLOSECURLY   OBAND   OBACKSLASHbmOPENCURLYECLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYECLOSECURLY
OBACKSLASHendOPENCURLYbmatrixCLOSECURLY ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

当然在列文伯格—马夸尔特方法中我们也需要计算这个矩阵。不难发现，因为考虑了所有的优化变量，这个线性方程的维度将非常大，包含了所有的相机位姿和路标点。尤其是在视觉SLAM中，一幅图像就会提出数百个特征点，大大增加了这个线性方程的规模。如果直接对ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR求逆来计算增量方程，由于矩阵求逆是复杂度为ODOLLAROOPENBRACKETnOHAT3CLOSEBRACKETODOLLAR的操作OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYSueli2003CLOSECURLYCLOSECURLY，这是非常消耗计算资源的。幸运的是，这里的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵是有一定的特殊结构的。利用这个特殊结构，我们可以加速求解过程。

OBACKSLASHsubsectionOPENCURLY稀疏性和边缘化CLOSECURLY
21世纪视觉SLAM的一个重要进展是认识到了矩阵ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR的稀疏结构，并发现该结构可以自然、显式地用图优化来表示OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYKummerle2011OCOMMA Polok2013CLOSECURLYCLOSECURLY。本节将详细讨论一下该矩阵稀疏结构。

ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵的稀疏性是由雅可比矩阵ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOPENBRACKETOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSEBRACKETODOLLAR引起的。考虑这些代价函数当中的其中一个ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYODOLLAR。注意到，这个误差项只描述了在ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREiODOLLAR看到ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREjODOLLAR这件事，只涉及第ODOLLARiODOLLAR个相机位姿和第ODOLLARjODOLLAR个路标点，对其余部分的变量的导数都为0。所以该误差项对应的雅可比矩阵有下面的形式：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYOPENBRACKETOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSEBRACKET OASSIGN OBACKSLASHleftOPENBRACKET
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2 OBACKSLASHtimes 6CLOSECURLYOCOMMAODOTODOTODOT
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2 OBACKSLASHtimes 6CLOSECURLYOCOMMA
OBACKSLASHfracOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREiCLOSECURLYOCOMMA
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2 OBACKSLASHtimes 6CLOSECURLYOCOMMAODOTODOTODOT
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2 OBACKSLASHtimes 3CLOSECURLYOCOMMAODOTODOTODOT
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2 OBACKSLASHtimes 3CLOSECURLYOCOMMA
OBACKSLASHfracOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYCLOSECURLYOPENCURLY OBACKSLASHpartial OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREjCLOSECURLYOCOMMA
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2 OBACKSLASHtimes 3CLOSECURLYOCOMMAODOTODOTODOT
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2 OBACKSLASHtimes 3CLOSECURLY 
OBACKSLASHrightCLOSEBRACKET ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

其中ODOLLAROBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2 OBACKSLASHtimes 6CLOSECURLYODOLLAR表示维度为ODOLLAR2 OBACKSLASHtimes 6ODOLLAR的ODOLLAROBACKSLASHbmOPENCURLY0CLOSECURLYODOLLAR矩阵，同理ODOLLAROBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2 OBACKSLASHtimes 3CLOSECURLYODOLLAR也是一样。该误差项对相机姿态的偏导ODOLLAROPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYCLOSECURLYODIVIDEOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYOUNDERSCOREiCLOSECURLYODOLLAR维度为ODOLLAR2 OBACKSLASHtimes 6ODOLLAR，对路标点的偏导ODOLLAROPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYCLOSECURLYODIVIDEOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREjCLOSECURLYODOLLAR维度是ODOLLAR2 OBACKSLASHtimes 3ODOLLAR。这个误差项的雅可比矩阵，除了这两处为非零块之外，其余地方都为零。这体现了该误差项与其他路标和轨迹无关的特性。从图优化角度来说，这条观测边只和两个顶点有关。那么，它对增量方程有何影响？ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵为什么会产生稀疏性呢？

以OBACKSLASHautorefOPENCURLYfigOCOLONsparseCLOSECURLYOTILDE为例，我们设ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYODOLLAR只在ODOLLARiOCOMMAjODOLLAR处有非零块，那么它对ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR的贡献为ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYODOLLAR，具有图上所画的稀疏形式。这个ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYODOLLAR矩阵也仅有4个非零块，位于ODOLLAROPENBRACKETiOCOMMAiCLOSEBRACKETOCOMMA OPENBRACKETiOCOMMAjCLOSEBRACKETOCOMMA OPENBRACKETjOCOMMAiCLOSEBRACKETOCOMMA OPENBRACKETjOCOMMAjCLOSEBRACKETODOLLAR。对于整体的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYHCLOSECURLY OASSIGN OBACKSLASHsumOUNDERSCOREOPENCURLYiOCOMMAjCLOSECURLY OBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYOCOMMA
OBACKSLASHendOPENCURLYequationCLOSECURLY
请注意ODOLLARiODOLLAR在所有相机位姿中取值，ODOLLARjODOLLAR在所有路标点中取值。我们把ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR进行分块：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONHOMINUSblocksCLOSECURLY
OBACKSLASHbmOPENCURLYHCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLY12CLOSECURLYCLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLY21CLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLY22CLOSECURLYCLOSECURLYCLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUARE ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1ODOT0OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEsparseODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLY当某个误差项ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYODOLLAR具有稀疏性时，它对ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR的贡献也具有稀疏形式。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONsparseCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

这里ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYODOLLAR只和相机位姿有关，而ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLY22CLOSECURLYODOLLAR只和路标点有关。当我们遍历ODOLLARiOCOMMAjODOLLAR时，以下事实总是成立的：
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 不管ODOLLARiOCOMMAjODOLLAR怎么变，ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYODOLLAR都是对角阵，只在ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLYiOCOMMAiCLOSECURLYODOLLAR处有非零块。
	OBACKSLASHitem 同理，ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLY22CLOSECURLYODOLLAR也是对角阵，只在ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLYjOCOMMAjCLOSECURLYODOLLAR处有非零块。
	OBACKSLASHitem 对于ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLY12CLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYOUNDERSCOREOPENCURLY21CLOSECURLYODOLLAR，它们可能是稀疏的，也可能是稠密的，视具体的观测数据而定。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

这显示了ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR的稀疏结构。之后对线性方程的求解中，也正需要利用它的稀疏结构。也许读者还没有很好地领会这里的意思，我们举一个实例来直观说明它的情况。假设一个场景内有2个相机位姿（ODOLLARCOUNDERSCORE1OCOMMACOUNDERSCORE2ODOLLAR）和6个路标（ODOLLARPOUNDERSCORE1OCOMMAPOUNDERSCORE2OCOMMAPOUNDERSCORE3OCOMMAPOUNDERSCORE4OCOMMAPOUNDERSCORE5OCOMMAPOUNDERSCORE6ODOLLAR）。这些相机和点云所对应的变量为ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREiOCOMMA i OASSIGN 1OCOMMA2ODOLLAR及ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREjOCOMMA j OASSIGN 1OCOMMAOBACKSLASHcdotsOCOMMA 6ODOLLAR。相机ODOLLARCOUNDERSCORE1ODOLLAR观测到路标ODOLLARPOUNDERSCORE1OCOMMAPOUNDERSCORE2OCOMMAPOUNDERSCORE3OCOMMAPOUNDERSCORE4ODOLLAR，相机ODOLLARCOUNDERSCORE2ODOLLAR观测到路标ODOLLARPOUNDERSCORE3OCOMMAPOUNDERSCORE4OCOMMAPOUNDERSCORE5OCOMMAPOUNDERSCORE6ODOLLAR。我们把这个过程画成示意OBACKSLASHautorefOPENCURLYfigOCOLONsimplegraphCLOSECURLYOTILDE。相机和路标以圆形节点表示。如果ODOLLARiODOLLAR相机能够观测到ODOLLARjODOLLAR点，我们就在它们对应的节点连上一条边。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT8OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEsimplegraphODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLY点和边组成的示意图。该图显示相机ODOLLARCOUNDERSCORE1ODOLLAR观测到了路标点ODOLLARPOUNDERSCORE1OCOMMAPOUNDERSCORE2OCOMMAPOUNDERSCORE3OCOMMAPOUNDERSCORE4ODOLLAR，相机ODOLLARCOUNDERSCORE2ODOLLAR看到了ODOLLARPOUNDERSCORE3ODOLLAR到ODOLLARPOUNDERSCORE6ODOLLAR。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONsimplegraphCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

可以推出，场景下的BA目标函数应该是
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHleftOPENBRACKET OBACKSLASHleftOBACKSLASHVert OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLY OBACKSLASHrightOBACKSLASHVertOHAT2 OPLUS 
OBACKSLASHleftOBACKSLASHVert OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY12CLOSECURLY OBACKSLASHrightOBACKSLASHVertOHAT2 OPLUS 
OBACKSLASHleftOBACKSLASHVert OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY13CLOSECURLY OBACKSLASHrightOBACKSLASHVertOHAT2 OPLUS 
OBACKSLASHleftOBACKSLASHVert OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY14CLOSECURLY OBACKSLASHrightOBACKSLASHVertOHAT2 OPLUS 
OBACKSLASHleftOBACKSLASHVert OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY23CLOSECURLY OBACKSLASHrightOBACKSLASHVertOHAT2 OPLUS 
OBACKSLASHleftOBACKSLASHVert OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY24CLOSECURLY OBACKSLASHrightOBACKSLASHVertOHAT2 OPLUS 
OBACKSLASHleftOBACKSLASHVert OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY25CLOSECURLY OBACKSLASHrightOBACKSLASHVertOHAT2 OPLUS 
OBACKSLASHleftOBACKSLASHVert OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY26CLOSECURLY OBACKSLASHrightOBACKSLASHVertOHAT2 
OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这里的ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYODOLLAR使用之前定义过的代价函数，即式OBACKSLASHeqrefOPENCURLYeqOCOLONBAcostfunctionCLOSECURLY。以ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYODOLLAR为例，它描述了在ODOLLARCOUNDERSCORE1ODOLLAR看到了ODOLLARPOUNDERSCORE1ODOLLAR这件事，与其他的相机位姿和路标无关。令ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYODOLLAR为ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYODOLLAR所对应的雅可比矩阵，不难看出ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYODOLLAR对相机变量ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYOUNDERSCORE2ODOLLAR和路标点ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2OCOMMA OBACKSLASHcdotsOCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE6ODOLLAR的偏导都为0。我们把所有变量以ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLY OASSIGN OBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYOUNDERSCORE2OCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHcdotsOCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2 OBACKSLASHrightCLOSEBRACKETOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR的顺序摆放，则有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLY OASSIGN OBACKSLASHfracOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLY
OASSIGN OBACKSLASHleftOPENBRACKET
OBACKSLASHfracOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYOUNDERSCORE1CLOSECURLYOCOMMA
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2OBACKSLASHtimes 6CLOSECURLYOCOMMA
OBACKSLASHfracOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1CLOSECURLYOCOMMA
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2OBACKSLASHtimes 3CLOSECURLYOCOMMA
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2OBACKSLASHtimes 3CLOSECURLYOCOMMA
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2OBACKSLASHtimes 3CLOSECURLYOCOMMA
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2OBACKSLASHtimes 3CLOSECURLYOCOMMA
OBACKSLASHbmOPENCURLY0CLOSECURLYOUNDERSCOREOPENCURLY2OBACKSLASHtimes 3CLOSECURLY
OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

为了方便表示稀疏性，我们用带有颜色的方块表示矩阵在该方块内有数值，其余没有颜色的区域表示矩阵在该处数值都为0。那么上面的ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYODOLLAR则可以表示成OBACKSLASHautorefOPENCURLYfigOCOLONjaobianrowCLOSECURLYOTILDE所示图案。同理，其他的雅可比矩阵也会有类似的稀疏图案。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOTtCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT8OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEJacobianrowODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLYODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLY11CLOSECURLYODOLLAR矩阵的非零块分布图。上方的标记表示矩阵该列所对应的变量。由于相机参数维数比点云参数维数要大，所以ODOLLARCOUNDERSCORE1ODOLLAR对应的矩阵块要比ODOLLARPOUNDERSCORE1ODOLLAR对应的矩阵块宽一些。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONjaobianrowCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

为了得到该目标函数对应的雅可比矩阵，我们可以将这些ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLYODOLLAR按照一定顺序列为向量，那么整体雅可比矩阵及相应的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵的稀疏情况就如OBACKSLASHautorefOPENCURLYfigOCOLONsimplematrixCLOSECURLYOTILDE所示。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOTtCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEsimplematrixODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLY雅可比矩阵的稀疏性（左）和ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵的稀疏性（右），填色的方块表示矩阵在对应的矩阵块处有数值，其余没有颜色的部分表示矩阵在该处的数值始终为0。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONsimplematrixCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

也许你已经注意到了，OBACKSLASHautorefOPENCURLYfigOCOLONsimplegraphCLOSECURLYOTILDE对应的OBACKSLASHtextbfOPENCURLY邻接矩阵CLOSECURLY（Adjacency Matrix）OBACKSLASHfootnoteOPENCURLY所谓邻接矩阵是这样一种矩阵，它的第ODOLLARiOCOMMAjODOLLAR个元素描述了节点ODOLLARiODOLLAR和ODOLLARjODOLLAR是否存在一条边。如果存在此边，设这个元素为1，否则设为0。CLOSECURLY和上图中的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵，除了对角元素以外的其余部分有着完全一致的结构。事实上的确如此。上面的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵一共有ODOLLAR8 OBACKSLASHtimes 8ODOLLAR个矩阵块，对于ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵当中处于非对角线的矩阵块来说，如果该矩阵块非零，则其位置所对应的变量之间在图中会存在一条边，我们可以从OBACKSLASHautorefOPENCURLYfigOCOLONmatrixandgraphCLOSECURLYOTILDE中清晰地看到这一点。所以，ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵当中的非对角部分的非零矩阵块可以理解为其对应的两个变量之间存在联系，或者可以称之为约束。于是，我们发现图优化结构与增量方程的稀疏性存在着明显的联系。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEmatrixandgraphODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLYODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵中非零矩阵块和图中边的对应关系。如左图ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵中右侧的红色矩阵块，表示在右图中其对应的变量ODOLLARCOUNDERSCORE2ODOLLAR和ODOLLARPOUNDERSCORE6ODOLLAR之间存在一条边ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREOPENCURLY26CLOSECURLYODOLLAR。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONmatrixandgraphCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

现在考虑更一般的情况，假如我们有ODOLLARmODOLLAR个相机位姿，ODOLLARnODOLLAR个路标点。由于通常路标的数量远远多于相机，于是有ODOLLARn OBACKSLASHgg mODOLLAR。由上面的推理可知，实际的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵会如OBACKSLASHautorefOPENCURLYfigOCOLONBigHmatrixCLOSECURLYOTILDE所示。它的左上角块显得非常小，而右下角的对角块占据了大量地方。除此之外，非对角部分则分布着散乱的观测数据。由于它的形状很像箭头，又称为箭头形（ArrowOMINUSlike）矩阵OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYBarfoot2016CLOSECURLYCLOSECURLY。同时，它也很像一把镐子，所以笔者也称其为镐形矩阵OBACKSLASHfootnoteOPENCURLY这是一个玩笑，请不要在正式的学术论文里这样写。CLOSECURLY。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT7OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEBigHmatrixODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLY一般情况下的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONBigHmatrixCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

对于具有这种稀疏结构的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR，线性方程ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLY OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOASSIGN OBACKSLASHbmOPENCURLYgCLOSECURLYODOLLAR的求解会有什么不同呢？现实当中存在着若干种利用ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR的稀疏性加速计算的方法，本节介绍视觉SLAM里一种最常用的手段：Schur消元。在SLAM研究中亦称为Marginalization（边缘化）。

仔细观察一下OBACKSLASHautorefOPENCURLYfigOCOLONBigHmatrixCLOSECURLY，我们不难发现这个矩阵可以分成4个块，和式OBACKSLASHeqrefOPENCURLYeqOCOLONHOMINUSblocksCLOSECURLY一致。左上角为对角块矩阵，每个对角块元素的维度与相机位姿的维度相同，且是一个对角块矩阵。右下角也是对角块矩阵，每个对角块的维度是路标的维度。非对角块的结构与具体观测数据相关。我们首先将这个矩阵按照OBACKSLASHautorefOPENCURLYfigOCOLONMatrixSegmentationCLOSECURLY所示的方式做区域划分，读者不难发现，这4个区域正好对应了公式OBACKSLASHeqrefOPENCURLYeqOCOLONHessianMatrixCLOSECURLY中的4个矩阵块。为了后续分析方便，我们记这4个块为ODOLLAROBACKSLASHbmOPENCURLYBCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYECLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYECLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYCCLOSECURLYODOLLAR。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT5OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEMatrixSegmentationODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLYODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵的区域划分。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONMatrixSegmentationCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

于是，对应的线性方程组也可以由ODOLLAROBACKSLASHbmOPENCURLYHOBACKSLASHDelta xCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYgCLOSECURLYODOLLAR变为如下形式：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONlinearequationsCLOSECURLY
 OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYmatrixCLOSECURLY
OBACKSLASHbmOPENCURLYBCLOSECURLY   OBAND   OBACKSLASHbmOPENCURLYECLOSECURLY OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYEOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OBAND   OBACKSLASHbmOPENCURLYCCLOSECURLY
OBACKSLASHendOPENCURLYmatrixCLOSECURLYOBACKSLASHrightCLOSESQUARE 
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREc OBACKSLASHOBACKSLASH
OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREp 
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN 
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHbmOPENCURLYvCLOSECURLY OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYwCLOSECURLY 
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

其中ODOLLAROBACKSLASHbmOPENCURLYBCLOSECURLYODOLLAR是对角块矩阵，每个对角块的维度和相机参数的维度相同，对角块的个数是相机变量的个数。由于路标数量会远远大于相机变量个数，所以ODOLLAROBACKSLASHbmOPENCURLYCCLOSECURLYODOLLAR往往也远大于ODOLLAROBACKSLASHbmOPENCURLYBCLOSECURLYODOLLAR。三维空间中每个路标点为三维，于是ODOLLAROBACKSLASHbmOPENCURLYCCLOSECURLYODOLLAR矩阵为对角块矩阵，每个块为ODOLLAR3 OBACKSLASHtimes 3ODOLLAR矩阵。对角块矩阵求逆的难度远小于对一般矩阵的求逆难度，因为我们只需要对那些对角线矩阵块分别求逆即可。考虑到这个特性，我们对线性方程组进行高斯消元，目标是消去右上角的非对角部分ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLYOBACKSLASHlabelOPENCURLYeqOCOLONguasseliminationCLOSECURLY
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYmatrixCLOSECURLY
OBACKSLASHbmOPENCURLYICLOSECURLY   OBAND    OMINUSOBACKSLASHbmOPENCURLYECOHATOPENCURLYOMINUS1CLOSECURLYCLOSECURLY OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLY0CLOSECURLY	 OBAND	  OBACKSLASHbmOPENCURLYICLOSECURLY
OBACKSLASHendOPENCURLYmatrixCLOSECURLYOBACKSLASHrightCLOSESQUARE
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYmatrixCLOSECURLY
OBACKSLASHbmOPENCURLYBCLOSECURLY   OBAND   OBACKSLASHbmOPENCURLYECLOSECURLY OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYEOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OBAND   OBACKSLASHbmOPENCURLYCCLOSECURLY
OBACKSLASHendOPENCURLYmatrixCLOSECURLYOBACKSLASHrightCLOSESQUARE 
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREc OBACKSLASHOBACKSLASH
OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREp 
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN 
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYmatrixCLOSECURLY
OBACKSLASHbmOPENCURLYICLOSECURLY   OBAND    OMINUSOBACKSLASHbmOPENCURLYECOHATOPENCURLYOMINUS1CLOSECURLYCLOSECURLY  OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLY0CLOSECURLY	 OBAND	  OBACKSLASHbmOPENCURLYICLOSECURLY
OBACKSLASHendOPENCURLYmatrixCLOSECURLY
OBACKSLASHrightCLOSESQUARE
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHbmOPENCURLYvCLOSECURLY OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYwCLOSECURLY 
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE  ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

整理，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYmatrixCLOSECURLY
OBACKSLASHbmOPENCURLYBCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYECLOSECURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLYOBACKSLASHbmOPENCURLYECLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY	OBAND 	OBACKSLASHbmOPENCURLY0CLOSECURLY OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYECLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY							OBAND 	OBACKSLASHbmOPENCURLYCCLOSECURLY
OBACKSLASHendOPENCURLYmatrixCLOSECURLY OBACKSLASHrightCLOSESQUARE
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREc OBACKSLASHOBACKSLASH
OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREp 
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN 
OBACKSLASHleftOPENSQUAREOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHbmOPENCURLYvCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYECLOSECURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLYOBACKSLASHbmOPENCURLYwCLOSECURLY  OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYwCLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLYOBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

经过消元之后，方程组第一行变成和ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREpODOLLAR无关的项。单独把它拿出来，得到关于位姿部分的增量方程：
OBACKSLASHbeginOPENCURLYequationCLOSECURLYOBACKSLASHlabelOPENCURLYeqOCOLONmarginalizationCLOSECURLY
OBACKSLASHleftOPENSQUARE 
OBACKSLASHbmOPENCURLYBCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYECLOSECURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLYOBACKSLASHbmOPENCURLYECLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY
OBACKSLASHrightCLOSESQUARE
OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREc  OASSIGN 
OBACKSLASHbmOPENCURLYvCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYECLOSECURLYOBACKSLASHbmOPENCURLYCCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLYOBACKSLASHbmOPENCURLYwCLOSECURLY ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这个线性方程的维度和ODOLLAROBACKSLASHbmOPENCURLYBCLOSECURLYODOLLAR矩阵一样。我们的做法是先求解这个方程，然后把解得的ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREcODOLLAR代入到原方程，然后求解ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREpODOLLAR。这个过程称为OBACKSLASHtextbfOPENCURLYMarginalizationCLOSECURLYOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYSibley2010CLOSECURLYCLOSECURLY，或者OBACKSLASHtextbfOPENCURLYSchur消元CLOSECURLY（Schur Elimination）。相比于直接解线性方程的做法，它的优势在于：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 在消元过程中，由于ODOLLAROBACKSLASHbmOPENCURLYCCLOSECURLYODOLLAR为对角块，所以ODOLLAROBACKSLASHbmOPENCURLYCCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLYODOLLAR容易解出。
	OBACKSLASHitem 求解了ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREcODOLLAR之后，路标部分的增量方程由ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREp OASSIGN OBACKSLASHbmOPENCURLYCCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLY OPENBRACKETOBACKSLASHbmOPENCURLYwCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYECLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREcCLOSEBRACKETODOLLAR给出。这依然用到了ODOLLAROBACKSLASHbmOPENCURLYCCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLYODOLLAR易于求解的特性。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

于是，边缘化的主要计算量在于求解式OBACKSLASHeqrefOPENCURLYeqOCOLONmarginalizationCLOSECURLY。关于这个方程，我们能说的就不多了。它仅是一个普通的线性方程，没有特殊的结构可以利用。我们将此方程的系数记为ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR，它的稀疏性如何呢？OBACKSLASHautorefOPENCURLYfigOCOLONmarginalizationCLOSECURLY显示了进行Schur消元之后的一个ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR实例，可以看到它的稀疏性是不规则的。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT5OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEmarginalizationODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLY对ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵进行Schur消元后ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵的稀疏状态。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONmarginalizationCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

前面说到，ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵的非对角块处的非零元素对应着相机和路标的关联。那么，进行了Schur消元后ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR的稀疏性是否具有物理意义呢？答案是肯定的。此处我们不加证明地说，ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵的非对角线上的非零矩阵块，表示了该处对应的两个相机变量之间存在着共同观测的路标点，有时候称为共视（CoOMINUSvisibility）。反之，如果该块为零，则表示这两个相机没有共同观测。例如OBACKSLASHautorefOPENCURLYfigOCOLONmarginalizationanalysisCLOSECURLYOTILDE所示的稀疏矩阵，左上角前ODOLLAR4 OBACKSLASHtimes 4ODOLLAR个矩阵块可以表示对应的相机变量ODOLLARCOUNDERSCORE1OCOMMACOUNDERSCORE2OCOMMACOUNDERSCORE3OCOMMACOUNDERSCORE4ODOLLAR之间有共同观测。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT8OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEmarginalizationanalysisODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLY以ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵中前ODOLLAR4 OBACKSLASHtimes 4ODOLLAR个矩阵块为例，这个区域当中的矩阵块ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYOUNDERSCOREOPENCURLY14CLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYSCLOSECURLYOUNDERSCOREOPENCURLY24CLOSECURLYODOLLAR不为零，表示相机ODOLLARCOUNDERSCORE4ODOLLAR和相机ODOLLARCOUNDERSCORE1ODOLLAR、ODOLLARCOUNDERSCORE2ODOLLAR之间有共同观测点；而ODOLLARSOUNDERSCOREOPENCURLY34CLOSECURLYODOLLAR为零则表示ODOLLARCOUNDERSCORE3ODOLLAR和ODOLLARCOUNDERSCORE4ODOLLAR之间没有共同观测的路标。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONmarginalizationanalysisCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY
OBACKSLASHclearpage
于是，ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵的稀疏性结构当取决于实际观测的结果，我们无法提前预知。在实践当中，例如ORBOMINUSSLAMOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYMurOMINUSArtal2015CLOSECURLYCLOSECURLY中的Local Mapping 环节，在做BA的时候刻意选择那些具有共同观测的帧作为关键帧，在这种情况下Schur消元后得到的ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR就是稠密矩阵。不过，由于这个模块并不是实时执行，所以这种做法也是可以接受的。但是在另一些方法里面，例如DSOOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYEngel2016CLOSECURLYCLOSECURLY、OKVISOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYLeutenegger2015CLOSECURLYCLOSECURLY等，它们采用了滑动窗口方法（Sliding Window）。这类方法对每一帧都要求做一次BA来防止误差的累积，因此它们也必须采用一些技巧来保持ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵的稀疏性。读者如果希望能够更加深入这一块，可以参考它们的论文。这里就不谈这些过于细节的事情了。

从概率角度来看，我们称这一步为边缘化，是因为我们实际上把求ODOLLAROPENBRACKETOBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREcOCOMMA OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREpCLOSEBRACKETODOLLAR的问题，转化成了先固定ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREpODOLLAR，求出ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREcODOLLAR，再求ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREpODOLLAR的过程。这一步相当于做了条件概率展开：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
POPENBRACKET OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREcOCOMMA OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREp CLOSEBRACKET OASSIGN POPENBRACKETOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREc OBBOR OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREp CLOSEBRACKET POPENBRACKET OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREp CLOSEBRACKET OCOMMA
OBACKSLASHendOPENCURLYequationCLOSECURLY

结果是求出了关于ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREpODOLLAR的边缘分布，故称边缘化。在前面讲的边缘化过程中，我们实际把所有的路标点都给边缘化了。根据实际情况，我们也能选择一部分进行边缘化。同时，Schur消元只是实现边缘化的其中一种方式，同样可以使用Cholesky分解进行边缘化。

读者可能会继续问，在进行了Schur消元后，我们还需要求解线性方程组OBACKSLASHeqrefOPENCURLYeqOCOLONmarginalizationCLOSECURLY。对它的求解是否还有什么技巧呢？很遗憾，这部分就属于传统的矩阵数值求解了，通常是用分解来计算的。不管采用哪种求解办法，我们都建议利用ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR的稀疏性进行Schur消元。不光是因为这样可以提高速度，也因为消元后的ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵的条件数往往比之前的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵要小。Schur消元也并不意味着将所有路标消元，将相机变量消元也是SLAM当中采用的手段。

OMODULOOBACKSLASHsubsectionOPENCURLY稀疏线性方程组求解CLOSECURLY
OMODULO在进行了Schur消元后，我们还需要求解线性方程组OBACKSLASHeqrefOPENCURLYeqOCOLONmarginalizationCLOSECURLY。我们将这个式子简写成公式OBACKSLASHeqrefOPENCURLYeqOCOLONreducedBundleAdjustmentCLOSECURLY。其中ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR是维数为ODOLLARmc OBACKSLASHtimes mcODOLLAR的半正定对称矩阵，ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYODOLLAR是维数为ODOLLARmc OBACKSLASHtimes 1ODOLLAR维的向量。
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLYOBACKSLASHlabelOPENCURLYeqOCOLONreducedBundleAdjustmentCLOSECURLY
OMODULOOBACKSLASHbmOPENCURLYSCLOSECURLYOBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREc OASSIGN OBACKSLASHbmOPENCURLYpCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULO读者也许会觉得此处很简单，对ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR求逆或者违逆就可以得到这个方程的解OBACKSLASHeqrefOPENCURLYeqOCOLONreducedBundleAdjustmentCLOSECURLY，这么做理论上的确可以，但是如果你仔细思考一下也会发现，尽管我们这里得到的ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵相比之前的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR来说已经大幅度缩小了维度，但求逆OPENBRACKET或者违逆CLOSEBRACKET依然是个计算量非常大的计算。其实不光是SLAM，其余领域的工程计算也很少会去用求逆OPENBRACKET或者伪逆CLOSEBRACKET这类思路去解决。
OMODULO
OMODULO由于解决线性方程组的方法五花八门，这里并不会将它们拿出来一一介绍。通常在一般情况下，求解线性方程组的方式是LU分解，但在这里，由于我们的ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵是对称的半正定矩阵，可以采用更快速的手段来做。在SLAM或者SFM当中，常见的方法包括Cholesky分解或者ODOLLARLDLOHATTODOLLAR分解。其中Cholesky用来分解正定矩阵，ODOLLARLDLOHATTODOLLAR用来分解对称矩阵，因此这两者的选择主要是看ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵所具有的特点。由于在SLAM里我们通常会让ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵正定，我们接下来会对正定矩阵情况下采用的Cholesky分解方法重点介绍。你也许会好奇为何矩阵的分解会加速这个线性方程组的求解，因此在这之前，我们先回顾一下针对三角矩阵的线性方程组求解方法：
OMODULO
OMODULO假设ODOLLAROBACKSLASHbmOPENCURLYLCLOSECURLYODOLLAR矩阵是维度为ODOLLARn OBACKSLASHtimes nODOLLAR的下三角矩阵，并且对角线上的元素非零。ODOLLAROBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR是维度为ODOLLARn OBACKSLASHtimes 1ODOLLAR的向量OCOMMA那么线性方程组ODOLLAROBACKSLASHbmOPENCURLYLxOASSIGNbCLOSECURLYODOLLAR展开可以得到下面形式：
OMODULOODOLLARODOLLAROBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
OMODULOOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OMODULOOPENCURLYLOUNDERSCOREOPENCURLY11CLOSECURLYCLOSECURLYOPENCURLYxOUNDERSCORE1CLOSECURLYOBACKSLASHOBACKSLASH
OMODULOOPENCURLYLOUNDERSCOREOPENCURLY21CLOSECURLYCLOSECURLYOPENCURLYxOUNDERSCORE1CLOSECURLY OPLUS OPENCURLYLOUNDERSCOREOPENCURLY22CLOSECURLYCLOSECURLYOPENCURLYxOUNDERSCORE2CLOSECURLYOBACKSLASHOBACKSLASH
OMODULOOBACKSLASHvdots OBACKSLASHOBACKSLASH
OMODULOOBACKSLASHvdots OBACKSLASHOBACKSLASH
OMODULOOPENCURLYLOUNDERSCOREOPENCURLYn1CLOSECURLYCLOSECURLYOPENCURLYxOUNDERSCORE1CLOSECURLY OPLUS OPENCURLYLOUNDERSCOREOPENCURLYn2CLOSECURLYCLOSECURLYOPENCURLYxOUNDERSCORE2CLOSECURLY OPLUS  OBACKSLASHcdots  OBACKSLASHcdots OPENCURLYLOUNDERSCOREOPENCURLYnnCLOSECURLYCLOSECURLYOPENCURLYxOUNDERSCOREnCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYarrayCLOSECURLYOBANDOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OMODULOOASSIGN OPENCURLYbOUNDERSCORE1CLOSECURLYOBACKSLASHOBACKSLASH
OMODULOOASSIGN OPENCURLYbOUNDERSCORE2CLOSECURLYOBACKSLASHOBACKSLASH
OMODULOOBACKSLASHvdots OBACKSLASHOBACKSLASH
OMODULOOBACKSLASHvdots OBACKSLASHOBACKSLASH
OMODULOOASSIGN OPENCURLYbOUNDERSCOREnCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYarrayCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYarrayCLOSECURLY	ODOLLARODOLLAR
OMODULO
OMODULO此时，我们可以从第一行直接求出ODOLLARxOUNDERSCORE1ODOLLAR，接着代入第二行ODOLLAROPENCURLYLOUNDERSCOREOPENCURLY21CLOSECURLYCLOSECURLYOPENCURLYxOUNDERSCORE1CLOSECURLY OPLUS OPENCURLYLOUNDERSCOREOPENCURLY22CLOSECURLYCLOSECURLYOPENCURLYxOUNDERSCORE2CLOSECURLY ODOLLAR求出ODOLLARxOUNDERSCORE2ODOLLAR，依次类推可以得到最后的ODOLLARxOUNDERSCOREnODOLLAR。整个过程从ODOLLARxOUNDERSCORE1ODOLLAR一直求出ODOLLARxOUNDERSCOREnODOLLAR，这个过程被称之为OBACKSLASHtextbfOPENCURLY顺向代入CLOSECURLYOPENBRACKETforward substitutionCLOSEBRACKET。其伪代码可以如下表示：
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYalgorithmCLOSECURLYOPENSQUAREhCLOSESQUARE
OMODULO	OBACKSLASHcaptionOPENCURLYOPENBRACKET顺向代入法CLOSEBRACKETCLOSECURLY
OMODULO	OBACKSLASHlabelOPENCURLYalgOCOLONforwardsubstitutionCLOSECURLY
OMODULO	OBACKSLASHbeginOPENCURLYalgorithmicCLOSECURLYOPENSQUARE1CLOSESQUARE
OMODULO		OBACKSLASHREQUIRE
OMODULO		ODOLLAROBACKSLASHbmOPENCURLYLCLOSECURLYODOLLAROCOLON 实数下三角矩阵，对角线元素非零OSEMICOLON
OMODULO		ODOLLAROBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAROCOLON 实数向量；
OMODULO		ODOLLARnODOLLAROCOLON ODOLLAROBACKSLASHbmOPENCURLYLCLOSECURLYODOLLAR的维度OSEMICOLON
OMODULO		OBACKSLASHFOROPENCURLYODOLLARiOASSIGN1ODOLLAR to ODOLLARnODOLLAR CLOSECURLY
OMODULO		
OMODULO		OBACKSLASHSTATE ODOLLARxOUNDERSCOREi OASSIGN OPENBRACKETbOUNDERSCOREi OMINUS OBACKSLASHsumOUNDERSCOREOPENCURLYkOASSIGN0CLOSECURLYOHATOPENCURLYiOMINUS1CLOSECURLYOPENCURLYLOUNDERSCOREOPENCURLYikCLOSECURLYxOUNDERSCOREkCLOSECURLYCLOSEBRACKETODIVIDELOUNDERSCOREOPENCURLYiiCLOSECURLYODOLLAROSEMICOLON
OMODULO		
OMODULO		OBACKSLASHENDFOR
OMODULO		
OMODULO		OBACKSLASHRETURN
OMODULO		ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR
OMODULO	OBACKSLASHendOPENCURLYalgorithmicCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYalgorithmCLOSECURLY
OMODULO
OMODULO当然，当ODOLLAROBACKSLASHbmOPENCURLYLCLOSECURLYODOLLAR为一个上三角矩阵的时候，则对应的代入顺序则是先求出最后一项ODOLLARxOUNDERSCOREnODOLLAR，然后一直代入最后求出ODOLLARxOUNDERSCORE1ODOLLAR。这个过程被成为OBACKSLASHtextbfOPENCURLY逆向代入法CLOSECURLYOPENBRACKETback substitutionCLOSEBRACKET。对应的伪代码则如下：
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYalgorithmCLOSECURLYOPENSQUAREhCLOSESQUARE
OMODULO	OBACKSLASHcaptionOPENCURLYOPENBRACKET逆向代入法CLOSEBRACKETCLOSECURLY
OMODULO	OBACKSLASHlabelOPENCURLYalgOCOLONbacksubstitutionCLOSECURLY
OMODULO	OBACKSLASHbeginOPENCURLYalgorithmicCLOSECURLYOPENSQUARE1CLOSESQUARE
OMODULO		OBACKSLASHREQUIRE
OMODULO		ODOLLAROBACKSLASHbmOPENCURLYLCLOSECURLYODOLLAROCOLON 实数下三角矩阵，对角线元素非零OSEMICOLON
OMODULO		ODOLLAROBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAROCOLON 实数向量；
OMODULO		ODOLLARnODOLLAROCOLON ODOLLAROBACKSLASHbmOPENCURLYLCLOSECURLYODOLLAR的维度OSEMICOLON
OMODULO		OBACKSLASHFOROPENCURLYODOLLARiOASSIGNnODOLLAR to ODOLLAR1ODOLLAR CLOSECURLY
OMODULO		
OMODULO		OBACKSLASHSTATE ODOLLARxOUNDERSCOREi OASSIGN OPENBRACKETbOUNDERSCOREi OMINUS OBACKSLASHsumOUNDERSCOREOPENCURLYkOASSIGNiCLOSECURLYOHATOPENCURLYnCLOSECURLYOPENCURLYLOUNDERSCOREOPENCURLYikCLOSECURLYxOUNDERSCOREkCLOSECURLYCLOSEBRACKETODIVIDELOUNDERSCOREOPENCURLYiiCLOSECURLYODOLLAROSEMICOLON
OMODULO		
OMODULO		OBACKSLASHENDFOR
OMODULO		
OMODULO		OBACKSLASHRETURN
OMODULO		ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR
OMODULO	OBACKSLASHendOPENCURLYalgorithmicCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYalgorithmCLOSECURLY
OMODULO
OMODULO基于三角矩阵的这类优秀特性，在解决线性方程组的时候先将其分解为三角矩阵是常用的求解方法之一。我们要介绍的Cholesky分解是将一个正定矩阵ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR分解为ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYLCLOSECURLYOBACKSLASHbmOPENCURLYLOHATTCLOSECURLYODOLLAR的形式，当ODOLLAROBACKSLASHbmOPENCURLYLCLOSECURLYODOLLAR矩阵对角线元素为正数的时候，分解结果具有唯一性。Cholesky分解的操作也非常简单，即从对角线元素开始，依次将对角线元素下方的每一列递推完成：
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYalgorithmCLOSECURLYOPENSQUAREhCLOSESQUARE
OMODULO	OBACKSLASHcaptionOPENCURLYOPENBRACKETCholesky 分解CLOSEBRACKETCLOSECURLY
OMODULO	OBACKSLASHlabelOPENCURLYalgOCOLONCholeskyDecompositionCLOSECURLY
OMODULO	OBACKSLASHbeginOPENCURLYalgorithmicCLOSECURLYOPENSQUARE1CLOSESQUARE
OMODULO		OBACKSLASHREQUIRE
OMODULO		ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAROCOLON 实数正定矩阵OSEMICOLON
OMODULO		ODOLLARnODOLLAROCOLON 正定矩阵ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR的维度OSEMICOLON
OMODULO		OBACKSLASHFOROPENCURLYODOLLARjOASSIGN1ODOLLAR to ODOLLARnODOLLARCLOSECURLY
OMODULO		
OMODULO		OBACKSLASHSTATE ODOLLAROBACKSLASHbmOPENCURLYLCLOSECURLYOUNDERSCOREOPENCURLYjjCLOSECURLY OASSIGN OBACKSLASHsqrtOPENCURLYOBACKSLASHbmOPENCURLYSCLOSECURLYOUNDERSCOREOPENCURLYjjCLOSECURLY OMINUS OBACKSLASHsumOUNDERSCOREOPENCURLYkOASSIGN1CLOSECURLYOHATOPENCURLYjOMINUS1CLOSECURLYOPENCURLYLOUNDERSCOREOPENCURLYjkCLOSECURLYOHAT2CLOSECURLYCLOSECURLYODOLLAROSEMICOLON
OMODULO		
OMODULO		OBACKSLASHFOROPENCURLYODOLLARiOASSIGNjOPLUS1ODOLLAR to ODOLLARnODOLLARCLOSECURLY
OMODULO		OBACKSLASHSTATE ODOLLAROBACKSLASHbmOPENCURLYLCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLY OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYLCLOSECURLYOUNDERSCOREOPENCURLYjjCLOSECURLYCLOSECURLYOPENBRACKETOBACKSLASHbmOPENCURLYSCLOSECURLYOUNDERSCOREOPENCURLYijCLOSECURLY OMINUS OBACKSLASHsumOUNDERSCOREOPENCURLYkOASSIGN1CLOSECURLYOHATOPENCURLYjOMINUS1CLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYLCLOSECURLYOUNDERSCOREOPENCURLYikCLOSECURLYOBACKSLASHbmOPENCURLYLCLOSECURLYOUNDERSCOREOPENCURLYjkCLOSECURLYCLOSECURLYCLOSEBRACKETODOLLAROSEMICOLON
OMODULO		OBACKSLASHENDFOR
OMODULO		
OMODULO		OBACKSLASHENDFOR
OMODULO		OBACKSLASHRETURN
OMODULO		ODOLLAROBACKSLASHbmOPENCURLYLCLOSECURLYODOLLAR 
OMODULO	OBACKSLASHendOPENCURLYalgorithmicCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYalgorithmCLOSECURLY
OMODULO
OMODULO容易看出，该算法的复杂度为ODOLLAROOPENBRACKETnOHAT3CLOSEBRACKETODOLLAR，其中ODOLLARnODOLLAR为矩阵的维度。在对OBACKSLASHeqrefOPENCURLYeqOCOLONreducedBundleAdjustmentCLOSECURLY进行了Cholesky分解之后，我们需要求解的线性方程组则变成了ODOLLAROBACKSLASHbmOPENCURLYLLOHATTCLOSECURLYOBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREc OASSIGN OBACKSLASHbmOPENCURLYpCLOSECURLYODOLLAR。为了充分利用三角矩阵求解带来的便利，我们将ODOLLAROBACKSLASHbmOPENCURLYLOHATTCLOSECURLY OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREcODOLLAR 这个向量记作ODOLLAROBACKSLASHbmOPENCURLYyCLOSECURLYODOLLAR。这样一来，我们可以首先求解ODOLLAROBACKSLASHbmOPENCURLYLyOASSIGNbCLOSECURLYODOLLAR来得到ODOLLAROBACKSLASHbmOPENCURLYyCLOSECURLYODOLLAR，接着再次借助三角矩阵求解带来的便利来求ODOLLAROBACKSLASHbmOPENCURLYLOHATTCLOSECURLY OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREc OASSIGN OBACKSLASHbmOPENCURLYyCLOSECURLYODOLLAR，从而得到最终的ODOLLAROBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREc ODOLLAR。这样我们不难总结出，使用Cholesky分解求解线性方程组的流程大致如下OCOLON
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYalgorithmCLOSECURLYOPENSQUAREhCLOSESQUARE
OMODULO	OBACKSLASHcaptionOPENCURLYOPENBRACKETCholesky 分解求解线性方程组CLOSEBRACKETCLOSECURLY
OMODULO	OBACKSLASHlabelOPENCURLYalgOCOLONCholeskyLinearsolverCLOSECURLY
OMODULO	OBACKSLASHbeginOPENCURLYalgorithmicCLOSECURLYOPENSQUARE1CLOSESQUARE
OMODULO		OBACKSLASHREQUIRE
OMODULO		ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAROCOLON 实数正定矩阵
OMODULO		ODOLLARnODOLLAROCOLON 正定矩阵ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR的维度
OMODULO		ODOLLAROBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAROCOLON 维数为ODOLLARn OBACKSLASHtimes 1ODOLLAR的实数向量
OMODULO		OBACKSLASHSTATE 使用OPENBRACKETOBACKSLASHrefOPENCURLYalgOCOLONCholeskyDecompositionCLOSECURLYCLOSEBRACKET将矩阵ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR进行Cholesky分解，得到其对应的下三角矩阵ODOLLAROBACKSLASHbmOPENCURLYLCLOSECURLYODOLLAROSEMICOLON
OMODULO		
OMODULO		OBACKSLASHSTATE 使用顺向代入法OPENBRACKETOBACKSLASHrefOPENCURLYalgOCOLONforwardsubstitutionCLOSECURLYCLOSEBRACKET求解线性方程组ODOLLAROBACKSLASHbmOPENCURLYLy OASSIGN bCLOSECURLYODOLLAR，得到向量ODOLLAROBACKSLASHbmOPENCURLYyCLOSECURLYODOLLAROSEMICOLON
OMODULO		
OMODULO		OBACKSLASHSTATE 使用逆向代入法OPENBRACKETOBACKSLASHrefOPENCURLYalgOCOLONbacksubstitutionCLOSECURLYCLOSEBRACKET求解线性方程组ODOLLAROBACKSLASHbmOPENCURLYLOHATTx OASSIGN yCLOSECURLYODOLLAR，得到向量ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAROSEMICOLON
OMODULO	
OMODULO		OBACKSLASHRETURN
OMODULO		ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR 
OMODULO	OBACKSLASHendOPENCURLYalgorithmicCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYalgorithmCLOSECURLY
OMODULO
OMODULO对于半正定的矩阵来说，通常的做法就是在加上一个比较小的对角矩阵，然后让其可逆。当然我们还需要考虑一类情况，那就是ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵为稀疏矩阵的时候，这就会涉及到稀疏矩阵线性方程组的求解问题。稀疏性会给SLAM提供很大的便利，不光是从算法速度上，还是从算法占用的内存空间上。稀疏矩阵的存储有很多种，其中最简单的就是仅仅只保存非零元素所在的行列以及自身的数值，最后放在一个Hash表里进行管理。但稀疏矩阵的数据结构会根据算法所需进行定制。
OMODULO
OMODULO好在这些底层的数学内容，现有的很多算法库都已经做的挺完整，比如CHOLMODOBACKSLASHciteOPENCURLYchen2008algorithmCLOSECURLY，CSparseOBACKSLASHciteOPENCURLYdavis2005csparseCLOSECURLY这类高效的Cholesky分解算法库已经用在广泛的工业界和学术界，连著名的软件MATLAB也是调用的它，也有SuitsparseOBACKSLASHciteOPENCURLYdavis2014suitesparseCLOSECURLY这类算法库集成了针对稀疏矩阵的各种分解的高效算法，因此绝大多数人都可以忽略这些理论上的细节，选择去熟悉这些算法库的调用也是可取的。
OMODULO
OMODULO但为了方便读者熟悉各类SLAM的前沿理论研究，笔者还是得对稀疏矩阵进行简要的描述。在研究稀疏矩阵的分解操作时，有个概念叫做OBACKSLASHtextbfOPENCURLY填充CLOSECURLYOPENBRACKETfillOMINUSinCLOSEBRACKET。这个概念指的是在稀疏矩阵原本为0的位置当中，其中某些位置在其分解后变成了带有数值的元素。比如下面对我们对箭头型矩阵直接进行Cholesky分解，就会出现OBACKSLASHautorefOPENCURLYfigOCOLONArrowMatrixCLOSECURLY这样的情况。我们可以发现，再进行了Cholesky分解后，箭头矩阵那些原本为零的地方几乎全被OBACKSLASHtextbfOPENCURLY填充CLOSECURLY了。
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
OMODULO	OBACKSLASHcentering
OMODULO	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT8OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEarrowMatrixODOTpdfCLOSECURLY
OMODULO	OBACKSLASHcaptionOPENCURLY箭头矩阵OPENBRACKET左CLOSEBRACKET和其对应的Cholesky分解矩阵OPENBRACKET右CLOSEBRACKET，Cholesky分解将原本稀疏的矩阵变成了稠密矩阵CLOSECURLY
OMODULO	OBACKSLASHlabelOPENCURLYfigOCOLONArrowMatrixCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYfigureCLOSECURLY
OMODULO
OMODULO由于我们对矩阵进行Cholesky分解的目的是为了求解线性方程组ODOLLAROBACKSLASHbmOPENCURLYSxOASSIGNpCLOSECURLYODOLLAR，我们可以改变向量ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR当中的元素顺序，这种改变也只是需要对ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR当中的非零成员出现的位置，不需要对ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR进行重新计算。比如针对OBACKSLASHautorefOPENCURLYfigOCOLONArrowMatrixCLOSECURLY的箭头矩阵所对应的线性系统ODOLLAROBACKSLASHbmOPENCURLYSxOASSIGNpCLOSECURLYODOLLAR来说，我们将整个ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR当中所有变量的顺序颠倒，那么其对应的ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵以及它的Cholesky分解就会出现OBACKSLASHautorefOPENCURLYfigOCOLONArrowMatrixPermuteCLOSECURLY这样的情况，Cholesky分解后依然是个稀疏矩阵，甚至连稀疏的图案都和原矩阵一模一样。
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
OMODULO	OBACKSLASHcentering
OMODULO	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT8OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEarrowMatrixPermuteODOTpdfCLOSECURLY
OMODULO	OBACKSLASHcaptionOPENCURLY调换顺序箭头矩阵OPENBRACKET左CLOSEBRACKET和其对应的Cholesky分解矩阵OPENBRACKET右CLOSEBRACKET，Cholesky分解后依然是稀疏矩阵，并且和原矩阵具有一模一样的稀疏形式。CLOSECURLY
OMODULO	OBACKSLASHlabelOPENCURLYfigOCOLONArrowMatrixPermuteCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYfigureCLOSECURLY
OMODULO
OMODULO显而易见，这样被排序后不但丝毫不影响线性方程组的求解，甚至我们在做后面的正向或者逆向代入法的时候，由于分解保持了稀疏性可以节约大量的乘法和加法运算从而提高了计算效率。同时，更具有吸引力的是，我们依然可以用原来稀疏矩阵的数据结构保存这个Cholesky分解后的矩阵，我们也不需要开辟新的存储空间，直接在原有的数据结构上不断计算和覆盖即可。如果是排序前OBACKSLASHeqrefOPENCURLYfigOCOLONArrowMatrixCLOSECURLY那类情况就太糟糕了，我们不仅需要更多的内存空间来保存这个矩阵，同时也需要更换这个矩阵的数据结构OPENBRACKET用Hash表这类对付稀疏矩阵的数据结构来保存稠密矩阵将是个复杂低效的方法CLOSEBRACKET。由此在对稀疏矩阵进行线性方程组求解之前，为了更加高效我们最好先使用OBACKSLASHtextbfOPENCURLY排序CLOSECURLYOPENBRACKETorderingCLOSEBRACKET这类操作来尽可能避免过多的填充现象。
OMODULO
OMODULO至于这类减少填充的排序的算法，由于种类及其繁多，读者可以参考OBACKSLASHciteOPENCURLYagarwal2012variableCLOSECURLY。其中非常具有影响力的是EMD算法OPENBRACKETExact Minimum DegreeCLOSEBRACKET，该算法针对矩阵对应的图不断地选取具有OBACKSLASHtextbfOPENCURLY最小度CLOSECURLYOPENBRACKETDegreeCLOSEBRACKET的节点而得到该矩阵对应的顺序。但值得说明的是，这种排序算法都是OBACKSLASHtextbfOPENCURLYNP难CLOSECURLY问题OPENBRACKETNPOMINUScomplete，即在多项式时间内无法保证解决的问题CLOSEBRACKET。正是因为如此，这里我也需要提醒读者，并不是所有排序都能使得整个线性系统变得更加快速。因此，为了真正保证有加速的作用，建议读者还是运行比较一下两者的运行时间从而进行选择。
OMODULO
OMODULOOBACKSLASHsubsectionOPENCURLYQR分解求解Bundle Adjustment CLOSECURLY
OMODULOBundle Adjustment的解决方法也不止我们上面详细介绍的这一种，例如我们接下来将简单地介绍一类方法可以避免解算ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵，直接通过QR分解来求解最小二乘方程OBACKSLASHeqrefOPENCURLYeqOCOLONBAleastsquareCLOSECURLY。
OMODULO
OMODULOQR分解是将矩阵分解为单位正交矩阵ODOLLAROBACKSLASHbmOPENCURLYQCLOSECURLYODOLLAR和上三角矩阵ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR的操作，即ODOLLAROBACKSLASHbmOPENCURLYJOASSIGNQRCLOSECURLYODOLLAR。QR分解的方法也有很多，例如给定旋转OPENBRACKETGiven RotationCLOSEBRACKET，Householder 变换，GramOMINUSSchmidt正交化等，这里不一一介绍，具体可以参考OBACKSLASHciteOPENCURLYgolub2012matrixCLOSECURLY。QR分解当中一个非常重要的定理，就是当ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYODOLLAR的维度是ODOLLARm OBACKSLASHtimes nOCOMMA OPENBRACKETm OBACKSLASHge nCLOSEBRACKETODOLLAR，且列满秩矩阵的时候，矩阵ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYODOLLAR的QR分解为如下形式：
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYdisplaymathCLOSECURLY
OMODULOOBACKSLASHbmOPENCURLYJOASSIGNQRCLOSECURLY OASSIGN OBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYQCLOSECURLYCLOSECURLYOUNDERSCORE1CLOSECURLYOCOMMAOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYQCLOSECURLYCLOSECURLYOUNDERSCORE2CLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
OMODULO		OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE1CLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
OMODULO		 OBACKSLASHbmOPENCURLY0CLOSECURLY
OMODULO		OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OASSIGN OBACKSLASHbmOPENCURLYQCLOSECURLYOUNDERSCORE1 OBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE1
OMODULOOBACKSLASHendOPENCURLYdisplaymathCLOSECURLY
OMODULO
OMODULO此时ODOLLAROBACKSLASHbmOPENCURLYJOASSIGNQOUNDERSCORE1 ROUNDERSCORE1CLOSECURLYODOLLAR是该分解的OBACKSLASHtextbfOPENCURLY紧凑形式CLOSECURLYOPENBRACKETthin QR decompositionCLOSEBRACKET，其中 ODOLLAROBACKSLASHbmOPENCURLYQOUNDERSCORE1CLOSECURLY OBACKSLASHin OBACKSLASHbmOPENCURLYOBACKSLASHmathbbOPENCURLYRCLOSECURLYOHATOPENCURLYm OBACKSLASHtimes nCLOSECURLYCLOSECURLYODOLLAR，由一系列单位正交的列向量组成OPENBRACKET即ODOLLAROBACKSLASHbmOPENCURLYQOUNDERSCORE1OHATTQOUNDERSCORE1 OASSIGN IOUNDERSCOREnCLOSECURLYODOLLARCLOSEBRACKET；同时ODOLLAROBACKSLASHbmOPENCURLYROUNDERSCORE1CLOSECURLYODOLLAR是维度为ODOLLARn OBACKSLASHtimes nODOLLAR的上三角矩阵，而且对角线元素均大于0。
OMODULO
OMODULO由于ODOLLAROBACKSLASHbmOPENCURLYQCLOSECURLYODOLLAR是单位正交矩阵，我们有ODOLLAROPENCURLYOBACKSLASHleftOBACKSLASHOBBOR OBACKSLASHbmOPENCURLYQOHATTyCLOSECURLY OBACKSLASHrightOBACKSLASHOBBOROUNDERSCORE2CLOSECURLY OASSIGN OPENCURLYOBACKSLASHleftOBACKSLASHOBBOR OBACKSLASHbmOPENCURLYyCLOSECURLY OBACKSLASHrightOBACKSLASHOBBOROUNDERSCORE2CLOSECURLYODOLLAR，所以我们不难推出：
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYalignOMULTIPLYCLOSECURLY
OMODULOOBACKSLASHleftOBACKSLASHOBBOR OBACKSLASHbmOPENCURLYJx OPLUS fCLOSECURLY OBACKSLASHrightOBACKSLASHOBBOROHAT2 OBANDOASSIGN 
OMODULOOBACKSLASHleftOBACKSLASHOBBOR OPENBRACKETOBACKSLASHbmOPENCURLYQOUNDERSCORE1CLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYQOUNDERSCORE2CLOSECURLYCLOSEBRACKETOPENBRACKETOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
OMODULO		OBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE1OBACKSLASHOBACKSLASH
OMODULO		OBACKSLASHbmOPENCURLY0CLOSECURLY
OMODULO		OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSEBRACKETOBACKSLASHbmOPENCURLYxCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYfCLOSECURLY OBACKSLASHrightOBACKSLASHOBBOROHAT2 OBACKSLASHOBACKSLASH OBANDOASSIGN 
OMODULOOBACKSLASHleftOBACKSLASHOBBOR OBACKSLASHleftOPENBRACKET OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
OMODULO			OBACKSLASHbmOPENCURLYQCLOSECURLYOUNDERSCORE1OHATTOBACKSLASHOBACKSLASH
OMODULO			OBACKSLASHbmOPENCURLYQCLOSECURLYOUNDERSCORE2OHATT
OMODULO			OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSEBRACKETOPENBRACKETOBACKSLASHbmOPENCURLYQOUNDERSCORE1CLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYQOUNDERSCORE2CLOSECURLYCLOSEBRACKETOPENBRACKETOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
OMODULO		OBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE1OBACKSLASHOBACKSLASH
OMODULO		OBACKSLASHbmOPENCURLY0CLOSECURLY
OMODULO		OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSEBRACKETOBACKSLASHbmOPENCURLYxCLOSECURLY OPLUS OBACKSLASHleftOPENBRACKET OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
OMODULO			OBACKSLASHbmOPENCURLYQCLOSECURLYOUNDERSCORE1OBACKSLASHOBACKSLASH
OMODULO			OBACKSLASHbmOPENCURLYQCLOSECURLYOUNDERSCORE2
OMODULO			OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSEBRACKETOBACKSLASHbmOPENCURLYfCLOSECURLY OBACKSLASHrightOBACKSLASHOBBOROHAT2 OBACKSLASHOBACKSLASH OBANDOASSIGN 
OMODULOOBACKSLASHleftOBACKSLASHOBBOR OBACKSLASHbmOPENCURLYROUNDERSCORE1 xCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYQCLOSECURLYOUNDERSCORE1OHATTOBACKSLASHbmOPENCURLYfCLOSECURLY OBACKSLASHrightOBACKSLASHOBBOROHAT2 OPLUS OBACKSLASHleftOBACKSLASHOBBOR OBACKSLASHbmOPENCURLYQCLOSECURLYOUNDERSCORE2OHATTOBACKSLASHbmOPENCURLYfCLOSECURLY OBACKSLASHrightOBACKSLASHOBBOROHAT2
OMODULOOBACKSLASHendOPENCURLYalignOMULTIPLYCLOSECURLY
OMODULO
OMODULO这样，我们不难看出，由于ODOLLAROBACKSLASHbmOPENCURLYROUNDERSCORE1CLOSECURLYODOLLAR是上三角矩阵，该最小二乘的最优解就是用前面提到的逆向代入法求解方程组：
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYdisplaymathCLOSECURLY
OMODULOOBACKSLASHbmOPENCURLYROUNDERSCORE1 xCLOSECURLY OASSIGN OMINUSOBACKSLASHbmOPENCURLYQOUNDERSCORE1OHATT fCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYdisplaymathCLOSECURLY
OMODULO
OMODULO该方法也同样需要讲究使用前面的排序手段来保持矩阵ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE1ODOLLAR的稀疏性，但由于该分解方法远远没有Schur消元后进行Cholesky分解的方法快速，现实中很少采纳。但值得一提的是，QR分解却是比Cholesky分解数值上更加稳定的方法。
OMODULO
OMODULO线性系统的稳定性是实战中不可忽略的分析部分，因为由于处理器精度的限制OPENBRACKET例如双精度浮点数只有16位有效数字，则精度的数量级是ODOLLAR10OHATOPENCURLYOMINUS16CLOSECURLYODOLLARCLOSEBRACKET，有的低端处理器又只能让你使用单精度浮点数，因此任何情况下我们对矩阵的计算都存在截断误差。这种截断误差对矩阵的影响，可以说是对矩阵的一种OBACKSLASHtextbfOPENCURLY扰动CLOSECURLY，我们并不希望这类扰动对最后的求解结果带来太大影响。具体的分析需要用到矩阵的OBACKSLASHtextbfOPENCURLY条件数CLOSECURLYOPENBRACKETCondition numberCLOSEBRACKET，这又是一些复杂的数学内容，我推荐希望深入的读者参考书籍OBACKSLASHciteOPENCURLYgolub2012matrixCLOSECURLY。但需要我们记住的是，相比前面提到的Cholesky分解而言，QR分解是个速度慢但是数值上更稳定的选择。

OBACKSLASHsubsectionOPENCURLY鲁棒核函数CLOSECURLY
在前面的BA问题中，我们最小化误差项的二范数平方和作为目标函数。这种做法虽然很直观，但存在一个严重的问题：如果出于误匹配等原因，某个误差项给的数据是错误的，会发生什么呢？我们把一条原本不应该加到图中的边给加进去了，然而优化算法并不能辨别出这是个错误数据，它会把所有的数据都当作误差来处理。这个数据在算法看来，是观测到了一次很小概率看到的数据。这时，在图优化中会有一条误差很大的边，它的梯度也很大，意味着调整与它相关的变量会使目标函数下降更多。所以，算法将试图优先调整这条边所连接的节点的估计值，使它们顺应这条边的无理要求。由于这条边的误差真的很大，往往会抹平了其他正确边的影响，使优化算法专注于调整一个错误的值。这显然不是我们希望看到的。

出现这种问题的原因是，当误差很大时，二范数增长得太快。于是就有了核函数的存在。核函数保证每条边的误差不会大得没边而掩盖掉其他的边。具体的方式是，把原先误差的二范数度量替换成一个增长没有那么快的函数，同时保证自己的光滑性质（不然无法求导！）。因为它们使得整个优化结果更为稳健，所以又叫它们鲁棒核函数（Robust Kernel）。

鲁棒核函数有许多种，例如最常用的Huber核：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
HOBACKSLASHleftOPENBRACKET e OBACKSLASHrightCLOSEBRACKET OASSIGN 
OBACKSLASHleftOBACKSLASHOPENCURLY 
OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYllCLOSECURLY
OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOPENCURLYeOHAT2CLOSECURLY OBANDOBACKSLASHquad OBACKSLASHtextOPENCURLY当CLOSECURLY OBBOReOBBOR OBACKSLASHleqslant OBACKSLASHdeltaOCOMMA OBACKSLASHOBACKSLASH
OBACKSLASHdelta OBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHleftOBBOR e OBACKSLASHrightOBBOR OMINUS OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHdelta CLOSECURLY OBACKSLASHrightCLOSEBRACKET OBANDOBACKSLASHquad OBACKSLASHtextOPENCURLY其他CLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

我们看到，当误差ODOLLAReODOLLAR大于某个阈值ODOLLAROBACKSLASHdeltaODOLLAR后，函数增长由二次形式变成了一次形式，相当于限制了梯度的最大值。同时，Huber核函数又是光滑的，可以很方便地求导。OBACKSLASHautorefOPENCURLYfigOCOLONhuberCLOSECURLYOTILDE显示了Huber核函数与二次函数的对比，可见在误差较大时Huber核函数增长明显低于二次函数。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT5OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEhuberlossCLOSECURLY
	OBACKSLASHcaptionOPENCURLYHuber核函数。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONhuberCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

除了Huber核之外，还有Cauchy核、Tukey核，等等，读者可以看看g2o和Ceres都提供了哪些核函数。

OBACKSLASHsubsectionOPENCURLY小结CLOSECURLY
本节我们重点介绍了BA中的稀疏性问题。不过，实践当中，多数软件库已经为我们实现了细节操作，而我们需要做的主要是构造Bundle Adjustment问题，设置Schur消元，然后调用稠密或者稀疏矩阵求解器对变量进行优化即可。如果读者希望更深入地了解BA，可以在阅读完本节的基础上，进一步参考文献OBACKSLASHciteOPENCURLYTriggs2000CLOSECURLY学习。

下面的两节，我们将使用Ceres和g2o两个库来做Bundle Adjustment。为了体现出它们的区别，我们会使用一个公开数据集BALOBACKSLASHtextsubscriptOPENCURLYOBACKSLASHciteOPENCURLYbundleadjustmentinlargeCLOSECURLYCLOSECURLY，并使用共用的读写代码。

OBACKSLASHsectionOPENCURLY实践：Ceres BACLOSECURLY
OBACKSLASHsubsectionOPENCURLYBAL数据集CLOSECURLY
我们用BAL数据集进行BA的演示实验。BAL数据集提供若干个场景，每一个场景里的相机和路标点信息由一个文本文件给定。在本例中，使用problemOMINUS16OMINUS22106OMINUSpreODOTtxt这个文件作为例子。该文件的以行的方式存储BA问题的信息，详细格式见 。我们用commonODOTh中定义的BALProblem类读入该文件的内容，然后分别用Ceres和g2o求解。

需要注意的是，BAL这个数据集有它一些特殊之处：
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
OBACKSLASHitem BAL的相机内参模型由焦距ODOLLARfODOLLAR和畸变参数ODOLLARkOUNDERSCORE1OCOMMAkOUNDERSCORE2ODOLLAR给出。ODOLLARfODOLLAR类似于我们提到的ODOLLARfOUNDERSCORExODOLLAR和ODOLLARfOUNDERSCOREyODOLLAR。由于照片像素基本上是正方形，所以很多实际场合中ODOLLARfOUNDERSCORExODOLLAR非常接近ODOLLARfOUNDERSCOREyODOLLAR，用同一个值也未尝不可。此外，这个模型中没有ODOLLARcOUNDERSCORExOCOMMAcOUNDERSCOREyODOLLAR，因为存储的数据已经去掉了这两个值。
OBACKSLASHitem BAL数据在投影时假设投影平面在相机光心之后，所以按照我们之前用的模型计算的话，需要在投影之后乘以系数ODOLLAROMINUS1ODOLLAR。不过，大部分数据集仍使用光心前面的投影平面，我们在使用数据集之前应该仔细阅读格式说明。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

用BALProblem类读取数据之后，我们可以调用Normalize函数对原始数据进行归一化，或通过Perturb函数给数据加上噪声。归一化是指将所有路标点的中心置零，然后做一个合适尺度的缩放。这会使优化过程中数值更加稳定一些，防止在极端情况下处理很大或者有很大偏移的BA问题。

请读者自行阅读BALProblem类的其他接口。由于这些代码只负责读写数据等外围功能，为节省篇幅，我们不在正文中给出。在解出BA之后，我们还可以用该类的函数将结果写入一个ply文件（一种点云文件格式），然后用meshlab软件进行查看。meshlab可以通过aptOMINUSget安装，在此不赘述安装方式。

OBACKSLASHsubsectionOPENCURLYCeres BA的书写CLOSECURLY
在bundleOBACKSLASHOUNDERSCOREadjustmentOBACKSLASHOUNDERSCOREceresODOTcpp文件中，我们实现了Ceres求解BA的过程。用Ceres的关键是定义出投影误差模型，该部分代码在SnavelyReprojectionErrorODOTh中给出：

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMA captionOASSIGNslambook2ODIVIDEch9ODIVIDESnavelyReprojectionErrorODOTcpp（片段）CLOSESQUARE
class SnavelyReprojectionError OPENCURLY
publicOCOLON
	SnavelyReprojectionErrorOPENBRACKETdouble observationOUNDERSCORExOCOMMA double observationOUNDERSCOREyCLOSEBRACKET OCOLON observedOUNDERSCORExOPENBRACKETobservationOUNDERSCORExCLOSEBRACKETOCOMMA
	observedOUNDERSCOREyOPENBRACKETobservationOUNDERSCOREyCLOSEBRACKET OPENCURLYCLOSECURLY
	
	templateOGREATtypename TOLESS
	bool operatorOPENBRACKETCLOSEBRACKETOPENBRACKETconst T OMULTIPLYconst cameraOCOMMA
		const T OMULTIPLYconst pointOCOMMA
		T OMULTIPLYresidualsCLOSEBRACKET const OPENCURLY
		ODIVIDEODIVIDE cameraOPENSQUARE0OCOMMA1OCOMMA2CLOSESQUARE are the angleOMINUSaxis rotation
		T predictionsOPENSQUARE2CLOSESQUAREOSEMICOLON
		CamProjectionWithDistortionOPENBRACKETcameraOCOMMA pointOCOMMA predictionsCLOSEBRACKETOSEMICOLON
		residualsOPENSQUARE0CLOSESQUARE OASSIGN predictionsOPENSQUARE0CLOSESQUARE OMINUS TOPENBRACKETobservedOUNDERSCORExCLOSEBRACKETOSEMICOLON
		residualsOPENSQUARE1CLOSESQUARE OASSIGN predictionsOPENSQUARE1CLOSESQUARE OMINUS TOPENBRACKETobservedOUNDERSCOREyCLOSEBRACKETOSEMICOLON
		
		return trueOSEMICOLON
	CLOSECURLY
	
	ODIVIDEODIVIDE camera OCOLON 9 dims array
	ODIVIDEODIVIDE OPENSQUARE0OMINUS2CLOSESQUARE OCOLON angleOMINUSaxis rotation
	ODIVIDEODIVIDE OPENSQUARE3OMINUS5CLOSESQUARE OCOLON translation
	ODIVIDEODIVIDE OPENSQUARE6OMINUS8CLOSESQUARE OCOLON camera parameterOCOMMA OPENSQUARE6CLOSESQUARE focal lengthOCOMMA OPENSQUARE7OMINUS8CLOSESQUARE second and forth order radial distortion
	ODIVIDEODIVIDE point OCOLON 3D locationODOT
	ODIVIDEODIVIDE predictions OCOLON 2D predictions with center of the image planeODOT
	templateOGREATtypename TOLESS
	static inline bool CamProjectionWithDistortionOPENBRACKETconst T OMULTIPLYcameraOCOMMA const T OMULTIPLYpointOCOMMA T OMULTIPLYpredictionsCLOSEBRACKET OPENCURLY
		ODIVIDEODIVIDE Rodrigues' formula
		T pOPENSQUARE3CLOSESQUAREOSEMICOLON
		AngleAxisRotatePointOPENBRACKETcameraOCOMMA pointOCOMMA pCLOSEBRACKETOSEMICOLON
		ODIVIDEODIVIDE cameraOPENSQUARE3OCOMMA4OCOMMA5CLOSESQUARE are the translation
		pOPENSQUARE0CLOSESQUARE OPLUSOASSIGN cameraOPENSQUARE3CLOSESQUAREOSEMICOLON
		pOPENSQUARE1CLOSESQUARE OPLUSOASSIGN cameraOPENSQUARE4CLOSESQUAREOSEMICOLON
		pOPENSQUARE2CLOSESQUARE OPLUSOASSIGN cameraOPENSQUARE5CLOSESQUAREOSEMICOLON
		
		ODIVIDEODIVIDE Compute the center fo distortion
		T xp OASSIGN OMINUSpOPENSQUARE0CLOSESQUARE ODIVIDE pOPENSQUARE2CLOSESQUAREOSEMICOLON
		T yp OASSIGN OMINUSpOPENSQUARE1CLOSESQUARE ODIVIDE pOPENSQUARE2CLOSESQUAREOSEMICOLON
		
		ODIVIDEODIVIDE Apply second and fourth order radial distortion
		const T OBANDl1 OASSIGN cameraOPENSQUARE7CLOSESQUAREOSEMICOLON
		const T OBANDl2 OASSIGN cameraOPENSQUARE8CLOSESQUAREOSEMICOLON
		
		T r2 OASSIGN xp OMULTIPLY xp OPLUS yp OMULTIPLY ypOSEMICOLON
		T distortion OASSIGN TOPENBRACKET1ODOT0CLOSEBRACKET OPLUS r2 OMULTIPLY OPENBRACKETl1 OPLUS l2 OMULTIPLY r2CLOSEBRACKETOSEMICOLON
		
		const T OBANDfocal OASSIGN cameraOPENSQUARE6CLOSESQUAREOSEMICOLON
		predictionsOPENSQUARE0CLOSESQUARE OASSIGN focal OMULTIPLY distortion OMULTIPLY xpOSEMICOLON
		predictionsOPENSQUARE1CLOSESQUARE OASSIGN focal OMULTIPLY distortion OMULTIPLY ypOSEMICOLON
		
		return trueOSEMICOLON
	CLOSECURLY
	
	static ceresOCOLONOCOLONCostFunction OMULTIPLYCreateOPENBRACKETconst double observedOUNDERSCORExOCOMMA const double observedOUNDERSCOREyCLOSEBRACKET OPENCURLY
		return OPENBRACKETnew ceresOCOLONOCOLONAutoDiffCostFunctionOGREATSnavelyReprojectionErrorOCOMMA 2OCOMMA 9OCOMMA 3OLESSOPENBRACKET
			new SnavelyReprojectionErrorOPENBRACKETobservedOUNDERSCORExOCOMMA observedOUNDERSCOREyCLOSEBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
privateOCOLON
	double observedOUNDERSCORExOSEMICOLON
	double observedOUNDERSCOREyOSEMICOLON
CLOSECURLYOSEMICOLON
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY
该类的括号运算符实现了Ceres计算误差的接口，实际的计算在CamProjectionWithDistortion函数中。注意在Ceres中，我们必须以double数组形式存储优化变量。现在每个相机一共有6维的姿态、1维焦距和2维畸变参数，共9维参数来描述，我们在实际存储中也必须按照这个顺序来存。该类的静态函数Create作为外部调用接口，直接返回一个可自动求导的Ceres代价函数。我们只要调用Create函数，把代价函数放入ceresOCOLONOCOLONProblem即可。

接下来我们实现BA搭建和求解的部分：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMA captionOASSIGNslambook2ODIVIDEch9ODIVIDESnavelyReprojectionErrorODOTcpp（片段）CLOSESQUARE
void SolveBAOPENBRACKETBALProblem OBANDbalOUNDERSCOREproblemCLOSEBRACKET OPENCURLY
	const int pointOUNDERSCOREblockOUNDERSCOREsize OASSIGN balOUNDERSCOREproblemODOTpointOUNDERSCOREblockOUNDERSCOREsizeOPENBRACKETCLOSEBRACKETOSEMICOLON
	const int cameraOUNDERSCOREblockOUNDERSCOREsize OASSIGN balOUNDERSCOREproblemODOTcameraOUNDERSCOREblockOUNDERSCOREsizeOPENBRACKETCLOSEBRACKETOSEMICOLON
	double OMULTIPLYpoints OASSIGN balOUNDERSCOREproblemODOTmutableOUNDERSCOREpointsOPENBRACKETCLOSEBRACKETOSEMICOLON
	double OMULTIPLYcameras OASSIGN balOUNDERSCOREproblemODOTmutableOUNDERSCOREcamerasOPENBRACKETCLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDE Observations is 2 OMULTIPLY numOUNDERSCOREobservations long array observations
	ODIVIDEODIVIDE OPENSQUAREuOUNDERSCORE1OCOMMA uOUNDERSCORE2OCOMMA ODOTODOTODOT uOUNDERSCOREnCLOSESQUAREOCOMMA where each uOUNDERSCOREi is two dimensionalOCOMMA the x
	ODIVIDEODIVIDE and y position of the observationODOT
	const double OMULTIPLYobservations OASSIGN balOUNDERSCOREproblemODOTobservationsOPENBRACKETCLOSEBRACKETOSEMICOLON
	ceresOCOLONOCOLONProblem problemOSEMICOLON
	
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT balOUNDERSCOREproblemODOTnumOUNDERSCOREobservationsOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		ceresOCOLONOCOLONCostFunction OMULTIPLYcostOUNDERSCOREfunctionOSEMICOLON
		
		ODIVIDEODIVIDE Each Residual block takes a point and a camera as input
		ODIVIDEODIVIDE and outputs a 2 dimensional Residual
		costOUNDERSCOREfunction OASSIGN 
			SnavelyReprojectionErrorOCOLONOCOLONCreateOPENBRACKETobservationsOPENSQUARE2 OMULTIPLY i OPLUS 0CLOSESQUAREOCOMMA observationsOPENSQUARE2 OMULTIPLY i OPLUS 1CLOSESQUARECLOSEBRACKETOSEMICOLON
		
		ODIVIDEODIVIDE If enabled use Huber's loss functionODOT
		ceresOCOLONOCOLONLossFunction OMULTIPLYlossOUNDERSCOREfunction OASSIGN new ceresOCOLONOCOLONHuberLossOPENBRACKET1ODOT0CLOSEBRACKETOSEMICOLON
		
		ODIVIDEODIVIDE Each observation corresponds to a pair of a camera and a point
		ODIVIDEODIVIDE which are identified by cameraOUNDERSCOREindexOPENBRACKETCLOSEBRACKETOPENSQUAREiCLOSESQUARE and pointOUNDERSCOREindexOPENBRACKETCLOSEBRACKETOPENSQUAREiCLOSESQUARE
		ODIVIDEODIVIDE respectivelyODOT
		double OMULTIPLYcamera OASSIGN cameras OPLUS cameraOUNDERSCOREblockOUNDERSCOREsize OMULTIPLY balOUNDERSCOREproblemODOTcameraOUNDERSCOREindexOPENBRACKETCLOSEBRACKETOPENSQUAREiCLOSESQUAREOSEMICOLON
		double OMULTIPLYpoint OASSIGN points OPLUS pointOUNDERSCOREblockOUNDERSCOREsize OMULTIPLY balOUNDERSCOREproblemODOTpointOUNDERSCOREindexOPENBRACKETCLOSEBRACKETOPENSQUAREiCLOSESQUAREOSEMICOLON
		
		problemODOTAddResidualBlockOPENBRACKETcostOUNDERSCOREfunctionOCOMMA lossOUNDERSCOREfunctionOCOMMA cameraOCOMMA pointCLOSEBRACKETOSEMICOLON
	CLOSECURLY

	stdOCOLONOCOLONcout OGREATOGREAT "Solving ceres BA ODOTODOTODOT " OGREATOGREAT endlOSEMICOLON
	ceresOCOLONOCOLONSolverOCOLONOCOLONOptions optionsOSEMICOLON
	optionsODOTlinearOUNDERSCOREsolverOUNDERSCOREtype OASSIGN ceresOCOLONOCOLONLinearSolverTypeOCOLONOCOLONSPARSEOUNDERSCORESCHUROSEMICOLON
	optionsODOTminimizerOUNDERSCOREprogressOUNDERSCOREtoOUNDERSCOREstdout OASSIGN trueOSEMICOLON
	ceresOCOLONOCOLONSolverOCOLONOCOLONSummary summaryOSEMICOLON
	ceresOCOLONOCOLONSolveOPENBRACKEToptionsOCOMMA OBANDproblemOCOMMA OBANDsummaryCLOSEBRACKETOSEMICOLON
	stdOCOLONOCOLONcout OGREATOGREAT summaryODOTFullReportOPENBRACKETCLOSEBRACKET OGREATOGREAT "OBACKSLASHn"OSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY
可见问题搭建部分是相当简单的。如果要添加别的代价函数，整个流程也不会有太大的变化。最后，在ceresOCOLONOCOLONSolverOCOLONOCOLONOptions中，我们可以设定求解的方法。使用SPARSEOBACKSLASHOUNDERSCORESCHUR会让Ceres实际求解的过程和我们前面描述的一致，即先对路标部分进行Schur边缘化，以加速的方式求解此问题。不过，在Ceres中我们不能控制哪部分变量被边缘化，这是由Ceres求解器自动寻找并计算的。

Ceres的BA求解输出如下：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshOCOMMAcaptionOASSIGN终端输出CLOSESQUARE
ODOTODIVIDEbuildODIVIDEbundleOUNDERSCOREadjustmentOUNDERSCOREceres  problemOMINUS16OMINUS22106OMINUSpreODOTtxt                
HeaderOCOLON 16 22106 83718bal problem file loadedODOTODOTODOT
bal problem have 16 cameras and 22106 pointsODOT 
Forming 83718 observationsODOT 
Solving ceres BA ODOTODOTODOT 
iter      cost      costOUNDERSCOREchange  OBBORgradientOBBOR   OBBORstepOBBOR    trOUNDERSCOREratio  trOUNDERSCOREradius  lsOUNDERSCOREiter  iterOUNDERSCOREtime  totalOUNDERSCOREtime
0  1ODOT842900eOPLUS07    0ODOT00eOPLUS00    2ODOT04eOPLUS06   0ODOT00eOPLUS00   0ODOT00eOPLUS00  1ODOT00eOPLUS04        0    6ODOT10eOMINUS02    2ODOT24eOMINUS01
1  1ODOT449093eOPLUS06    1ODOT70eOPLUS07    1ODOT75eOPLUS06   2ODOT16eOPLUS03   1ODOT84eOPLUS00  3ODOT00eOPLUS04        1    1ODOT79eOMINUS01    4ODOT03eOMINUS01
2  5ODOT848543eOPLUS04    1ODOT39eOPLUS06    1ODOT30eOPLUS06   1ODOT55eOPLUS03   1ODOT87eOPLUS00  9ODOT00eOPLUS04        1    1ODOT56eOMINUS01    5ODOT59eOMINUS01
3  1ODOT581483eOPLUS04    4ODOT27eOPLUS04    4ODOT98eOPLUS05   4ODOT98eOPLUS02   1ODOT29eOPLUS00  2ODOT70eOPLUS05        1    1ODOT51eOMINUS01    7ODOT10eOMINUS01
ODOTODOTODOTODOTODOTODOT
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY
总体误差应该随着迭代次数的增长而不断下降。最后，我们将优化前和优化后的点云输出为initialODOTply和finalODOTply，用meshlab可以直接打开这两个点云。结果图如OBACKSLASHautorefOPENCURLYfigOCOLONg2oOMINUSBACLOSECURLY所示。

OBACKSLASHsectionOPENCURLY实践：g2o求解BACLOSECURLY
下面来考虑如何使用g2o求解这个BA问题。和以前一样，g2o使用图模型来描述问题的结构，所以我们要用节点来表示相机和路标，然后用边来表示它们之间的观测。我们仍然使用自定义的点和边，只需覆盖一些关键函数即可。针对相机和路标，我们可以定义如下结构体，并使用override关键字来表示对基类虚函数的覆盖：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch9ODIVIDEbundleOUNDERSCOREadjustmentOUNDERSCOREg2oODOTcpp（片段）CLOSESQUARE
ODIVIDEODIVIDEODIVIDE 姿态和内参的结构
struct PoseAndIntrinsics OPENCURLY
	PoseAndIntrinsicsOPENBRACKETCLOSEBRACKET OPENCURLYCLOSECURLY
	
	ODIVIDEODIVIDEODIVIDE set from given data address
	explicit PoseAndIntrinsicsOPENBRACKETdouble OMULTIPLYdataOUNDERSCOREaddrCLOSEBRACKET OPENCURLY
		rotation OASSIGN SO3dOCOLONOCOLONexpOPENBRACKETVector3dOPENBRACKETdataOUNDERSCOREaddrOPENSQUARE0CLOSESQUAREOCOMMA dataOUNDERSCOREaddrOPENSQUARE1CLOSESQUAREOCOMMA dataOUNDERSCOREaddrOPENSQUARE2CLOSESQUARECLOSEBRACKETCLOSEBRACKETOSEMICOLON
		translation OASSIGN Vector3dOPENBRACKETdataOUNDERSCOREaddrOPENSQUARE3CLOSESQUAREOCOMMA dataOUNDERSCOREaddrOPENSQUARE4CLOSESQUAREOCOMMA dataOUNDERSCOREaddrOPENSQUARE5CLOSESQUARECLOSEBRACKETOSEMICOLON
		focal OASSIGN dataOUNDERSCOREaddrOPENSQUARE6CLOSESQUAREOSEMICOLON
		k1 OASSIGN dataOUNDERSCOREaddrOPENSQUARE7CLOSESQUAREOSEMICOLON
		k2 OASSIGN dataOUNDERSCOREaddrOPENSQUARE8CLOSESQUAREOSEMICOLON
	CLOSECURLY
	
	ODIVIDEODIVIDEODIVIDE 将估计值放入内存
	void setOUNDERSCOREtoOPENBRACKETdouble OMULTIPLYdataOUNDERSCOREaddrCLOSEBRACKET OPENCURLY
		auto r OASSIGN rotationODOTlogOPENBRACKETCLOSEBRACKETOSEMICOLON
		for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT 3OSEMICOLON OPLUSOPLUSiCLOSEBRACKET dataOUNDERSCOREaddrOPENSQUAREiCLOSESQUARE OASSIGN rOPENSQUAREiCLOSESQUAREOSEMICOLON
		for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT 3OSEMICOLON OPLUSOPLUSiCLOSEBRACKET dataOUNDERSCOREaddrOPENSQUAREi OPLUS 3CLOSESQUARE OASSIGN translationOPENSQUAREiCLOSESQUAREOSEMICOLON
		dataOUNDERSCOREaddrOPENSQUARE6CLOSESQUARE OASSIGN focalOSEMICOLON
		dataOUNDERSCOREaddrOPENSQUARE7CLOSESQUARE OASSIGN k1OSEMICOLON
		dataOUNDERSCOREaddrOPENSQUARE8CLOSESQUARE OASSIGN k2OSEMICOLON
	CLOSECURLY
	
	SO3d rotationOSEMICOLON
	Vector3d translation OASSIGN Vector3dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
	double focal OASSIGN 0OSEMICOLON
	double k1 OASSIGN 0OCOMMA k2 OASSIGN 0OSEMICOLON
CLOSECURLYOSEMICOLON

ODIVIDEODIVIDEODIVIDE 位姿加相机内参的顶点，9维，前三维为so3，接下去为tOCOMMA fOCOMMA k1OCOMMA k2
class VertexPoseAndIntrinsics OCOLON public g2oOCOLONOCOLONBaseVertexOGREAT9OCOMMA PoseAndIntrinsicsOLESS OPENCURLY
publicOCOLON
	EIGENOUNDERSCOREMAKEOUNDERSCOREALIGNEDOUNDERSCOREOPERATOROUNDERSCORENEWOSEMICOLON
	
	VertexPoseAndIntrinsicsOPENBRACKETCLOSEBRACKET OPENCURLYCLOSECURLY
	
	virtual void setToOriginImplOPENBRACKETCLOSEBRACKET override OPENCURLY
		OUNDERSCOREestimate OASSIGN PoseAndIntrinsicsOPENBRACKETCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	virtual void oplusImplOPENBRACKETconst double OMULTIPLYupdateCLOSEBRACKET override OPENCURLY
		OUNDERSCOREestimateODOTrotation OASSIGN SO3dOCOLONOCOLONexpOPENBRACKETVector3dOPENBRACKETupdateOPENSQUARE0CLOSESQUAREOCOMMA updateOPENSQUARE1CLOSESQUAREOCOMMA updateOPENSQUARE2CLOSESQUARECLOSEBRACKETCLOSEBRACKET OMULTIPLY OUNDERSCOREestimateODOTrotationOSEMICOLON
		OUNDERSCOREestimateODOTtranslation OPLUSOASSIGN Vector3dOPENBRACKETupdateOPENSQUARE3CLOSESQUAREOCOMMA updateOPENSQUARE4CLOSESQUAREOCOMMA updateOPENSQUARE5CLOSESQUARECLOSEBRACKETOSEMICOLON
		OUNDERSCOREestimateODOTfocal OPLUSOASSIGN updateOPENSQUARE6CLOSESQUAREOSEMICOLON
		OUNDERSCOREestimateODOTk1 OPLUSOASSIGN updateOPENSQUARE7CLOSESQUAREOSEMICOLON
		OUNDERSCOREestimateODOTk2 OPLUSOASSIGN updateOPENSQUARE8CLOSESQUAREOSEMICOLON
	CLOSECURLY
	
	ODIVIDEODIVIDEODIVIDE 根据估计值投影一个点
	Vector2d projectOPENBRACKETconst Vector3d OBANDpointCLOSEBRACKET OPENCURLY
		Vector3d pc OASSIGN OUNDERSCOREestimateODOTrotation OMULTIPLY point OPLUS OUNDERSCOREestimateODOTtranslationOSEMICOLON
		pc OASSIGN OMINUSpc ODIVIDE pcOPENSQUARE2CLOSESQUAREOSEMICOLON
		double r2 OASSIGN pcODOTsquaredNormOPENBRACKETCLOSEBRACKETOSEMICOLON
		double distortion OASSIGN 1ODOT0 OPLUS r2 OMULTIPLY OPENBRACKETOUNDERSCOREestimateODOTk1 OPLUS OUNDERSCOREestimateODOTk2 OMULTIPLY r2CLOSEBRACKETOSEMICOLON
		return Vector2dOPENBRACKETOUNDERSCOREestimateODOTfocal OMULTIPLY distortion OMULTIPLY pcOPENSQUARE0CLOSESQUAREOCOMMA
		OUNDERSCOREestimateODOTfocal OMULTIPLY distortion OMULTIPLY pcOPENSQUARE1CLOSESQUARECLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	virtual bool readOPENBRACKETistream OBANDinCLOSEBRACKET OPENCURLYCLOSECURLY
	
	virtual bool writeOPENBRACKETostream OBANDoutCLOSEBRACKET const OPENCURLYCLOSECURLY
CLOSECURLYOSEMICOLON

class VertexPoint OCOLON public g2oOCOLONOCOLONBaseVertexOGREAT3OCOMMA Vector3dOLESS OPENCURLY
publicOCOLON
	EIGENOUNDERSCOREMAKEOUNDERSCOREALIGNEDOUNDERSCOREOPERATOROUNDERSCORENEWOSEMICOLON
	
	VertexPointOPENBRACKETCLOSEBRACKET OPENCURLYCLOSECURLY
	
	virtual void setToOriginImplOPENBRACKETCLOSEBRACKET override OPENCURLY
		OUNDERSCOREestimate OASSIGN Vector3dOPENBRACKET0OCOMMA 0OCOMMA 0CLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	virtual void oplusImplOPENBRACKETconst double OMULTIPLYupdateCLOSEBRACKET override OPENCURLY
		OUNDERSCOREestimate OPLUSOASSIGN Vector3dOPENBRACKETupdateOPENSQUARE0CLOSESQUAREOCOMMA updateOPENSQUARE1CLOSESQUAREOCOMMA updateOPENSQUARE2CLOSESQUARECLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	virtual bool readOPENBRACKETistream OBANDinCLOSEBRACKET OPENCURLYCLOSECURLY
	
	virtual bool writeOPENBRACKETostream OBANDoutCLOSEBRACKET const OPENCURLYCLOSECURLY
CLOSECURLYOSEMICOLON

class EdgeProjection OCOLON
public g2oOCOLONOCOLONBaseBinaryEdgeOGREAT2OCOMMA Vector2dOCOMMA VertexPoseAndIntrinsicsOCOMMA VertexPointOLESS OPENCURLY
publicOCOLON
	EIGENOUNDERSCOREMAKEOUNDERSCOREALIGNEDOUNDERSCOREOPERATOROUNDERSCORENEWOSEMICOLON
	
	virtual void computeErrorOPENBRACKETCLOSEBRACKET override OPENCURLY
		auto v0 OASSIGN OPENBRACKETVertexPoseAndIntrinsics OMULTIPLYCLOSEBRACKET OUNDERSCOREverticesOPENSQUARE0CLOSESQUAREOSEMICOLON
		auto v1 OASSIGN OPENBRACKETVertexPoint OMULTIPLYCLOSEBRACKET OUNDERSCOREverticesOPENSQUARE1CLOSESQUAREOSEMICOLON
		auto proj OASSIGN v0OMINUSOLESSprojectOPENBRACKETv1OMINUSOLESSestimateOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
		OUNDERSCOREerror OASSIGN proj OMINUS OUNDERSCOREmeasurementOSEMICOLON
	CLOSECURLY
	
	ODIVIDEODIVIDE use numeric derivatives
	virtual bool readOPENBRACKETistream OBANDinCLOSEBRACKET OPENCURLYCLOSECURLY
	
	virtual bool writeOPENBRACKETostream OBANDoutCLOSEBRACKET const OPENCURLYCLOSECURLY
CLOSECURLYOSEMICOLON
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

我们把旋转、平移、焦距和畸变参数定义在同一个相机顶点中，然后定义相机到路标点之间的观测边。这里我们没有实现边的雅可比计算函数，这样g2o会自动提供一个数值计算的雅可比。最后，再按照BAL中的数据，将g2o的优化问题搭建起来即可：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch9ODIVIDEbundleOUNDERSCOREadjustmentOUNDERSCOREg2oODOTcpp（片段）CLOSESQUARE
void SolveBAOPENBRACKETBALProblem OBANDbalOUNDERSCOREproblemCLOSEBRACKET OPENCURLY
	const int pointOUNDERSCOREblockOUNDERSCOREsize OASSIGN balOUNDERSCOREproblemODOTpointOUNDERSCOREblockOUNDERSCOREsizeOPENBRACKETCLOSEBRACKETOSEMICOLON
	const int cameraOUNDERSCOREblockOUNDERSCOREsize OASSIGN balOUNDERSCOREproblemODOTcameraOUNDERSCOREblockOUNDERSCOREsizeOPENBRACKETCLOSEBRACKETOSEMICOLON
	double OMULTIPLYpoints OASSIGN balOUNDERSCOREproblemODOTmutableOUNDERSCOREpointsOPENBRACKETCLOSEBRACKETOSEMICOLON
	double OMULTIPLYcameras OASSIGN balOUNDERSCOREproblemODOTmutableOUNDERSCOREcamerasOPENBRACKETCLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDE pose dimension 9OCOMMA landmark is 3
	typedef g2oOCOLONOCOLONBlockSolverOGREATg2oOCOLONOCOLONBlockSolverTraitsOGREAT9OCOMMA 3OLESSOLESS BlockSolverTypeOSEMICOLON
	typedef g2oOCOLONOCOLONLinearSolverCSparseOGREATBlockSolverTypeOCOLONOCOLONPoseMatrixTypeOLESS LinearSolverTypeOSEMICOLON
	ODIVIDEODIVIDE use LM
	auto solver OASSIGN new g2oOCOLONOCOLONOptimizationAlgorithmLevenbergOPENBRACKET
	g2oOCOLONOCOLONmakeOUNDERSCOREuniqueOGREATBlockSolverTypeOLESSOPENBRACKETg2oOCOLONOCOLONmakeOUNDERSCOREuniqueOGREATLinearSolverTypeOLESSOPENBRACKETCLOSEBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
	g2oOCOLONOCOLONSparseOptimizer optimizerOSEMICOLON
	optimizerODOTsetAlgorithmOPENBRACKETsolverCLOSEBRACKETOSEMICOLON
	optimizerODOTsetVerboseOPENBRACKETtrueCLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDEODIVIDE build g2o problem
	const double OMULTIPLYobservations OASSIGN balOUNDERSCOREproblemODOTobservationsOPENBRACKETCLOSEBRACKETOSEMICOLON
	ODIVIDEODIVIDE vertex
	vectorOGREATVertexPoseAndIntrinsics OMULTIPLYOLESS vertexOUNDERSCOREposeOUNDERSCOREintrinsicsOSEMICOLON
	vectorOGREATVertexPoint OMULTIPLYOLESS vertexOUNDERSCOREpointsOSEMICOLON
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT balOUNDERSCOREproblemODOTnumOUNDERSCOREcamerasOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		VertexPoseAndIntrinsics OMULTIPLYv OASSIGN new VertexPoseAndIntrinsicsOPENBRACKETCLOSEBRACKETOSEMICOLON
		double OMULTIPLYcamera OASSIGN cameras OPLUS cameraOUNDERSCOREblockOUNDERSCOREsize OMULTIPLY iOSEMICOLON
		vOMINUSOLESSsetIdOPENBRACKETiCLOSEBRACKETOSEMICOLON
		vOMINUSOLESSsetEstimateOPENBRACKETPoseAndIntrinsicsOPENBRACKETcameraCLOSEBRACKETCLOSEBRACKETOSEMICOLON
		optimizerODOTaddVertexOPENBRACKETvCLOSEBRACKETOSEMICOLON
		vertexOUNDERSCOREposeOUNDERSCOREintrinsicsODOTpushOUNDERSCOREbackOPENBRACKETvCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT balOUNDERSCOREproblemODOTnumOUNDERSCOREpointsOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		VertexPoint OMULTIPLYv OASSIGN new VertexPointOPENBRACKETCLOSEBRACKETOSEMICOLON
		double OMULTIPLYpoint OASSIGN points OPLUS pointOUNDERSCOREblockOUNDERSCOREsize OMULTIPLY iOSEMICOLON
		vOMINUSOLESSsetIdOPENBRACKETi OPLUS balOUNDERSCOREproblemODOTnumOUNDERSCOREcamerasOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
		vOMINUSOLESSsetEstimateOPENBRACKETVector3dOPENBRACKETpointOPENSQUARE0CLOSESQUAREOCOMMA pointOPENSQUARE1CLOSESQUAREOCOMMA pointOPENSQUARE2CLOSESQUARECLOSEBRACKETCLOSEBRACKETOSEMICOLON
		ODIVIDEODIVIDE g2o在BA中需要手动设置待Marg的顶点
		vOMINUSOLESSsetMarginalizedOPENBRACKETtrueCLOSEBRACKETOSEMICOLON
		optimizerODOTaddVertexOPENBRACKETvCLOSEBRACKETOSEMICOLON
		vertexOUNDERSCOREpointsODOTpushOUNDERSCOREbackOPENBRACKETvCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	ODIVIDEODIVIDE edge
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT balOUNDERSCOREproblemODOTnumOUNDERSCOREobservationsOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		EdgeProjection OMULTIPLYedge OASSIGN new EdgeProjectionOSEMICOLON
		edgeOMINUSOLESSsetVertexOPENBRACKET0OCOMMA vertexOUNDERSCOREposeOUNDERSCOREintrinsicsOPENSQUAREbalOUNDERSCOREproblemODOTcameraOUNDERSCOREindexOPENBRACKETCLOSEBRACKETOPENSQUAREiCLOSESQUARECLOSESQUARECLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetVertexOPENBRACKET1OCOMMA vertexOUNDERSCOREpointsOPENSQUAREbalOUNDERSCOREproblemODOTpointOUNDERSCOREindexOPENBRACKETCLOSEBRACKETOPENSQUAREiCLOSESQUARECLOSESQUARECLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetMeasurementOPENBRACKETVector2dOPENBRACKETobservationsOPENSQUARE2 OMULTIPLY i OPLUS 0CLOSESQUAREOCOMMA observationsOPENSQUARE2 OMULTIPLY i OPLUS 1CLOSESQUARECLOSEBRACKETCLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetInformationOPENBRACKETMatrix2dOCOLONOCOLONIdentityOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetRobustKernelOPENBRACKETnew g2oOCOLONOCOLONRobustKernelHuberOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
		optimizerODOTaddEdgeOPENBRACKETedgeCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	optimizerODOTinitializeOptimizationOPENBRACKETCLOSEBRACKETOSEMICOLON
	optimizerODOToptimizeOPENBRACKET40CLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDE set to bal problem
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT balOUNDERSCOREproblemODOTnumOUNDERSCOREcamerasOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		double OMULTIPLYcamera OASSIGN cameras OPLUS cameraOUNDERSCOREblockOUNDERSCOREsize OMULTIPLY iOSEMICOLON
		auto vertex OASSIGN vertexOUNDERSCOREposeOUNDERSCOREintrinsicsOPENSQUAREiCLOSESQUAREOSEMICOLON
		auto estimate OASSIGN vertexOMINUSOLESSestimateOPENBRACKETCLOSEBRACKETOSEMICOLON
		estimateODOTsetOUNDERSCOREtoOPENBRACKETcameraCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT balOUNDERSCOREproblemODOTnumOUNDERSCOREpointsOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		double OMULTIPLYpoint OASSIGN points OPLUS pointOUNDERSCOREblockOUNDERSCOREsize OMULTIPLY iOSEMICOLON
		auto vertex OASSIGN vertexOUNDERSCOREpointsOPENSQUAREiCLOSESQUAREOSEMICOLON
		for OPENBRACKETint k OASSIGN 0OSEMICOLON k OGREAT 3OSEMICOLON OPLUSOPLUSkCLOSEBRACKET pointOPENSQUAREkCLOSESQUARE OASSIGN vertexOMINUSOLESSestimateOPENBRACKETCLOSEBRACKETOPENSQUAREkCLOSESQUAREOSEMICOLON
	CLOSECURLY
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

以上定义了本问题中使用的节点和边。下面需要根据BALProblem类当中的实际数据来生成一些节点和边，交给g2o进行优化。值得注意的是，为了充分利用BA中的稀疏性，需要在这里将路标中的setMarginalized属性设置为true。代码的主要片段如下：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch9ODIVIDEbundleOUNDERSCOREadjustmentOUNDERSCOREg2o（片段）CLOSESQUARE
void SolveBAOPENBRACKETBALProblem OBANDbalOUNDERSCOREproblemCLOSEBRACKET OPENCURLY
	const int pointOUNDERSCOREblockOUNDERSCOREsize OASSIGN balOUNDERSCOREproblemODOTpointOUNDERSCOREblockOUNDERSCOREsizeOPENBRACKETCLOSEBRACKETOSEMICOLON
	const int cameraOUNDERSCOREblockOUNDERSCOREsize OASSIGN balOUNDERSCOREproblemODOTcameraOUNDERSCOREblockOUNDERSCOREsizeOPENBRACKETCLOSEBRACKETOSEMICOLON
	double OMULTIPLYpoints OASSIGN balOUNDERSCOREproblemODOTmutableOUNDERSCOREpointsOPENBRACKETCLOSEBRACKETOSEMICOLON
	double OMULTIPLYcameras OASSIGN balOUNDERSCOREproblemODOTmutableOUNDERSCOREcamerasOPENBRACKETCLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDE pose dimension 9OCOMMA landmark is 3
	typedef g2oOCOLONOCOLONBlockSolverOGREATg2oOCOLONOCOLONBlockSolverTraitsOGREAT9OCOMMA 3OLESSOLESS BlockSolverTypeOSEMICOLON
	typedef g2oOCOLONOCOLONLinearSolverCSparseOGREATBlockSolverTypeOCOLONOCOLONPoseMatrixTypeOLESS LinearSolverTypeOSEMICOLON
	ODIVIDEODIVIDE use LM
	auto solver OASSIGN new g2oOCOLONOCOLONOptimizationAlgorithmLevenbergOPENBRACKET
	g2oOCOLONOCOLONmakeOUNDERSCOREuniqueOGREATBlockSolverTypeOLESSOPENBRACKETg2oOCOLONOCOLONmakeOUNDERSCOREuniqueOGREATLinearSolverTypeOLESSOPENBRACKETCLOSEBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
	g2oOCOLONOCOLONSparseOptimizer optimizerOSEMICOLON
	optimizerODOTsetAlgorithmOPENBRACKETsolverCLOSEBRACKETOSEMICOLON
	optimizerODOTsetVerboseOPENBRACKETtrueCLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDEODIVIDE build g2o problem
	const double OMULTIPLYobservations OASSIGN balOUNDERSCOREproblemODOTobservationsOPENBRACKETCLOSEBRACKETOSEMICOLON
	ODIVIDEODIVIDE vertex
	vectorOGREATVertexPoseAndIntrinsics OMULTIPLYOLESS vertexOUNDERSCOREposeOUNDERSCOREintrinsicsOSEMICOLON
	vectorOGREATVertexPoint OMULTIPLYOLESS vertexOUNDERSCOREpointsOSEMICOLON
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT balOUNDERSCOREproblemODOTnumOUNDERSCOREcamerasOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		VertexPoseAndIntrinsics OMULTIPLYv OASSIGN new VertexPoseAndIntrinsicsOPENBRACKETCLOSEBRACKETOSEMICOLON
		double OMULTIPLYcamera OASSIGN cameras OPLUS cameraOUNDERSCOREblockOUNDERSCOREsize OMULTIPLY iOSEMICOLON
		vOMINUSOLESSsetIdOPENBRACKETiCLOSEBRACKETOSEMICOLON
		vOMINUSOLESSsetEstimateOPENBRACKETPoseAndIntrinsicsOPENBRACKETcameraCLOSEBRACKETCLOSEBRACKETOSEMICOLON
		optimizerODOTaddVertexOPENBRACKETvCLOSEBRACKETOSEMICOLON
		vertexOUNDERSCOREposeOUNDERSCOREintrinsicsODOTpushOUNDERSCOREbackOPENBRACKETvCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT balOUNDERSCOREproblemODOTnumOUNDERSCOREpointsOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		VertexPoint OMULTIPLYv OASSIGN new VertexPointOPENBRACKETCLOSEBRACKETOSEMICOLON
		double OMULTIPLYpoint OASSIGN points OPLUS pointOUNDERSCOREblockOUNDERSCOREsize OMULTIPLY iOSEMICOLON
		vOMINUSOLESSsetIdOPENBRACKETi OPLUS balOUNDERSCOREproblemODOTnumOUNDERSCOREcamerasOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
		vOMINUSOLESSsetEstimateOPENBRACKETVector3dOPENBRACKETpointOPENSQUARE0CLOSESQUAREOCOMMA pointOPENSQUARE1CLOSESQUAREOCOMMA pointOPENSQUARE2CLOSESQUARECLOSEBRACKETCLOSEBRACKETOSEMICOLON
		ODIVIDEODIVIDE g2o在BA中需要手动设置待Marg的顶点
		vOMINUSOLESSsetMarginalizedOPENBRACKETtrueCLOSEBRACKETOSEMICOLON
		optimizerODOTaddVertexOPENBRACKETvCLOSEBRACKETOSEMICOLON
		vertexOUNDERSCOREpointsODOTpushOUNDERSCOREbackOPENBRACKETvCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	ODIVIDEODIVIDE edge
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT balOUNDERSCOREproblemODOTnumOUNDERSCOREobservationsOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		EdgeProjection OMULTIPLYedge OASSIGN new EdgeProjectionOSEMICOLON
		edgeOMINUSOLESSsetVertexOPENBRACKET0OCOMMA vertexOUNDERSCOREposeOUNDERSCOREintrinsicsOPENSQUAREbalOUNDERSCOREproblemODOTcameraOUNDERSCOREindexOPENBRACKETCLOSEBRACKETOPENSQUAREiCLOSESQUARECLOSESQUARECLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetVertexOPENBRACKET1OCOMMA vertexOUNDERSCOREpointsOPENSQUAREbalOUNDERSCOREproblemODOTpointOUNDERSCOREindexOPENBRACKETCLOSEBRACKETOPENSQUAREiCLOSESQUARECLOSESQUARECLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetMeasurementOPENBRACKETVector2dOPENBRACKETobservationsOPENSQUARE2 OMULTIPLY i OPLUS 0CLOSESQUAREOCOMMA observationsOPENSQUARE2 OMULTIPLY i OPLUS 1CLOSESQUARECLOSEBRACKETCLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetInformationOPENBRACKETMatrix2dOCOLONOCOLONIdentityOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetRobustKernelOPENBRACKETnew g2oOCOLONOCOLONRobustKernelHuberOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
		optimizerODOTaddEdgeOPENBRACKETedgeCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	optimizerODOTinitializeOptimizationOPENBRACKETCLOSEBRACKETOSEMICOLON
	optimizerODOToptimizeOPENBRACKET40CLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDE set to bal problem
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT balOUNDERSCOREproblemODOTnumOUNDERSCOREcamerasOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		double OMULTIPLYcamera OASSIGN cameras OPLUS cameraOUNDERSCOREblockOUNDERSCOREsize OMULTIPLY iOSEMICOLON
		auto vertex OASSIGN vertexOUNDERSCOREposeOUNDERSCOREintrinsicsOPENSQUAREiCLOSESQUAREOSEMICOLON
		auto estimate OASSIGN vertexOMINUSOLESSestimateOPENBRACKETCLOSEBRACKETOSEMICOLON
		estimateODOTsetOUNDERSCOREtoOPENBRACKETcameraCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT balOUNDERSCOREproblemODOTnumOUNDERSCOREpointsOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		double OMULTIPLYpoint OASSIGN points OPLUS pointOUNDERSCOREblockOUNDERSCOREsize OMULTIPLY iOSEMICOLON
		auto vertex OASSIGN vertexOUNDERSCOREpointsOPENSQUAREiCLOSESQUAREOSEMICOLON
		for OPENBRACKETint k OASSIGN 0OSEMICOLON k OGREAT 3OSEMICOLON OPLUSOPLUSkCLOSEBRACKET pointOPENSQUAREkCLOSESQUARE OASSIGN vertexOMINUSOLESSestimateOPENBRACKETCLOSEBRACKETOPENSQUAREkCLOSESQUAREOSEMICOLON
	CLOSECURLY
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY
g2o和Ceres一大不同点在于，在使用稀疏优化时，g2o必须手动设置哪些顶点为边缘化顶点，否则就会报运行时错误（读者可以尝试注释掉vOMINUSOLESSsetMarginalizedOPENBRACKETtrueCLOSEBRACKET这一行）。其余地方和Ceres实验大同小异，我们就不多加介绍了。g2o实验也会输出优化前后点云，供对比查看。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1ODOT0OBACKSLASHtextwidthCLOSESQUAREOPENCURLYbackend1ODIVIDEg2oOMINUSbaCLOSECURLY
	OBACKSLASHcaptionOPENCURLY优化前后的可视化点云。左侧为优化前初始值，右侧为优化后的。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONg2oOMINUSBACLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

OBACKSLASHsectionOPENCURLY小结CLOSECURLY
本讲比较深入地探讨了状态估计问题与图优化的求解。我们看到在经典模型中SLAM可以看成状态估计问题。如果我们假设马尔可夫性，只考虑当前状态，则得到以EKF为代表的滤波器模型。如若不然，我们也可以选择考虑所有的运动和观测，它们构成一个最小二乘问题。在只有观测方程的情况下，这个问题称为BA，并可利用非线性优化方法求解。我们仔细讨论了求解过程中的稀疏性问题，指出了该问题与图优化之间的联系。最后，我们演示了如何使用g2o和Ceres库求解同一个优化问题，让读者对BA有一个直观的认识。

OBACKSLASHsectionOMULTIPLYOPENCURLY习题CLOSECURLY
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 证明式OBACKSLASHeqrefOPENCURLYeqOCOLONkalmanOMINUSKOMINUSanotherCLOSECURLY成立。提示：你可能会用到SMW（ShermanOMINUSMorrisonOMINUSWoodbury）公式，参考文献OBACKSLASHciteOPENCURLYSherman1950OCOMMA Barfoot2016CLOSECURLY。
	OBACKSLASHitem 
	对比g2o和Ceres的优化后目标函数的数值。指出为什么两者在Meshlab中效果一样但数值却不同。
	OBACKSLASHitem 
	对Ceres当中的部分点云进行Schur消元，看看结果会有什么区别。
	OBACKSLASHitem 证明ODOLLAROBACKSLASHbmOPENCURLYSCLOSECURLYODOLLAR矩阵为半正定矩阵。
	OBACKSLASHitem 阅读文献OBACKSLASHciteOPENCURLYKummerle2011CLOSECURLY，看看g2o对核函数是如何处理的。与Ceres中的Loss function有何联系？
	OBACKSLASHitemOPENSQUAREOBACKSLASHoptionalCLOSESQUARE 在两个示例中，我们优化了相机位姿、以ODOLLARfOCOMMA kOUNDERSCORE1OCOMMA kOUNDERSCORE2ODOLLAR为参数的相机内参及路标点。请考虑使用第5讲介绍的完整的相机模型进行优化，即，至少考虑ODOLLARfOUNDERSCORExOCOMMA fOUNDERSCOREyOCOMMA pOUNDERSCORE1OCOMMA pOUNDERSCORE2OCOMMAODOLLAR ODOLLARkOUNDERSCORE1OCOMMA kOUNDERSCORE2ODOLLAR这些量。修改现在的Ceres和g2o程序以完成实验。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY
