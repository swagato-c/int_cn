OMODULO ONOTModeOCOLONOCOLON "TeXOCOLONUTFOMINUS8"
OBACKSLASHchapterOPENCURLY视觉里程计2CLOSECURLY
OBACKSLASHlabelOPENCURLYcptOCOLONvo2CLOSECURLY
OBACKSLASHbeginOPENCURLYmdframedCLOSECURLY  
	OBACKSLASHtextbfOPENCURLY主要目标CLOSECURLY
	OBACKSLASHbeginOPENCURLYenumerateCLOSECURLYOPENSQUARElabelindentOASSIGN0emOCOMMAleftmarginOASSIGN1ODOT5emCLOSESQUARE
		OBACKSLASHitem 理解光流法跟踪特征点的原理。
		OBACKSLASHitem 理解直接法是如何估计相机位姿的。
		OBACKSLASHitem 使用g2o进行直接法的计算。
	OBACKSLASHendOPENCURLYenumerateCLOSECURLY
OBACKSLASHendOPENCURLYmdframedCLOSECURLY

直接法是视觉里程计另一主要分支，它与特征点法有很大不同。虽然它还没有成为现在VO中的主流，但经过近几年的发展，直接法在一定程度上已经能和特征点法平分秋色。本讲我们将介绍直接法的原理，并实现直接法中的核心部分。

OBACKSLASHnewpage
OBACKSLASHincludepdfOPENCURLYresourcesODIVIDEotherODIVIDEch8ODOTpdfCLOSECURLY

OBACKSLASHnewpage
OBACKSLASHsectionOPENCURLY直接法的引出CLOSECURLY
上一讲我们介绍了使用特征点估计相机运动的方法。尽管特征点法在视觉里程计中占据主流地位，但研究者们还是认识到它至少有以下几个缺点：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 关键点的提取与描述子的计算非常耗时。实践当中，SIFT目前在CPU上是无法实时计算的，而ORB也需要近20ms的计算。如果整个SLAM以30毫秒ODIVIDE帧的速度运行，那么一大半时间都将花在计算特征点上。
	
	OBACKSLASHitem 使用特征点时，忽略了除特征点以外的所有信息。一幅图像有几十万个像素，而特征点只有几百个。只使用特征点丢弃了大部分OBACKSLASHtextbfOPENCURLY可能有用的CLOSECURLY图像信息。
	
	OBACKSLASHitem 相机有时会运动到OBACKSLASHtextbfOPENCURLY特征缺失CLOSECURLY的地方，这些地方往往没有明显的纹理信息。例如，有时我们会面对一堵白墙，或者一个空荡荡的走廊。这些场景下特征点数量会明显减少，我们可能找不到足够的匹配点来计算相机运动。 
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

我们看到使用特征点确实存在一些问题。有没有什么办法能够克服这些缺点呢？我们有以下几种思路：

OBACKSLASHbeginOPENCURLYitemizeCLOSECURLY
	OBACKSLASHitem 保留特征点，但只计算关键点，不计算描述子。同时，使用OBACKSLASHtextbfOPENCURLY光流法CLOSECURLY（Optical Flow）来跟踪特征点的运动。这样可以回避计算和匹配描述子带来的时间，而光流本身的计算时间要小于描述子的计算与匹配。
	OBACKSLASHitem 只计算关键点，不计算描述子。同时，使用OBACKSLASHtextbfOPENCURLY直接法CLOSECURLY（Direct Method）来计算特征点在下一时刻图像中的位置。这同样可以跳过描述子的计算过程，也省去了光流的计算时间。
OBACKSLASHendOPENCURLYitemizeCLOSECURLY

第一种方法仍然使用特征点，只是把匹配描述子替换成了光流跟踪，估计相机运动时仍使用对极几何、PnP或ICP算法。这依然会要求提取到的关键点具有可区别性，即我们需要提到角点。而在直接法中，我们会根据图像的OBACKSLASHtextbfOPENCURLY像素灰度信息CLOSECURLY同时估计相机运动和点的投影，不要求提取到的点必须为角点。后文将看到，它们甚至可以是随机的选点。

使用特征点法估计相机运动时，我们把特征点看作固定在三维空间的不动点。根据它们在相机中的投影位置，通过OBACKSLASHtextbfOPENCURLY最小化重投影误差CLOSECURLY（Reprojection error）来优化相机运动。在这个过程中，我们需要精确地知道空间点在两个相机中投影后的像素位置——这也就是我们要对特征进行匹配或跟踪的原因。同时，我们也知道，计算、匹配特征需要付出大量的计算量。相对地，在直接法中，我们并不需要知道点与点之间的对应关系，而是通过最小化OBACKSLASHtextbfOPENCURLY光度误差CLOSECURLY（Photometric error）来求得它们。

直接法是本讲介绍的重点。它是为了克服特征点法的上述缺点而存在的。直接法根据像素的亮度信息估计相机的运动，可以完全不用计算关键点和描述子，于是，既避免了特征的计算时间，也避免了特征缺失的情况。只要场景中存在明暗变化（可以是渐变，不形成局部的图像梯度），直接法就能工作。根据使用像素的数量，直接法分为稀疏、稠密和半稠密三种。相比于特征点法只能重构稀疏特征点（稀疏地图），直接法还具有恢复稠密或半稠密结构的能力。

历史上，早期也有对直接法的使用OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYSilveira2008CLOSECURLYCLOSECURLY。随着一些使用直接法的开源项目的出现（如SVOOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYForster2014CLOSECURLYCLOSECURLY、LSDOMINUSSLAMOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYEngel2014CLOSECURLYCLOSECURLY、DSOOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYEngel2016CLOSECURLYCLOSECURLY等），它们逐渐地走上主流舞台，成为视觉里程计算法中重要的一部分。

OBACKSLASHsectionOPENCURLY2D光流（Optical Flow）CLOSECURLY
直接法是从光流演变而来的。它们非常相似，具有相同的假设条件。光流描述了像素在图像中的运动，而直接法则附带着一个相机运动模型。为了说明直接法，我们不妨先来介绍一下光流。

光流是一种描述像素随时间在图像之间运动的方法，如OBACKSLASHautorefOPENCURLYfigOCOLONLKCLOSECURLYOTILDE所示。随着时间的流逝，同一个像素会在图像中运动，而我们希望追踪它的运动过程。其中，计算部分像素运动的称为OBACKSLASHtextbfOPENCURLY稀疏光流CLOSECURLY，计算所有像素的称为OBACKSLASHtextbfOPENCURLY稠密光流CLOSECURLY。稀疏光流以LucasOMINUSKanade光流OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYLucas1981CLOSECURLYCLOSECURLY为代表，并可以在SLAM中用于跟踪特征点位置。稠密光流以HornOMINUSSchunck光流OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYHorn1981CLOSECURLYCLOSECURLY为代表。因此，本节主要介绍LucasOMINUSKanade光流，亦称LK光流。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1ODOT0OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo2ODIVIDEopticalFlowCLOSECURLY
	OBACKSLASHcaptionOPENCURLYLK光流法示意图。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONLKCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

OBACKSLASHsubsectionOMULTIPLYOPENCURLYLucasOMINUSKanade光流CLOSECURLY
在LK光流中，我们认为来自相机的图像是随时间变化的。图像可以看作时间的函数：ODOLLAROBACKSLASHbmOPENCURLYICLOSECURLYOPENBRACKETtCLOSEBRACKETODOLLAR。那么，一个在ODOLLARtODOLLAR时刻，位于ODOLLAROPENBRACKETxOCOMMAyCLOSEBRACKETODOLLAR处的像素，它的灰度可以写成
OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYICLOSECURLYOPENBRACKETxOCOMMAyOCOMMAtCLOSEBRACKETODOT
OBACKSLASHCLOSESQUARE
这种方式把图像看成了关于位置与时间的函数，它的值域就是图像中像素的灰度。现在考虑某个固定的空间点，它在ODOLLARtODOLLAR时刻的像素坐标为ODOLLARxOCOMMAyODOLLAR。由于相机的运动，它的图像坐标将发生变化。我们希望估计这个空间点在其他时刻图像中位置。怎么估计呢？这里要引入光流法的基本假设。

OBACKSLASHtextbfOPENCURLY灰度不变假设CLOSECURLY：同一个空间点的像素灰度值，在各个图像中是固定不变的。

对于ODOLLARtODOLLAR时刻位于ODOLLAROPENBRACKETxOCOMMAyCLOSEBRACKETODOLLAR处的像素，我们设ODOLLARtOPLUSOBACKSLASHmathrmOPENCURLYdCLOSECURLYtODOLLAR时刻它运动到ODOLLAROPENBRACKETxOPLUSOBACKSLASHmathrmOPENCURLYdCLOSECURLYxOCOMMA yOPLUSOBACKSLASHmathrmOPENCURLYdCLOSECURLYyCLOSEBRACKETODOLLAR处。由于灰度不变，我们有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY 
OBACKSLASHbmOPENCURLYICLOSECURLYOPENBRACKETxOPLUSOBACKSLASHmathrmOPENCURLYdCLOSECURLYxOCOMMA yOPLUSOBACKSLASHmathrmOPENCURLYdCLOSECURLYyOCOMMA tOPLUSOBACKSLASHmathrmOPENCURLYdCLOSECURLYtCLOSEBRACKET OASSIGN OBACKSLASHbmOPENCURLYICLOSECURLY OPENBRACKETxOCOMMAyOCOMMAtCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

注意灰度不变假设是一个很强的假设，实际当中很可能不成立。事实上，由于物体的材质不同，像素会出现高光和阴影部分；有时，相机会自动调整曝光参数，使得图像整体变亮或变暗。这些时候灰度不变假设都是不成立的，因此光流的结果也不一定可靠。然而，从另一方面来说，所有算法都是在一定假设下工作的。如果我们什么假设都不做，就没法设计实用的算法。所以，让我们暂且认为该假设成立，看看如何计算像素的运动。

对左边进行泰勒展开，保留一阶项，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYICLOSECURLY OBACKSLASHleftOPENBRACKET OPENCURLYx OPLUS OBACKSLASHmathrmOPENCURLYdCLOSECURLYxOCOMMAy OPLUS OBACKSLASHmathrmOPENCURLYdCLOSECURLYyOCOMMAt OPLUS OBACKSLASHmathrmOPENCURLYdCLOSECURLYtCLOSECURLY OBACKSLASHrightCLOSEBRACKET OBACKSLASHapprox OBACKSLASHbmOPENCURLYICLOSECURLY OBACKSLASHleftOPENBRACKET OPENCURLYxOCOMMAyOCOMMAtCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYICLOSECURLY CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial xCLOSECURLYCLOSECURLYOBACKSLASHmathrmOPENCURLYdCLOSECURLYx OPLUS OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYICLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial yCLOSECURLYCLOSECURLYOBACKSLASHmathrmOPENCURLYdCLOSECURLYy OPLUS OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYICLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial tCLOSECURLYCLOSECURLYOBACKSLASHmathrmOPENCURLYdCLOSECURLYtODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

因为我们假设了灰度不变，于是下一个时刻的灰度等于之前的灰度，从而：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
 OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYICLOSECURLY CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial xCLOSECURLYCLOSECURLYOBACKSLASHmathrmOPENCURLYdCLOSECURLYx OPLUS OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYICLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial yCLOSECURLYCLOSECURLYOBACKSLASHmathrmOPENCURLYdCLOSECURLYy OPLUS OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYICLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial tCLOSECURLYCLOSECURLYOBACKSLASHmathrmOPENCURLYdCLOSECURLYt OASSIGN 0ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

两边除以ODOLLAROBACKSLASHmathrmOPENCURLYdCLOSECURLYtODOLLAR，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLYOBACKSLASHlabelOPENCURLYkeyCLOSECURLY
 OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYICLOSECURLY CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial xCLOSECURLYCLOSECURLY OBACKSLASHfracOPENCURLYOBACKSLASHmathrmOPENCURLYdCLOSECURLYxCLOSECURLYOPENCURLYOBACKSLASHmathrmOPENCURLYdCLOSECURLYtCLOSECURLY OPLUS OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYICLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial yCLOSECURLYCLOSECURLY OBACKSLASHfracOPENCURLYOBACKSLASHmathrmOPENCURLYdCLOSECURLYyCLOSECURLYOPENCURLYOBACKSLASHmathrmOPENCURLYdCLOSECURLYtCLOSECURLY OASSIGNOMINUS OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYICLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial tCLOSECURLYCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

其中ODOLLAROBACKSLASHmathrmOPENCURLYdCLOSECURLYx ODIVIDE OBACKSLASHmathrmOPENCURLYdCLOSECURLYtODOLLAR为像素在ODOLLARxODOLLAR轴上的运动速度，而ODOLLAROBACKSLASHmathrmOPENCURLYdCLOSECURLYyODIVIDEOBACKSLASHmathrmOPENCURLYdCLOSECURLYtODOLLAR为ODOLLARyODOLLAR轴上的速度，把它们记为ODOLLARuOCOMMAvODOLLAR。同时ODOLLAROBACKSLASHpartial OBACKSLASHbmOPENCURLYICLOSECURLYODIVIDEOPENCURLYOBACKSLASHpartial xCLOSECURLYODOLLAR为图像在该点处ODOLLARxODOLLAR方向的梯度，另一项则是在ODOLLARyODOLLAR方向的梯度，记为ODOLLAROBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORExOCOMMA OBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCOREyODOLLAR。把图像灰度对时间的变化量记为ODOLLAROBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCOREtODOLLAR，写成矩阵形式，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOPENCURLY OBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORExCLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLY OBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCOREyCLOSECURLYCLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREOBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
uOBACKSLASHOBACKSLASH
v
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN  OMINUS OPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCOREtCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

我们想计算的是像素的运动ODOLLARuOCOMMAvODOLLAR，但是该式是带有两个变量的一次方程，仅凭它无法计算出ODOLLARuOCOMMAvODOLLAR。因此，必须引入额外的约束来计算ODOLLARuOCOMMAvODOLLAR。在LK光流中，我们假设OBACKSLASHtextbfOPENCURLY某一个窗口内的像素具有相同的运动CLOSECURLY。

考虑一个大小为ODOLLARw OBACKSLASHtimes wODOLLAR的窗口，它含有ODOLLARwOHAT2ODOLLAR数量的像素。由于该窗口内像素具有同样的运动，因此我们共有ODOLLARwOHAT2ODOLLAR个方程：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOPENCURLY OBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORExCLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLY OBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCOREyCLOSECURLYCLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREOUNDERSCOREk
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
uOBACKSLASHOBACKSLASH
v
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN  OMINUS OPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCOREtCLOSECURLYOUNDERSCOREkOCOMMA OBACKSLASHquad kOASSIGN1OCOMMA OBACKSLASHldotsOCOMMA wOHAT2ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

记：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYACLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOPENCURLYOPENCURLYOBACKSLASHleftOPENSQUARE OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORExCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCOREyCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUARECLOSECURLYOUNDERSCORE1CLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	OBACKSLASHvdots OBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLYOPENCURLYOBACKSLASHleftOPENSQUARE OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORExCLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCOREyCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUARECLOSECURLYOUNDERSCOREkCLOSECURLYCLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREOCOMMAOBACKSLASHbmOPENCURLYbCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOPENCURLY OBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCOREOPENCURLYt1CLOSECURLYCLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	OBACKSLASHvdots OBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLY OBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCOREOPENCURLYtkCLOSECURLYCLOSECURLYCLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

于是整个方程为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYACLOSECURLYOBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
uOBACKSLASHOBACKSLASH
v
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN  OMINUS OBACKSLASHbmOPENCURLYbCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这是一个关于ODOLLARuOCOMMAvODOLLAR的超定线性方程，传统解法是求最小二乘解。最小二乘在很多时候都用到过：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OPENCURLYOBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
	uOBACKSLASHOBACKSLASH
	v
	OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUAREOHATOMULTIPLYCLOSECURLY OASSIGN OMINUSOPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLY OBACKSLASHbmOPENCURLYACLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOBACKSLASHbmOPENCURLYACLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYOPENCURLY OBACKSLASHbmOPENCURLYACLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOBACKSLASHbmOPENCURLYbCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这样就得到了像素在图像间的运动速度ODOLLARuOCOMMAvODOLLAR。当ODOLLARtODOLLAR取离散的时刻而不是连续时间时，我们可以估计某块像素在若干个图像中出现的位置。由于像素梯度仅在局部有效，所以如果一次迭代不够好，我们会多迭代几次这个方程。在SLAM中，LK光流常被用来跟踪角点的运动，我们不妨通过程序体会一下。

OBACKSLASHsectionOPENCURLY实践：LK光流CLOSECURLY
OBACKSLASHlabelOPENCURLYsecOCOLONLKFlowCLOSECURLY
OMODULOOBACKSLASHsubsectionOPENCURLY使用TUM公开数据集CLOSECURLY
OMODULO下面演示如何用OpenCV提供的光流法来跟踪特征点。与上一节一样，我们准备了若干幅数据集图像，存放在程序目录中的dataODIVIDE文件夹下。它们来自于慕尼黑工业大学（TUM）提供的公开RGBOMINUSD数据集OBACKSLASHfootnoteOPENCURLY见OBACKSLASHurlOPENCURLYhttpOCOLONODIVIDEODIVIDEvisionODOTinODOTtumODOTdeODIVIDEdataODIVIDEdatasetsODIVIDErgbdOMINUSdatasetODIVIDEdownloadCLOSECURLY。CLOSECURLY。以后我们就称之为TUM数据集。它含有许多个RGBOMINUSD视频，可以作为RGBOMINUSD或单目SLAM的实验数据。它还提供了用运动捕捉系统测量的精确轨迹，可以作为标准轨迹以校准SLAM系统。由于该数据集比较大，我们没有放到GitHub上（否则下载代码需要很长时间），请读者自行去数据集主页查找对应的数据。本程序中使用了一部分“freburg1OBACKSLASHOUNDERSCOREdesk”数据集中的图像。读者可以在TUM数据集主页找到它的下载链接。或者，也可以直接使用本书在GitHub上提供的部分。
OMODULO
OMODULO我们的数据位于本章目录的dataODIVIDE下，以压缩包形式提供（dataODOTtarODOTgz）。由于TUM数据集是从实际环境中采集的，需要解释一下它的数据格式（数据集一般都有自己定义的格式）。在解压后，你将看到以下这些文件：
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
OMODULO	OBACKSLASHitem rgbODOTtxt和depthODOTtxt记录了各文件的采集时间和对应的文件名。
OMODULO	OBACKSLASHitem rgbODIVIDE 和 depthODIVIDE目录存放着采集到的PNG格式图像文件。彩色图像为8位3通道，深度图为16位单通道图像。文件名即采集时间。
OMODULO	
OMODULO	OBACKSLASHitem groundtruthODOTtxt为外部运动捕捉系统采集到的相机位姿，格式为
OMODULO	OBACKSLASHOPENSQUARE
OMODULO	OPENBRACKETOBACKSLASHmathrmOPENCURLYtimeCLOSECURLYOCOMMA tOUNDERSCORExOCOMMA tOUNDERSCOREyOCOMMA tOUNDERSCOREzOCOMMA qOUNDERSCORExOCOMMA qOUNDERSCOREyOCOMMA qOUNDERSCOREzOCOMMA qOUNDERSCOREwCLOSEBRACKETOCOMMA
OMODULO	OBACKSLASHCLOSESQUARE
OMODULO	我们可以把它看成标准轨迹。
OMODULOOBACKSLASHendOPENCURLYenumerateCLOSECURLY
OMODULO
OMODULO请注意，彩色图、深度图和标准轨迹的采集都是独立的，轨迹的采集频率比图像高很多。在使用数据之前，需要根据采集时间对数据进行一次时间上的对齐，以便对彩色图和深度图进行配对。原则上，我们可以把采集时间相近于一个阈值的数据，看成是一对图像。并把相近时间的位姿，看作是该图像的真实采集位置。TUM提供了一个Python脚本“associateODOTpy”（或使用slambookODIVIDEtoolsODIVIDEassociateODOTpy）帮我们完成这件事。请把此文件放到数据集目录下，运行：
OMODULOOBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshCLOSESQUARE
OMODULOpython associateODOTpy rgbODOTtxt depthODOTtxt OLESS associateODOTtxt
OMODULOOBACKSLASHendOPENCURLYlstlistingCLOSECURLY
OMODULO
OMODULO这段脚本会根据输入的两个文件中的采集时间进行配对，最后输出到文件associateODOTtxt。输出文件含有配对后的两幅图像的时间、文件名信息，可以作为后续处理的来源。此外，TUM数据集还提供了比较估计轨迹与标准轨迹的工具，我们将在用到的地方再进行介绍。
OBACKSLASHsubsectionOPENCURLY使用LK光流CLOSECURLY
在实践部分，我们将使用几张示例图像，用OpenCV的光流来追踪上面的特征点。同时，我们也将手动实现一个LK光流，以达到加深理解的效果。我们使用两张来自Euroc数据集的示例图像，在第一张图像中提取角点，然后用光流追踪它们在第二张中的位置。首先我们来使用OpenCV中的LK光流：

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch8ODIVIDEopticalOUNDERSCOREflowODOTcpp（片段）CLOSESQUARE
ODIVIDEODIVIDE use opencv's flow for validation
vectorOGREATPoint2fOLESS pt1OCOMMA pt2OSEMICOLON
for OPENBRACKETauto OBANDkpOCOLON kp1CLOSEBRACKET pt1ODOTpushOUNDERSCOREbackOPENBRACKETkpODOTptCLOSEBRACKETOSEMICOLON
vectorOGREATucharOLESS statusOSEMICOLON
vectorOGREATfloatOLESS errorOSEMICOLON
cvOCOLONOCOLONcalcOpticalFlowPyrLKOPENBRACKETimg1OCOMMA img2OCOMMA pt1OCOMMA pt2OCOMMA statusOCOMMA errorCLOSEBRACKETOSEMICOLON
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

OpenCV的光流在使用上十分简单，只需调用cvOCOLONOCOLONcalcOpticalFlowPyrLK函数，提供前后两张图像以及对应的特征点，即可得到追踪后的点，以及各点的状态、误差。我们可以根据status变量是否为1来确定对应的点是否正确被追踪到。该函数还有一些可选的参数，但是在演示中我们只使用默认参数。我们在此省略其他提特征、画结果的代码，这些在之前的程序中已经展示过了。

OBACKSLASHsubsectionOPENCURLY用高斯牛顿法实现光流CLOSECURLY
OBACKSLASHsubsubsectionOPENCURLY单层光流CLOSECURLY
光流也可以看成一个优化问题：通过最小化灰度误差，来估计最优的像素偏移。所以，类似于之前实现的各种高斯牛顿法化，我们现在也来实现一个基于高斯牛顿法的光流。

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch8ODIVIDEopticalOUNDERSCOREflowODOTcpp（片段）CLOSESQUARE
class OpticalFlowTracker OPENCURLY
publicOCOLON
	OpticalFlowTrackerOPENBRACKET
		const Mat OBANDimg1OUNDERSCOREOCOMMA
		const Mat OBANDimg2OUNDERSCOREOCOMMA
		const vectorOGREATKeyPointOLESS OBANDkp1OUNDERSCOREOCOMMA
		vectorOGREATKeyPointOLESS OBANDkp2OUNDERSCOREOCOMMA
		vectorOGREATboolOLESS OBANDsuccessOUNDERSCOREOCOMMA
		bool inverseOUNDERSCORE OASSIGN trueOCOMMA bool hasOUNDERSCOREinitialOUNDERSCORE OASSIGN falseCLOSEBRACKET OCOLON
		img1OPENBRACKETimg1OUNDERSCORECLOSEBRACKETOCOMMA img2OPENBRACKETimg2OUNDERSCORECLOSEBRACKETOCOMMA kp1OPENBRACKETkp1OUNDERSCORECLOSEBRACKETOCOMMA kp2OPENBRACKETkp2OUNDERSCORECLOSEBRACKETOCOMMA successOPENBRACKETsuccessOUNDERSCORECLOSEBRACKETOCOMMA inverseOPENBRACKETinverseOUNDERSCORECLOSEBRACKETOCOMMA
		hasOUNDERSCOREinitialOPENBRACKEThasOUNDERSCOREinitialOUNDERSCORECLOSEBRACKET OPENCURLYCLOSECURLY
	
	void calculateOpticalFlowOPENBRACKETconst Range OBANDrangeCLOSEBRACKETOSEMICOLON

privateOCOLON
	const Mat OBANDimg1OSEMICOLON
	const Mat OBANDimg2OSEMICOLON
	const vectorOGREATKeyPointOLESS OBANDkp1OSEMICOLON
	vectorOGREATKeyPointOLESS OBANDkp2OSEMICOLON
	vectorOGREATboolOLESS OBANDsuccessOSEMICOLON
	bool inverse OASSIGN trueOSEMICOLON
	bool hasOUNDERSCOREinitial OASSIGN falseOSEMICOLON
CLOSECURLYOSEMICOLON

void OpticalFlowSingleLevelOPENBRACKET
	const Mat OBANDimg1OCOMMA
	const Mat OBANDimg2OCOMMA
	const vectorOGREATKeyPointOLESS OBANDkp1OCOMMA
	vectorOGREATKeyPointOLESS OBANDkp2OCOMMA
	vectorOGREATboolOLESS OBANDsuccessOCOMMA
	bool inverseOCOMMA bool hasOUNDERSCOREinitialCLOSEBRACKET OPENCURLY
	kp2ODOTresizeOPENBRACKETkp1ODOTsizeOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
	successODOTresizeOPENBRACKETkp1ODOTsizeOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
	OpticalFlowTracker trackerOPENBRACKETimg1OCOMMA img2OCOMMA kp1OCOMMA kp2OCOMMA successOCOMMA inverseOCOMMA hasOUNDERSCOREinitialCLOSEBRACKETOSEMICOLON
	parallelOUNDERSCOREforOUNDERSCOREOPENBRACKETRangeOPENBRACKET0OCOMMA kp1ODOTsizeOPENBRACKETCLOSEBRACKETCLOSEBRACKETOCOMMA
		stdOCOLONOCOLONbindOPENBRACKETOBANDOpticalFlowTrackerOCOLONOCOLONcalculateOpticalFlowOCOMMA OBANDtrackerOCOMMA placeholdersOCOLONOCOLONOUNDERSCORE1CLOSEBRACKETCLOSEBRACKETOSEMICOLON
CLOSECURLY

void OpticalFlowTrackerOCOLONOCOLONcalculateOpticalFlowOPENBRACKETconst Range OBANDrangeCLOSEBRACKET OPENCURLY
	ODIVIDEODIVIDE parameters
	int halfOUNDERSCOREpatchOUNDERSCOREsize OASSIGN 4OSEMICOLON
	int iterations OASSIGN 10OSEMICOLON
	for OPENBRACKETsizeOUNDERSCOREt i OASSIGN rangeODOTstartOSEMICOLON i OGREAT rangeODOTendOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
		auto kp OASSIGN kp1OPENSQUAREiCLOSESQUAREOSEMICOLON
		double dx OASSIGN 0OCOMMA dy OASSIGN 0OSEMICOLON ODIVIDEODIVIDE dxOCOMMAdy need to be estimated
		if OPENBRACKEThasOUNDERSCOREinitialCLOSEBRACKET OPENCURLY
			dx OASSIGN kp2OPENSQUAREiCLOSESQUAREODOTptODOTx OMINUS kpODOTptODOTxOSEMICOLON
			dy OASSIGN kp2OPENSQUAREiCLOSESQUAREODOTptODOTy OMINUS kpODOTptODOTyOSEMICOLON
		CLOSECURLY
		
		double cost OASSIGN 0OCOMMA lastCost OASSIGN 0OSEMICOLON
		bool succ OASSIGN trueOSEMICOLON ODIVIDEODIVIDE indicate if this point succeeded
		
		ODIVIDEODIVIDE GaussOMINUSNewton iterations
		EigenOCOLONOCOLONMatrix2d H OASSIGN EigenOCOLONOCOLONMatrix2dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON    ODIVIDEODIVIDE hessian
		EigenOCOLONOCOLONVector2d b OASSIGN EigenOCOLONOCOLONVector2dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON    ODIVIDEODIVIDE bias
		EigenOCOLONOCOLONVector2d JOSEMICOLON  ODIVIDEODIVIDE jacobian
		for OPENBRACKETint iter OASSIGN 0OSEMICOLON iter OGREAT iterationsOSEMICOLON iterOPLUSOPLUSCLOSEBRACKET OPENCURLY
			if OPENBRACKETinverse OASSIGNOASSIGN falseCLOSEBRACKET OPENCURLY
				H OASSIGN EigenOCOLONOCOLONMatrix2dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
				b OASSIGN EigenOCOLONOCOLONVector2dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
			CLOSECURLY else OPENCURLY
				ODIVIDEODIVIDE only reset b
				b OASSIGN EigenOCOLONOCOLONVector2dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
			CLOSECURLY
			
			cost OASSIGN 0OSEMICOLON
			
			ODIVIDEODIVIDE compute cost and jacobian
			for OPENBRACKETint x OASSIGN OMINUShalfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON x OGREAT halfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON xOPLUSOPLUSCLOSEBRACKET
			for OPENBRACKETint y OASSIGN OMINUShalfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON y OGREAT halfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON yOPLUSOPLUSCLOSEBRACKET OPENCURLY
				double error OASSIGN GetPixelValueOPENBRACKETimg1OCOMMA kpODOTptODOTx OPLUS xOCOMMA kpODOTptODOTy OPLUS yCLOSEBRACKET OMINUS
					GetPixelValueOPENBRACKETimg2OCOMMA kpODOTptODOTx OPLUS x OPLUS dxOCOMMA kpODOTptODOTy OPLUS y OPLUS dyCLOSEBRACKETOSEMICOLONOSEMICOLON  ODIVIDEODIVIDE Jacobian
				if OPENBRACKETinverse OASSIGNOASSIGN falseCLOSEBRACKET OPENCURLY
					J OASSIGN OMINUS1ODOT0 OMULTIPLY EigenOCOLONOCOLONVector2dOPENBRACKET
						0ODOT5 OMULTIPLY OPENBRACKETGetPixelValueOPENBRACKETimg2OCOMMA kpODOTptODOTx OPLUS dx OPLUS x OPLUS 1OCOMMA kpODOTptODOTy OPLUS dy OPLUS yCLOSEBRACKET OMINUS
							GetPixelValueOPENBRACKETimg2OCOMMA kpODOTptODOTx OPLUS dx OPLUS x OMINUS 1OCOMMA kpODOTptODOTy OPLUS dy OPLUS yCLOSEBRACKETCLOSEBRACKETOCOMMA
						0ODOT5 OMULTIPLY OPENBRACKETGetPixelValueOPENBRACKETimg2OCOMMA kpODOTptODOTx OPLUS dx OPLUS xOCOMMA kpODOTptODOTy OPLUS dy OPLUS y OPLUS 1CLOSEBRACKET OMINUS
							GetPixelValueOPENBRACKETimg2OCOMMA kpODOTptODOTx OPLUS dx OPLUS xOCOMMA kpODOTptODOTy OPLUS dy OPLUS y OMINUS 1CLOSEBRACKETCLOSEBRACKET
					CLOSEBRACKETOSEMICOLON
				CLOSECURLY else if OPENBRACKETiter OASSIGNOASSIGN 0CLOSEBRACKET OPENCURLY
					ODIVIDEODIVIDE in inverse modeOCOMMA J keeps same for all iterations
					ODIVIDEODIVIDE NOTE this J does not change when dxOCOMMA dy is updatedOCOMMA so we can store it and only compute error
					J OASSIGN OMINUS1ODOT0 OMULTIPLY EigenOCOLONOCOLONVector2dOPENBRACKET
						0ODOT5 OMULTIPLY OPENBRACKETGetPixelValueOPENBRACKETimg1OCOMMA kpODOTptODOTx OPLUS x OPLUS 1OCOMMA kpODOTptODOTy OPLUS yCLOSEBRACKET OMINUS
							GetPixelValueOPENBRACKETimg1OCOMMA kpODOTptODOTx OPLUS x OMINUS 1OCOMMA kpODOTptODOTy OPLUS yCLOSEBRACKETCLOSEBRACKETOCOMMA
						0ODOT5 OMULTIPLY OPENBRACKETGetPixelValueOPENBRACKETimg1OCOMMA kpODOTptODOTx OPLUS xOCOMMA kpODOTptODOTy OPLUS y OPLUS 1CLOSEBRACKET OMINUS
							GetPixelValueOPENBRACKETimg1OCOMMA kpODOTptODOTx OPLUS xOCOMMA kpODOTptODOTy OPLUS y OMINUS 1CLOSEBRACKETCLOSEBRACKET
					CLOSEBRACKETOSEMICOLON
				CLOSECURLY
				ODIVIDEODIVIDE compute HOCOMMA b and set costOSEMICOLON
				b OPLUSOASSIGN OMINUSerror OMULTIPLY JOSEMICOLON
				cost OPLUSOASSIGN error OMULTIPLY errorOSEMICOLON
				if OPENBRACKETinverse OASSIGNOASSIGN false OBBOROBBOR iter OASSIGNOASSIGN 0CLOSEBRACKET OPENCURLY
					ODIVIDEODIVIDE also update H
					H OPLUSOASSIGN J OMULTIPLY JODOTtransposeOPENBRACKETCLOSEBRACKETOSEMICOLON
				CLOSECURLY
			CLOSECURLY
			
			ODIVIDEODIVIDE compute update
			EigenOCOLONOCOLONVector2d update OASSIGN HODOTldltOPENBRACKETCLOSEBRACKETODOTsolveOPENBRACKETbCLOSEBRACKETOSEMICOLON
			
			if OPENBRACKETstdOCOLONOCOLONisnanOPENBRACKETupdateOPENSQUARE0CLOSESQUARECLOSEBRACKETCLOSEBRACKET OPENCURLY
				ODIVIDEODIVIDE sometimes occurred when we have a black or white patch and H is irreversible
				cout OGREATOGREAT "update is nan" OGREATOGREAT endlOSEMICOLON
				succ OASSIGN falseOSEMICOLON
				breakOSEMICOLON
			CLOSECURLY
			
			if OPENBRACKETiter OLESS 0 OBANDOBAND cost OLESS lastCostCLOSEBRACKET OPENCURLY
				breakOSEMICOLON
			CLOSECURLY
			
			ODIVIDEODIVIDE update dxOCOMMA dy
			dx OPLUSOASSIGN updateOPENSQUARE0CLOSESQUAREOSEMICOLON
			dy OPLUSOASSIGN updateOPENSQUARE1CLOSESQUAREOSEMICOLON
			lastCost OASSIGN costOSEMICOLON
			succ OASSIGN trueOSEMICOLON
			
			if OPENBRACKETupdateODOTnormOPENBRACKETCLOSEBRACKET OGREAT 1eOMINUS2CLOSEBRACKET OPENCURLY
				ODIVIDEODIVIDE converge
				breakOSEMICOLON
			CLOSECURLY
		CLOSECURLY
		
		successOPENSQUAREiCLOSESQUARE OASSIGN succOSEMICOLON
		
		ODIVIDEODIVIDE set kp2
		kp2OPENSQUAREiCLOSESQUAREODOTpt OASSIGN kpODOTpt OPLUS Point2fOPENBRACKETdxOCOMMA dyCLOSEBRACKETOSEMICOLON
	CLOSECURLY
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

我们在OpticalFlowSingleLevel函数中实现了单层光流函数，其中调用了cvOCOLONOCOLONparallelOBACKSLASHOUNDERSCOREforOBACKSLASHOUNDERSCORE并行调用OpticalFlowTrackerOCOLONOCOLONcalculateOpticalFlow，该函数计算指定范围内特征点的光流。这个并行for循环内部是Intel tbb库实现的，我们只需按照其接口，将函数本体定义出来，然后将函数作为stdOCOLONOCOLONfunction对象传递给它即可。

在具体函数实现中（即calculateOpticalFlow），我们求解这样一个问题：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHmathop OPENCURLYOBACKSLASHmin CLOSECURLYOBACKSLASHlimitsOUNDERSCOREOPENCURLYOBACKSLASHDelta xOCOMMAOBACKSLASHDelta yCLOSECURLY OBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE1CLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYxOCOMMAyCLOSECURLY OBACKSLASHrightCLOSEBRACKET OMINUS OPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE2CLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYx OPLUS OBACKSLASHDelta xOCOMMAy OPLUS OBACKSLASHDelta yCLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHrightOBACKSLASHOBBOROUNDERSCORE2OHAT2ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
因此，残差为括号内部的部分，对应的雅可比为第二个图像在ODOLLARx OPLUS OBACKSLASHDelta xOCOMMAy OPLUS OBACKSLASHDelta yODOLLAR处的梯度。此外，根据文献OBACKSLASHciteOPENCURLYBaker2004CLOSECURLY，这里的梯度也可以用第一个图像的梯度ODOLLAROBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE1 OPENBRACKETxOCOMMAyCLOSEBRACKETODOLLAR来代替。这种代替的方法称为OBACKSLASHtextbfOPENCURLY反向CLOSECURLY（Inverse）光流法。在反向光流中，ODOLLAROBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE1 OPENBRACKETxOCOMMAyCLOSEBRACKETODOLLAR的梯度是保持不变的，所以我们可以在第一次迭代时保留计算的结果，在后续迭代中使用。当雅可比不变时，ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵不变，每次迭代只需计算残差，这可以节省一部分计算量。

OBACKSLASHsubsubsectionOPENCURLY多层光流CLOSECURLY
由于我们把光流写成了优化问题，那么就必须假设优化的初始值靠近最优值，才能在一定程度下保障算法的收敛。于是，如果相机运动较快，两张图像差异较明显，那么单层图像光流法容易达到一个局部极小值。这种情况可以通过引入图像金字塔来改善。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGNODOT7OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo2ODIVIDEimageOMINUSpyramidCLOSECURLY
	OBACKSLASHcaptionOPENCURLY图像金字塔和CoarseOMINUStoOMINUSfine过程。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONimageOMINUSpyramidCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

图像金字塔是指对同一个图像进行缩放，得到不同分辨率下的图像，如OBACKSLASHautorefOPENCURLYfigOCOLONimageOMINUSpyramidCLOSECURLY所示。以原始图像作为金字塔底层，每往上一层，就对下层图像进行一定倍率的缩放，就得到了一个金字塔。然后，在计算光流时，先从顶层的图像开始计算，然后把上一层的追踪结果，作为下一层光流的初始值。由于上层的图像相对粗糙，所以这个过程也称为OBACKSLASHtextbfOPENCURLY由粗至精CLOSECURLY（CoarseOMINUStoOMINUSfine）的光流，也是实用光流法的通常流程。

由粗至精的好处在于，当原始图像的像素运动较大时，在金字塔顶层的图像看来，运动仍然在一个很小范围内。例如，原始图像的特征点运动了20个像素，很容易由于图像非凸性导致优化困在极小值里。但现在假设有缩放倍率为0ODOT5倍的金字塔，那么往上两层图像里，像素运动就只有5个像素了，这时结果就明显好于直接在原始图像上优化。

我们在程序中实现了多层光流，代码如下：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch8ODIVIDEopticalOUNDERSCOREflowODOTcpp（片段）CLOSESQUARE
void OpticalFlowMultiLevelOPENBRACKET
	const Mat OBANDimg1OCOMMA
	const Mat OBANDimg2OCOMMA
	const vectorOGREATKeyPointOLESS OBANDkp1OCOMMA
	vectorOGREATKeyPointOLESS OBANDkp2OCOMMA
	vectorOGREATboolOLESS OBANDsuccessOCOMMA
	bool inverseCLOSEBRACKET OPENCURLY
	
	ODIVIDEODIVIDE parameters
	int pyramids OASSIGN 4OSEMICOLON
	double pyramidOUNDERSCOREscale OASSIGN 0ODOT5OSEMICOLON
	double scalesOPENSQUARECLOSESQUARE OASSIGN OPENCURLY1ODOT0OCOMMA 0ODOT5OCOMMA 0ODOT25OCOMMA 0ODOT125CLOSECURLYOSEMICOLON
	
	ODIVIDEODIVIDE create pyramids
	vectorOGREATMatOLESS pyr1OCOMMA pyr2OSEMICOLON ODIVIDEODIVIDE image pyramids
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT pyramidsOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
		if OPENBRACKETi OASSIGNOASSIGN 0CLOSEBRACKET OPENCURLY
			pyr1ODOTpushOUNDERSCOREbackOPENBRACKETimg1CLOSEBRACKETOSEMICOLON
			pyr2ODOTpushOUNDERSCOREbackOPENBRACKETimg2CLOSEBRACKETOSEMICOLON
		CLOSECURLY else OPENCURLY
			Mat img1OUNDERSCOREpyrOCOMMA img2OUNDERSCOREpyrOSEMICOLON
			cvOCOLONOCOLONresizeOPENBRACKETpyr1OPENSQUAREi OMINUS 1CLOSESQUAREOCOMMA img1OUNDERSCOREpyrOCOMMA
			cvOCOLONOCOLONSizeOPENBRACKETpyr1OPENSQUAREi OMINUS 1CLOSESQUAREODOTcols OMULTIPLY pyramidOUNDERSCOREscaleOCOMMA pyr1OPENSQUAREi OMINUS 1CLOSESQUAREODOTrows OMULTIPLY pyramidOUNDERSCOREscaleCLOSEBRACKETCLOSEBRACKETOSEMICOLON
			cvOCOLONOCOLONresizeOPENBRACKETpyr2OPENSQUAREi OMINUS 1CLOSESQUAREOCOMMA img2OUNDERSCOREpyrOCOMMA
			cvOCOLONOCOLONSizeOPENBRACKETpyr2OPENSQUAREi OMINUS 1CLOSESQUAREODOTcols OMULTIPLY pyramidOUNDERSCOREscaleOCOMMA pyr2OPENSQUAREi OMINUS 1CLOSESQUAREODOTrows OMULTIPLY pyramidOUNDERSCOREscaleCLOSEBRACKETCLOSEBRACKETOSEMICOLON
			pyr1ODOTpushOUNDERSCOREbackOPENBRACKETimg1OUNDERSCOREpyrCLOSEBRACKETOSEMICOLON
			pyr2ODOTpushOUNDERSCOREbackOPENBRACKETimg2OUNDERSCOREpyrCLOSEBRACKETOSEMICOLON
		CLOSECURLY
	CLOSECURLY

	ODIVIDEODIVIDE coarseOMINUStoOMINUSfine LK tracking in pyramids
	vectorOGREATKeyPointOLESS kp1OUNDERSCOREpyrOCOMMA kp2OUNDERSCOREpyrOSEMICOLON
	for OPENBRACKETauto OBANDkpOCOLONkp1CLOSEBRACKET OPENCURLY
		auto kpOUNDERSCOREtop OASSIGN kpOSEMICOLON
		kpOUNDERSCOREtopODOTpt OMULTIPLYOASSIGN scalesOPENSQUAREpyramids OMINUS 1CLOSESQUAREOSEMICOLON
		kp1OUNDERSCOREpyrODOTpushOUNDERSCOREbackOPENBRACKETkpOUNDERSCOREtopCLOSEBRACKETOSEMICOLON
		kp2OUNDERSCOREpyrODOTpushOUNDERSCOREbackOPENBRACKETkpOUNDERSCOREtopCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	for OPENBRACKETint level OASSIGN pyramids OMINUS 1OSEMICOLON level OLESSOASSIGN 0OSEMICOLON levelOMINUSOMINUSCLOSEBRACKET OPENCURLY
		ODIVIDEODIVIDE from coarse to fine
		successODOTclearOPENBRACKETCLOSEBRACKETOSEMICOLON
		OpticalFlowSingleLevelOPENBRACKETpyr1OPENSQUARElevelCLOSESQUAREOCOMMA pyr2OPENSQUARElevelCLOSESQUAREOCOMMA kp1OUNDERSCOREpyrOCOMMA kp2OUNDERSCOREpyrOCOMMA successOCOMMA inverseOCOMMA trueCLOSEBRACKETOSEMICOLON
		
		if OPENBRACKETlevel OLESS 0CLOSEBRACKET OPENCURLY
			for OPENBRACKETauto OBANDkpOCOLON kp1OUNDERSCOREpyrCLOSEBRACKET
			kpODOTpt ODIVIDEOASSIGN pyramidOUNDERSCOREscaleOSEMICOLON
			for OPENBRACKETauto OBANDkpOCOLON kp2OUNDERSCOREpyrCLOSEBRACKET
			kpODOTpt ODIVIDEOASSIGN pyramidOUNDERSCOREscaleOSEMICOLON
		CLOSECURLY
	CLOSECURLY
	
	for OPENBRACKETauto OBANDkpOCOLON kp2OUNDERSCOREpyrCLOSEBRACKET
		kp2ODOTpushOUNDERSCOREbackOPENBRACKETkpCLOSEBRACKETOSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

这段代码构造了一个四层的，倍率为0ODOT5的金字塔，并调用单层光流函数实现了多层光流。在主函数中，我们分别对两张图像测试了OpenCV的光流、单层光流和多层光流的表现，计算了它们的运行时间：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshOCOMMAcaptionOASSIGN终端输入：CLOSESQUARE
ODOTODIVIDEbuildODIVIDEopticalOUNDERSCOREflow
build pyramid timeOCOLON 0ODOT000150349
track pyr 3 cost timeOCOLON 0ODOT000304633
track pyr 2 cost timeOCOLON 0ODOT000392889
track pyr 1 cost timeOCOLON 0ODOT000382347
track pyr 0 cost timeOCOLON 0ODOT000375099
optical flow by gaussOMINUSnewtonOCOLON 0ODOT00189268
optical flow by opencvOCOLON 0ODOT00220134
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY
从运行时间上来看，多层光流法的耗时和OpenCV大致相当。由于并行化程序在每次运行的表现不尽相同，在读者机器上这些数字不会精确相同。光流的对比图见OBACKSLASHautorefOPENCURLYfigOCOLONopticalOMINUSflowOMINUSresultCLOSECURLY。从结果图上看，多层光流与OpenCV的效果相当，单层光流要明显弱于多层光流。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGNODOT85OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo2ODIVIDEopticalOMINUSflowCLOSECURLY
	OBACKSLASHcaptionOPENCURLY各种光流的结果对比CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONopticalOMINUSflowOMINUSresultCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

OBACKSLASHsubsectionOPENCURLY光流实践小结CLOSECURLY
我们看到，LK光流跟踪能够直接得到特征点的对应关系。这个对应关系就像是描述子的匹配，只是光流对图像的连续性和光照稳定性要求更高一些。我们可以通过光流跟踪的特征点，用PnP、ICP或对极几何来估计相机运动，这些方法在上一讲中介绍过，这里不再讨论。

从运行时间上来看，演示实验大约于230个特征点，OpenCV和多层光流需要大约2毫秒完成追踪（我用的CPU是Intel I7OMINUS8550U），这实际上是相当快的。如果我们前面使用FAST这样的关键点，那么整个光流计算可以做到5毫秒左右，相比于特征匹配来说算是非常快了。不过，如果角点提的位置不好，光流也容易跟丢或给出错误的结果，这就需要后续算法拥有一定的异常值去除机制，我们留到工程章节再谈。

总而言之，光流法可以加速基于特征点的视觉里程计算法，避免计算和匹配描述子的过程，但要求相机运动较平滑（或采集频率较高）。

OBACKSLASHsectionOPENCURLY直接法（Direct Method）CLOSECURLY
接下来，我们来讨论与光流有一定相似性的直接法。与前面内容相似，我们先介绍直接法的原理，然后使用实现一遍直接法。

OBACKSLASHsubsectionOPENCURLY直接法的推导CLOSECURLY
在光流中，我们会首先追踪特征点的位置，然后再根据这些位置确定相机的运动。那么，这样一种两步走的方案，很难保证全局的最优性。我们可以问，能不能在后一步中，调整一下前一步的结果呢？比方说，如果我认为相机右转了15度，那么光流能不能以这个15度运动作为初始值的假设，调整光流的计算结果呢？直接法就是遵循这样的思路得到的结果。

如OBACKSLASHautorefOPENCURLYfigOCOLONdirectMethodCLOSECURLYOTILDE所示，考虑某个空间点ODOLLARPODOLLAR和两个时刻的相机。ODOLLARPODOLLAR的世界坐标为ODOLLAROPENSQUAREXOCOMMAYOCOMMAZCLOSESQUAREODOLLAR，它在两个相机上成像，记像素坐标为ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2ODOLLAR。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGNODOT85OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo2ODIVIDEdirectMethodCLOSECURLY
	OBACKSLASHcaptionOPENCURLY直接法示意图。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONdirectMethodCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

我们的目标是求第一个相机到第二个相机的相对位姿变换。我们以第一个相机为参照系，设第二个相机的旋转和平移为ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR（对应李群为ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR）。同时，两相机的内参相同，记为ODOLLAROBACKSLASHbmOPENCURLYKCLOSECURLYODOLLAR。为清楚起见，我们列写完整的投影方程：
OBACKSLASHbeginOPENCURLYalignOMULTIPLYCLOSECURLY
OPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1CLOSECURLY OBANDOASSIGN OPENCURLYOBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
	uOBACKSLASHOBACKSLASH
	vOBACKSLASHOBACKSLASH
	1
	OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUAREOUNDERSCORE1CLOSECURLY OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLYZOUNDERSCORE1CLOSECURLY OBACKSLASHbmOPENCURLYKPCLOSECURLYOCOMMA OBACKSLASHOBACKSLASH
OPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2CLOSECURLY OBANDOASSIGN OPENCURLYOBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
	uOBACKSLASHOBACKSLASH
	vOBACKSLASHOBACKSLASH
	1
	OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUAREOUNDERSCORE2CLOSECURLY OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLYZOUNDERSCORE2CLOSECURLY OBACKSLASHbmOPENCURLYKCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYRPCLOSECURLY OPLUSOBACKSLASHbmOPENCURLYtCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLYZOUNDERSCORE2CLOSECURLY OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHleftOPENBRACKETOBACKSLASHbmOPENCURLYTCLOSECURLY  OBACKSLASHbmOPENCURLYPCLOSECURLY OBACKSLASHrightCLOSEBRACKETOUNDERSCOREOPENCURLY1OCOLON3CLOSECURLYODOT
OBACKSLASHendOPENCURLYalignOMULTIPLYCLOSECURLY
其中ODOLLARZOUNDERSCORE1ODOLLAR是ODOLLARPODOLLAR的深度，ODOLLARZOUNDERSCORE2ODOLLAR是ODOLLARPODOLLAR在第二个相机坐标系下的深度，也就是ODOLLAROBACKSLASHbmOPENCURLYRPCLOSECURLYOPLUSOBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR的第3个坐标值。由于ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR只能和齐次坐标相乘，所以我们乘完之后要取出前3个元素。这和第OBACKSLASHrefOPENCURLYcptOCOLON5CLOSECURLY讲的内容是一致的。

回忆特征点法中，由于我们通过匹配描述子知道了ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2ODOLLAR的像素位置，所以可以计算重投影的位置。但在直接法中，由于没有特征匹配，我们无从知道哪一个ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2ODOLLAR与ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1ODOLLAR对应着同一个点。直接法的思路是根据当前相机的位姿估计值来寻找ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2ODOLLAR的位置。但若相机位姿不够好，ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2ODOLLAR的外观和ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1ODOLLAR会有明显差别。于是，为了减小这个差别，我们优化相机的位姿，来寻找与ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1ODOLLAR更相似的ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2ODOLLAR。这同样可以通过解一个优化问题完成，但此时最小化的不是重投影误差，而是OBACKSLASHtextbfOPENCURLY光度误差CLOSECURLY（Photometric Error），也就是ODOLLARPODOLLAR的两个像素的亮度误差：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
e OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE1CLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1CLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OMINUS OPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE2CLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2CLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

注意这里ODOLLAReODOLLAR是一个标量。同样地，优化目标为该误差的二范数，暂时取不加权的形式，为：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHmathop OPENCURLYOBACKSLASHmin CLOSECURLYOBACKSLASHlimitsOUNDERSCOREOPENCURLYOBACKSLASHbmOPENCURLYTCLOSECURLYCLOSECURLY  JOBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYTCLOSECURLY  OBACKSLASHrightCLOSEBRACKET OASSIGN OBACKSLASHOBBOReOBACKSLASHOBBOROHAT2ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

能够做这种优化的理由，仍是基于OBACKSLASHtextbfOPENCURLY灰度不变假设CLOSECURLY。我们假设一个空间点在各个视角下成像的灰度是不变的。我们有许多个（比如ODOLLARNODOLLAR个）空间点ODOLLARPOUNDERSCOREiODOLLAR，那么，整个相机位姿估计问题变为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHmathop OPENCURLYOBACKSLASHmin CLOSECURLYOBACKSLASHlimitsOUNDERSCOREOPENCURLYOBACKSLASHbmOPENCURLYTCLOSECURLYCLOSECURLY  JOBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYTCLOSECURLY  OBACKSLASHrightCLOSEBRACKET OASSIGN OBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATN OPENCURLYeOUNDERSCOREiOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOPENCURLYeOUNDERSCOREiCLOSECURLYCLOSECURLYOCOMMA OBACKSLASHquad OPENCURLYeOUNDERSCOREiCLOSECURLY OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE1CLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREOPENCURLY1OCOMMAiCLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OMINUS OPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE2CLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLY OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREOPENCURLY2OCOMMAiCLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

注意这里的优化变量是相机位姿ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR，而不像光流那样优化各个特征点的运动。为了求解这个优化问题，我们关心误差ODOLLAReODOLLAR是如何随着相机位姿ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR变化的，需要分析它们的导数关系。因此，定义两个中间变量：
OBACKSLASHbeginOPENCURLYalignOMULTIPLYCLOSECURLY
OBACKSLASHbmOPENCURLYqCLOSECURLY OBANDOASSIGN OBACKSLASHbmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYPCLOSECURLYOCOMMA OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYuCLOSECURLY OBANDOASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLYOPENCURLYOPENCURLYZOUNDERSCORE2CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYODOT
OBACKSLASHendOPENCURLYalignOMULTIPLYCLOSECURLY
这里的ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR为ODOLLARPODOLLAR在第二个相机坐标系下的坐标，而ODOLLAROBACKSLASHbmOPENCURLYuCLOSECURLYODOLLAR为它的像素坐标。显然ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR是ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR的函数，ODOLLAROBACKSLASHbmOPENCURLYuCLOSECURLYODOLLAR是ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR的函数，从而也是ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR的函数。考虑李代数的左扰动模型，利用一阶泰勒展开，因为：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
eOPENBRACKETOBACKSLASHbmOPENCURLYTCLOSECURLYCLOSEBRACKETOASSIGNOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE1OPENBRACKETOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREOPENCURLY1CLOSECURLYCLOSEBRACKETOMINUSOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE2OPENBRACKETOBACKSLASHbmOPENCURLYuCLOSECURLYCLOSEBRACKETOCOMMA
OBACKSLASHendOPENCURLYequationCLOSECURLY
所以：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHfracOPENCURLYOBACKSLASHpartial eCLOSECURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYTCLOSECURLYCLOSECURLY OASSIGN OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OPENCURLYOBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE2CLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYuCLOSECURLYCLOSECURLYCLOSECURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYuCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYqCLOSECURLYCLOSECURLYCLOSECURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYqCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHdelta OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYCLOSECURLYOBACKSLASHdelta OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYOCOMMA
OBACKSLASHendOPENCURLYequationCLOSECURLY
其中ODOLLAROBACKSLASHdelta OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYODOLLAR为ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR的左扰动。我们看到，一阶导数由于链式法则分成了3项，而这3项都是容易计算的：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem ODOLLAR OBACKSLASHpartial OBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE2 ODIVIDE OBACKSLASHpartial OBACKSLASHbmOPENCURLYuCLOSECURLY ODOLLAR 为ODOLLAROBACKSLASHbmOPENCURLYuCLOSECURLYODOLLAR处的像素梯度。
	OBACKSLASHitem ODOLLAR OBACKSLASHpartial OBACKSLASHbmOPENCURLYuCLOSECURLY ODIVIDE OBACKSLASHpartial OBACKSLASHbmOPENCURLYqCLOSECURLY ODOLLAR 为投影方程关于相机坐标系下的三维点的导数。记ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYOASSIGNOPENSQUAREXOCOMMAYOCOMMAZCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR，根据第ODOLLAROBACKSLASHrefOPENCURLYcptOCOLON7CLOSECURLYODOLLAR讲的推导，导数为
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYuCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYqCLOSECURLYCLOSECURLYCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
		OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial uCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial XCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial uCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial YCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial uCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial ZCLOSECURLYCLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
		OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial vCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial XCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial vCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial YCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial vCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial ZCLOSECURLYCLOSECURLYCLOSECURLY
		OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
		OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHrmOPENCURLYZCLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBAND0OBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYXCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZOHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
		0OBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYZCLOSECURLYCLOSECURLYOBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZOHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLY
		OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	
	OBACKSLASHitem ODOLLAROPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYqCLOSECURLYCLOSECURLYODIVIDEOPENCURLYOBACKSLASHpartial OBACKSLASHdelta OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYODOLLAR为变换后的三维点对变换的导数，这在李代数一讲介绍过了：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYqCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHdelta OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLY OBACKSLASHbmOPENCURLYICLOSECURLYOCOMMA OMINUS OPENCURLYOBACKSLASHbmOPENCURLYqCLOSECURLYOHAT OBACKSLASHwedge CLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

在实践中，由于后两项只与三维点ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR有关，而与图像无关，我们经常把它合并在一起：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYuCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHdelta OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYZCLOSECURLYCLOSECURLYOBAND0OBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYXCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZOHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYXYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZOHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLY OPLUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYOPENCURLYXOHAT2CLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZOHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYYCLOSECURLYCLOSECURLYOPENCURLYZCLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	0OBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYZCLOSECURLYCLOSECURLYOBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZOHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLY OMINUS OPENCURLYfOUNDERSCOREyCLOSECURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYOPENCURLYYOHAT2CLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZOHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYXYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZOHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYXCLOSECURLYCLOSECURLYOPENCURLYZCLOSECURLYCLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这个ODOLLAR2 OBACKSLASHtimes 6ODOLLAR的矩阵在上一讲中也出现过。于是，我们推导出误差相对于李代数的雅可比矩阵：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONjacobianofDirectCLOSECURLY
OBACKSLASHbmOPENCURLYJCLOSECURLY OASSIGN  OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OPENCURLY OBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCORE2CLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYuCLOSECURLYCLOSECURLYCLOSECURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYuCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHdelta OBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

对于ODOLLARNODOLLAR个点的问题，我们可以用这种方法计算优化问题的雅可比矩阵，然后使用高斯牛顿法或列文伯格—马夸尔特方法计算增量，迭代求解。至此，我们推导了直接法估计相机位姿的整个流程，下面通过程序来演示一下直接法是如何使用的。

OBACKSLASHsubsectionOPENCURLY直接法的讨论CLOSECURLY
在上面的推导中，ODOLLARPODOLLAR是一个已知位置的空间点，它是怎么来的呢？在RGBOMINUSD相机下，我们可以把任意像素反投影到三维空间，然后投影到下一幅图像中。如果是双目，同样可以根据视差来计算像素的深度。如果在单目相机中，这件事情要更为困难，因为我们还须考虑由ODOLLARPODOLLAR的深度带来的不确定性。详细的深度估计放到第13讲中讨论。现在我们先来考虑简单的情况，即ODOLLARPODOLLAR深度已知的情况。

根据ODOLLARPODOLLAR的来源，我们可以把直接法进行分类：
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem ODOLLARPODOLLAR来自于稀疏关键点，我们称之为稀疏直接法。通常我们使用数百个至上千个关键点，并且像LOMINUSK光流那样，假设它周围像素也是不变的。这种稀疏直接法不必计算描述子，并且只使用数百个像素，因此速度最快，但只能计算稀疏的重构。
	OBACKSLASHitem ODOLLARPODOLLAR来自部分像素。我们看到式OBACKSLASHeqrefOPENCURLYeqOCOLONjacobianofDirectCLOSECURLY中，如果像素梯度为零，整项雅可比矩阵就为零，不会对计算运动增量有任何贡献。因此，可以考虑只使用带有梯度的像素点，舍弃像素梯度不明显的地方。这称为半稠密（SemiOMINUSDense）的直接法，可以重构一个半稠密结构。
	OBACKSLASHitem ODOLLARPODOLLAR为所有像素，称为稠密直接法。稠密重构需要计算所有像素（一般几十万至几百万个），因此多数不能在现有的CPU上实时计算，需要GPU的加速。但是，如前面所讨论的，像素梯度不明显的点，在运动估计中不会有太大贡献，在重构时也会难以估计位置。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

可以看到，从稀疏到稠密重构，都可以用直接法来计算。它们的计算量是逐渐增长的。稀疏方法可以快速地求解相机位姿，而稠密方法可以建立完整地图。具体使用哪种方法，需要视机器人的应用环境而定。特别地，在低端的计算平台上，稀疏直接法可以做到非常快速的效果，适用于实时性较高且计算资源有限的场合OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYEngel2016CLOSECURLYCLOSECURLY。

OBACKSLASHsectionOPENCURLY实践：直接法CLOSECURLY
OBACKSLASHsubsectionOPENCURLY单层直接法CLOSECURLY
现在，我们来演示如何使用稀疏的直接法。由于本书不涉及GPU编程，稠密的直接法就省略掉了。同时，为了保持程序简单，我们使用带深度的数据而非单目数据，这样可以省略掉单目的深度恢复部分。基于特征点的深度恢复（即三角化）已经在上一讲介绍过，而基于块匹配的深度恢复将在后面介绍。所以本节我们来考虑双目的稀疏直接法。

由于求解直接法最后等价于求解一个优化问题，因此可以使用g2o或Ceres这些优化库来帮助求解，也可以自己实现高斯牛顿法。和光流类似，直接法也可以分为单层直接法和金字塔式的多层直接法。我们同样先来实现单层直接法，进而拓展到多层。

在单层直接法中，类似于并行的光流，我们也可以并行地计算每个像素点的误差和雅可比，为此我们定义一个求雅可比的类：

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch8ODIVIDEdirectOUNDERSCOREmethodODOTcpp（片段）CLOSESQUARE
ODIVIDEODIVIDEODIVIDE class for accumulator jacobians in parallel
class JacobianAccumulator OPENCURLY
publicOCOLON
	JacobianAccumulatorOPENBRACKET
		const cvOCOLONOCOLONMat OBANDimg1OUNDERSCOREOCOMMA
		const cvOCOLONOCOLONMat OBANDimg2OUNDERSCOREOCOMMA
		const VecVector2d OBANDpxOUNDERSCORErefOUNDERSCOREOCOMMA
		const vectorOGREATdoubleOLESS depthOUNDERSCORErefOUNDERSCOREOCOMMA
		SophusOCOLONOCOLONSE3d OBANDT21OUNDERSCORECLOSEBRACKET OCOLON
	img1OPENBRACKETimg1OUNDERSCORECLOSEBRACKETOCOMMA img2OPENBRACKETimg2OUNDERSCORECLOSEBRACKETOCOMMA pxOUNDERSCORErefOPENBRACKETpxOUNDERSCORErefOUNDERSCORECLOSEBRACKETOCOMMA depthOUNDERSCORErefOPENBRACKETdepthOUNDERSCORErefOUNDERSCORECLOSEBRACKETOCOMMA T21OPENBRACKETT21OUNDERSCORECLOSEBRACKET OPENCURLY
		projection OASSIGN VecVector2dOPENBRACKETpxOUNDERSCORErefODOTsizeOPENBRACKETCLOSEBRACKETOCOMMA EigenOCOLONOCOLONVector2dOPENBRACKET0OCOMMA 0CLOSEBRACKETCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	ODIVIDEODIVIDEODIVIDE accumulate jacobians in a range
	void accumulateOUNDERSCOREjacobianOPENBRACKETconst cvOCOLONOCOLONRange OBANDrangeCLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDEODIVIDE get hessian matrix
	Matrix6d hessianOPENBRACKETCLOSEBRACKET const OPENCURLY return HOSEMICOLON CLOSECURLY
	
	ODIVIDEODIVIDEODIVIDE get bias
	Vector6d biasOPENBRACKETCLOSEBRACKET const OPENCURLY return bOSEMICOLON CLOSECURLY
	
	ODIVIDEODIVIDEODIVIDE get total cost
	double costOUNDERSCOREfuncOPENBRACKETCLOSEBRACKET const OPENCURLY return costOSEMICOLON CLOSECURLY
	
	ODIVIDEODIVIDEODIVIDE get projected points
	VecVector2d projectedOUNDERSCOREpointsOPENBRACKETCLOSEBRACKET const OPENCURLY return projectionOSEMICOLON CLOSECURLY
	
	ODIVIDEODIVIDEODIVIDE reset hOCOMMA bOCOMMA cost to zero
	void resetOPENBRACKETCLOSEBRACKET OPENCURLY
		H OASSIGN Matrix6dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
		b OASSIGN Vector6dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
		cost OASSIGN 0OSEMICOLON
	CLOSECURLY
	
privateOCOLON
	const cvOCOLONOCOLONMat OBANDimg1OSEMICOLON
	const cvOCOLONOCOLONMat OBANDimg2OSEMICOLON
	const VecVector2d OBANDpxOUNDERSCORErefOSEMICOLON
	const vectorOGREATdoubleOLESS depthOUNDERSCORErefOSEMICOLON
	SophusOCOLONOCOLONSE3d OBANDT21OSEMICOLON
	VecVector2d projectionOSEMICOLON ODIVIDEODIVIDE projected points
	
	stdOCOLONOCOLONmutex hessianOUNDERSCOREmutexOSEMICOLON
	Matrix6d H OASSIGN Matrix6dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
	Vector6d b OASSIGN Vector6dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
	double cost OASSIGN 0OSEMICOLON
CLOSECURLYOSEMICOLON

void JacobianAccumulatorOCOLONOCOLONaccumulateOUNDERSCOREjacobianOPENBRACKETconst cvOCOLONOCOLONRange OBANDrangeCLOSEBRACKET OPENCURLY
	
	ODIVIDEODIVIDE parameters
	const int halfOUNDERSCOREpatchOUNDERSCOREsize OASSIGN 1OSEMICOLON
	int cntOUNDERSCOREgood OASSIGN 0OSEMICOLON
	Matrix6d hessian OASSIGN Matrix6dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
	Vector6d bias OASSIGN Vector6dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
	double costOUNDERSCOREtmp OASSIGN 0OSEMICOLON
	
	for OPENBRACKETsizeOUNDERSCOREt i OASSIGN rangeODOTstartOSEMICOLON i OGREAT rangeODOTendOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
		ODIVIDEODIVIDE compute the projection in the second image
		EigenOCOLONOCOLONVector3d pointOUNDERSCOREref OASSIGN
		depthOUNDERSCORErefOPENSQUAREiCLOSESQUARE OMULTIPLY EigenOCOLONOCOLONVector3dOPENBRACKETOPENBRACKETpxOUNDERSCORErefOPENSQUAREiCLOSESQUAREOPENSQUARE0CLOSESQUARE OMINUS cxCLOSEBRACKET ODIVIDE fxOCOMMA OPENBRACKETpxOUNDERSCORErefOPENSQUAREiCLOSESQUAREOPENSQUARE1CLOSESQUARE OMINUS cyCLOSEBRACKET ODIVIDE fyOCOMMA 1CLOSEBRACKETOSEMICOLON
		EigenOCOLONOCOLONVector3d pointOUNDERSCOREcur OASSIGN T21 OMULTIPLY pointOUNDERSCORErefOSEMICOLON
		if OPENBRACKETpointOUNDERSCOREcurOPENSQUARE2CLOSESQUARE OGREAT 0CLOSEBRACKET   ODIVIDEODIVIDE depth invalid
			continueOSEMICOLON
		
		float u OASSIGN fx OMULTIPLY pointOUNDERSCOREcurOPENSQUARE0CLOSESQUARE ODIVIDE pointOUNDERSCOREcurOPENSQUARE2CLOSESQUARE OPLUS cxOCOMMA v OASSIGN fy OMULTIPLY pointOUNDERSCOREcurOPENSQUARE1CLOSESQUARE ODIVIDE pointOUNDERSCOREcurOPENSQUARE2CLOSESQUARE OPLUS cyOSEMICOLON
		if OPENBRACKETu OGREAT halfOUNDERSCOREpatchOUNDERSCOREsize OBBOROBBOR u OLESS img2ODOTcols OMINUS halfOUNDERSCOREpatchOUNDERSCOREsize OBBOROBBOR v OGREAT halfOUNDERSCOREpatchOUNDERSCOREsize OBBOROBBOR
		v OLESS img2ODOTrows OMINUS halfOUNDERSCOREpatchOUNDERSCOREsizeCLOSEBRACKET
			continueOSEMICOLON
		
		projectionOPENSQUAREiCLOSESQUARE OASSIGN EigenOCOLONOCOLONVector2dOPENBRACKETuOCOMMA vCLOSEBRACKETOSEMICOLON
		double X OASSIGN pointOUNDERSCOREcurOPENSQUARE0CLOSESQUAREOCOMMA Y OASSIGN pointOUNDERSCOREcurOPENSQUARE1CLOSESQUAREOCOMMA Z OASSIGN pointOUNDERSCOREcurOPENSQUARE2CLOSESQUAREOCOMMA
		Z2 OASSIGN Z OMULTIPLY ZOCOMMA ZOUNDERSCOREinv OASSIGN 1ODOT0 ODIVIDE ZOCOMMA Z2OUNDERSCOREinv OASSIGN ZOUNDERSCOREinv OMULTIPLY ZOUNDERSCOREinvOSEMICOLON
		cntOUNDERSCOREgoodOPLUSOPLUSOSEMICOLON
		
		ODIVIDEODIVIDE and compute error and jacobian
		for OPENBRACKETint x OASSIGN OMINUShalfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON x OGREATOASSIGN halfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON xOPLUSOPLUSCLOSEBRACKET
		for OPENBRACKETint y OASSIGN OMINUShalfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON y OGREATOASSIGN halfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON yOPLUSOPLUSCLOSEBRACKET OPENCURLY
			double error OASSIGN GetPixelValueOPENBRACKETimg1OCOMMA pxOUNDERSCORErefOPENSQUAREiCLOSESQUAREOPENSQUARE0CLOSESQUARE OPLUS xOCOMMA pxOUNDERSCORErefOPENSQUAREiCLOSESQUAREOPENSQUARE1CLOSESQUARE OPLUS yCLOSEBRACKET OMINUS
				GetPixelValueOPENBRACKETimg2OCOMMA u OPLUS xOCOMMA v OPLUS yCLOSEBRACKETOSEMICOLON
			Matrix26d JOUNDERSCOREpixelOUNDERSCORExiOSEMICOLON
			EigenOCOLONOCOLONVector2d JOUNDERSCOREimgOUNDERSCOREpixelOSEMICOLON
			
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET0OCOMMA 0CLOSEBRACKET OASSIGN fx OMULTIPLY ZOUNDERSCOREinvOSEMICOLON
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET0OCOMMA 1CLOSEBRACKET OASSIGN 0OSEMICOLON
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET0OCOMMA 2CLOSEBRACKET OASSIGN OMINUSfx OMULTIPLY X OMULTIPLY Z2OUNDERSCOREinvOSEMICOLON
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET0OCOMMA 3CLOSEBRACKET OASSIGN OMINUSfx OMULTIPLY X OMULTIPLY Y OMULTIPLY Z2OUNDERSCOREinvOSEMICOLON
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET0OCOMMA 4CLOSEBRACKET OASSIGN fx OPLUS fx OMULTIPLY X OMULTIPLY X OMULTIPLY Z2OUNDERSCOREinvOSEMICOLON
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET0OCOMMA 5CLOSEBRACKET OASSIGN OMINUSfx OMULTIPLY Y OMULTIPLY ZOUNDERSCOREinvOSEMICOLON
			
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET1OCOMMA 0CLOSEBRACKET OASSIGN 0OSEMICOLON
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET1OCOMMA 1CLOSEBRACKET OASSIGN fy OMULTIPLY ZOUNDERSCOREinvOSEMICOLON
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET1OCOMMA 2CLOSEBRACKET OASSIGN OMINUSfy OMULTIPLY Y OMULTIPLY Z2OUNDERSCOREinvOSEMICOLON
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET1OCOMMA 3CLOSEBRACKET OASSIGN OMINUSfy OMINUS fy OMULTIPLY Y OMULTIPLY Y OMULTIPLY Z2OUNDERSCOREinvOSEMICOLON
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET1OCOMMA 4CLOSEBRACKET OASSIGN fy OMULTIPLY X OMULTIPLY Y OMULTIPLY Z2OUNDERSCOREinvOSEMICOLON
			JOUNDERSCOREpixelOUNDERSCORExiOPENBRACKET1OCOMMA 5CLOSEBRACKET OASSIGN fy OMULTIPLY X OMULTIPLY ZOUNDERSCOREinvOSEMICOLON
			
			JOUNDERSCOREimgOUNDERSCOREpixel OASSIGN EigenOCOLONOCOLONVector2dOPENBRACKET
				0ODOT5 OMULTIPLY OPENBRACKETGetPixelValueOPENBRACKETimg2OCOMMA u OPLUS 1 OPLUS xOCOMMA v OPLUS yCLOSEBRACKET OMINUS GetPixelValueOPENBRACKETimg2OCOMMA u OMINUS 1 OPLUS xOCOMMA v OPLUS yCLOSEBRACKETCLOSEBRACKETOCOMMA
				0ODOT5 OMULTIPLY OPENBRACKETGetPixelValueOPENBRACKETimg2OCOMMA u OPLUS xOCOMMA v OPLUS 1 OPLUS yCLOSEBRACKET OMINUS GetPixelValueOPENBRACKETimg2OCOMMA u OPLUS xOCOMMA v OMINUS 1 OPLUS yCLOSEBRACKETCLOSEBRACKET
			CLOSEBRACKETOSEMICOLON
			
			ODIVIDEODIVIDE total jacobian
			Vector6d J OASSIGN OMINUS1ODOT0 OMULTIPLY OPENBRACKETJOUNDERSCOREimgOUNDERSCOREpixelODOTtransposeOPENBRACKETCLOSEBRACKET OMULTIPLY JOUNDERSCOREpixelOUNDERSCORExiCLOSEBRACKETODOTtransposeOPENBRACKETCLOSEBRACKETOSEMICOLON
			hessian OPLUSOASSIGN J OMULTIPLY JODOTtransposeOPENBRACKETCLOSEBRACKETOSEMICOLON
			bias OPLUSOASSIGN OMINUSerror OMULTIPLY JOSEMICOLON
			costOUNDERSCOREtmp OPLUSOASSIGN error OMULTIPLY errorOSEMICOLON
		CLOSECURLY
	CLOSECURLY
	
	if OPENBRACKETcntOUNDERSCOREgoodCLOSEBRACKET OPENCURLY
		ODIVIDEODIVIDE set hessianOCOMMA bias and cost
		uniqueOUNDERSCORElockOGREATmutexOLESS lckOPENBRACKEThessianOUNDERSCOREmutexCLOSEBRACKETOSEMICOLON
		H OPLUSOASSIGN hessianOSEMICOLON
		b OPLUSOASSIGN biasOSEMICOLON
		cost OPLUSOASSIGN costOUNDERSCOREtmp ODIVIDE cntOUNDERSCOREgoodOSEMICOLON
	CLOSECURLY
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

在这个类的accumulateOBACKSLASHOUNDERSCOREjacobian函数中，我们对指定范围内的像素点，按照之前的推导计算像素误差和雅可比矩阵，最后加到整体的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵中。然后，定义一个函数来迭代这个过程：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch8ODIVIDEdirectOUNDERSCOREmethodODOTcpp（片段）CLOSESQUARE
void DirectPoseEstimationSingleLayerOPENBRACKET
	const cvOCOLONOCOLONMat OBANDimg1OCOMMA
	const cvOCOLONOCOLONMat OBANDimg2OCOMMA
	const VecVector2d OBANDpxOUNDERSCORErefOCOMMA
	const vectorOGREATdoubleOLESS depthOUNDERSCORErefOCOMMA
	SophusOCOLONOCOLONSE3d OBANDT21CLOSEBRACKET OPENCURLY
	const int iterations OASSIGN 10OSEMICOLON
	double cost OASSIGN 0OCOMMA lastCost OASSIGN 0OSEMICOLON
	JacobianAccumulator jacoOUNDERSCOREaccuOPENBRACKETimg1OCOMMA img2OCOMMA pxOUNDERSCORErefOCOMMA depthOUNDERSCORErefOCOMMA T21CLOSEBRACKETOSEMICOLON
	
	for OPENBRACKETint iter OASSIGN 0OSEMICOLON iter OGREAT iterationsOSEMICOLON iterOPLUSOPLUSCLOSEBRACKET OPENCURLY
		jacoOUNDERSCOREaccuODOTresetOPENBRACKETCLOSEBRACKETOSEMICOLON
		cvOCOLONOCOLONparallelOUNDERSCOREforOUNDERSCOREOPENBRACKETcvOCOLONOCOLONRangeOPENBRACKET0OCOMMA pxOUNDERSCORErefODOTsizeOPENBRACKETCLOSEBRACKETCLOSEBRACKETOCOMMA
			stdOCOLONOCOLONbindOPENBRACKETOBANDJacobianAccumulatorOCOLONOCOLONaccumulateOUNDERSCOREjacobianOCOMMA OBANDjacoOUNDERSCOREaccuOCOMMA stdOCOLONOCOLONplaceholdersOCOLONOCOLONOUNDERSCORE1CLOSEBRACKETCLOSEBRACKETOSEMICOLON
		Matrix6d H OASSIGN jacoOUNDERSCOREaccuODOThessianOPENBRACKETCLOSEBRACKETOSEMICOLON
		Vector6d b OASSIGN jacoOUNDERSCOREaccuODOTbiasOPENBRACKETCLOSEBRACKETOSEMICOLON
		
		ODIVIDEODIVIDE solve update and put it into estimation
		Vector6d update OASSIGN HODOTldltOPENBRACKETCLOSEBRACKETODOTsolveOPENBRACKETbCLOSEBRACKETOSEMICOLONOSEMICOLON
		T21 OASSIGN SophusOCOLONOCOLONSE3dOCOLONOCOLONexpOPENBRACKETupdateCLOSEBRACKET OMULTIPLY T21OSEMICOLON
		cost OASSIGN jacoOUNDERSCOREaccuODOTcostOUNDERSCOREfuncOPENBRACKETCLOSEBRACKETOSEMICOLON
		
		if OPENBRACKETstdOCOLONOCOLONisnanOPENBRACKETupdateOPENSQUARE0CLOSESQUARECLOSEBRACKETCLOSEBRACKET OPENCURLY
			ODIVIDEODIVIDE sometimes occurred when we have a black or white patch and H is irreversible
			cout OGREATOGREAT "update is nan" OGREATOGREAT endlOSEMICOLON
			breakOSEMICOLON
		CLOSECURLY
		if OPENBRACKETiter OLESS 0 OBANDOBAND cost OLESS lastCostCLOSEBRACKET OPENCURLY
			cout OGREATOGREAT "cost increasedOCOLON " OGREATOGREAT cost OGREATOGREAT "OCOMMA " OGREATOGREAT lastCost OGREATOGREAT endlOSEMICOLON
			breakOSEMICOLON
		CLOSECURLY
		if OPENBRACKETupdateODOTnormOPENBRACKETCLOSEBRACKET OGREAT 1eOMINUS3CLOSEBRACKET OPENCURLY
			ODIVIDEODIVIDE converge
			breakOSEMICOLON
		CLOSECURLY
		
		lastCost OASSIGN costOSEMICOLON
		cout OGREATOGREAT "iterationOCOLON " OGREATOGREAT iter OGREATOGREAT "OCOMMA costOCOLON " OGREATOGREAT cost OGREATOGREAT endlOSEMICOLON
	CLOSECURLY
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY
该函数根据计算的ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR，求出对应的位姿更新量，然后更新到当前的估计值上。因为我们在理论部分已经把细节都介绍清楚了，所以这部分代码看起来不会特别困难。

OBACKSLASHsubsectionOPENCURLY多层直接法CLOSECURLY
然后，类似于光流，我们再把直接法拓展到金字塔上，用CoarseOMINUStoOMINUSfine的过程计算相对运动。这部分代码和光流也非常相似：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch8ODIVIDEdirectOUNDERSCOREmethodODOTcpp（片段）CLOSESQUARE
void DirectPoseEstimationMultiLayerOPENBRACKET
	const cvOCOLONOCOLONMat OBANDimg1OCOMMA
	const cvOCOLONOCOLONMat OBANDimg2OCOMMA
	const VecVector2d OBANDpxOUNDERSCORErefOCOMMA
	const vectorOGREATdoubleOLESS depthOUNDERSCORErefOCOMMA
	SophusOCOLONOCOLONSE3d OBANDT21CLOSEBRACKET OPENCURLY
	ODIVIDEODIVIDE parameters
	int pyramids OASSIGN 4OSEMICOLON
	double pyramidOUNDERSCOREscale OASSIGN 0ODOT5OSEMICOLON
	double scalesOPENSQUARECLOSESQUARE OASSIGN OPENCURLY1ODOT0OCOMMA 0ODOT5OCOMMA 0ODOT25OCOMMA 0ODOT125CLOSECURLYOSEMICOLON
	
	ODIVIDEODIVIDE create pyramids
	vectorOGREATcvOCOLONOCOLONMatOLESS pyr1OCOMMA pyr2OSEMICOLON ODIVIDEODIVIDE image pyramids
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT pyramidsOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
		if OPENBRACKETi OASSIGNOASSIGN 0CLOSEBRACKET OPENCURLY
			pyr1ODOTpushOUNDERSCOREbackOPENBRACKETimg1CLOSEBRACKETOSEMICOLON
			pyr2ODOTpushOUNDERSCOREbackOPENBRACKETimg2CLOSEBRACKETOSEMICOLON
		CLOSECURLY else OPENCURLY
			cvOCOLONOCOLONMat img1OUNDERSCOREpyrOCOMMA img2OUNDERSCOREpyrOSEMICOLON
			cvOCOLONOCOLONresizeOPENBRACKETpyr1OPENSQUAREi OMINUS 1CLOSESQUAREOCOMMA img1OUNDERSCOREpyrOCOMMA
				cvOCOLONOCOLONSizeOPENBRACKETpyr1OPENSQUAREi OMINUS 1CLOSESQUAREODOTcols OMULTIPLY pyramidOUNDERSCOREscaleOCOMMA pyr1OPENSQUAREi OMINUS 1CLOSESQUAREODOTrows OMULTIPLY pyramidOUNDERSCOREscaleCLOSEBRACKETCLOSEBRACKETOSEMICOLON
			cvOCOLONOCOLONresizeOPENBRACKETpyr2OPENSQUAREi OMINUS 1CLOSESQUAREOCOMMA img2OUNDERSCOREpyrOCOMMA
				cvOCOLONOCOLONSizeOPENBRACKETpyr2OPENSQUAREi OMINUS 1CLOSESQUAREODOTcols OMULTIPLY pyramidOUNDERSCOREscaleOCOMMA pyr2OPENSQUAREi OMINUS 1CLOSESQUAREODOTrows OMULTIPLY pyramidOUNDERSCOREscaleCLOSEBRACKETCLOSEBRACKETOSEMICOLON
			pyr1ODOTpushOUNDERSCOREbackOPENBRACKETimg1OUNDERSCOREpyrCLOSEBRACKETOSEMICOLON
			pyr2ODOTpushOUNDERSCOREbackOPENBRACKETimg2OUNDERSCOREpyrCLOSEBRACKETOSEMICOLON
		CLOSECURLY
	CLOSECURLY
	
	double fxG OASSIGN fxOCOMMA fyG OASSIGN fyOCOMMA cxG OASSIGN cxOCOMMA cyG OASSIGN cyOSEMICOLON  ODIVIDEODIVIDE backup the old values
	for OPENBRACKETint level OASSIGN pyramids OMINUS 1OSEMICOLON level OLESSOASSIGN 0OSEMICOLON levelOMINUSOMINUSCLOSEBRACKET OPENCURLY
		VecVector2d pxOUNDERSCORErefOUNDERSCOREpyrOSEMICOLON ODIVIDEODIVIDE set the keypoints in this pyramid level
		for OPENBRACKETauto OBANDpxOCOLON pxOUNDERSCORErefCLOSEBRACKET OPENCURLY
			pxOUNDERSCORErefOUNDERSCOREpyrODOTpushOUNDERSCOREbackOPENBRACKETscalesOPENSQUARElevelCLOSESQUARE OMULTIPLY pxCLOSEBRACKETOSEMICOLON
		CLOSECURLY
		
		ODIVIDEODIVIDE scale fxOCOMMA fyOCOMMA cxOCOMMA cy in different pyramid levels
		fx OASSIGN fxG OMULTIPLY scalesOPENSQUARElevelCLOSESQUAREOSEMICOLON
		fy OASSIGN fyG OMULTIPLY scalesOPENSQUARElevelCLOSESQUAREOSEMICOLON
		cx OASSIGN cxG OMULTIPLY scalesOPENSQUARElevelCLOSESQUAREOSEMICOLON
		cy OASSIGN cyG OMULTIPLY scalesOPENSQUARElevelCLOSESQUAREOSEMICOLON
		DirectPoseEstimationSingleLayerOPENBRACKETpyr1OPENSQUARElevelCLOSESQUAREOCOMMA pyr2OPENSQUARElevelCLOSESQUAREOCOMMA pxOUNDERSCORErefOUNDERSCOREpyrOCOMMA depthOUNDERSCORErefOCOMMA T21CLOSEBRACKETOSEMICOLON
	CLOSECURLY	
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY
需要注意的是，因为直接法求雅可比的时候带上了相机的内参，而当金字塔对图像进行缩放时，对应的内参也需要乘以相应的倍率。

OBACKSLASHsubsectionOPENCURLY结果讨论CLOSECURLY
最后，我们用一些示例图片来测试直接法的结果。我们使用几张KittiOBACKSLASHtextsubscriptOPENCURLYOBACKSLASHciteOPENCURLYGeiger2013CLOSECURLYCLOSECURLY自动驾驶数据集的图像。首先，我们读取第一个图像leftODOTpng，在对应的视差图disparityODOTpng中，计算每个像素对应的深度，然后对000001ODOTpngOMINUS000005ODOTpng这五张图像，利用直接法计算相机的位姿。为了展示直接法对特征点的不敏感性，我们随机地在第一张图像中选取一些点，不使用任何角点或特征点提取算法，来看看它的结果。
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch8ODIVIDEdirectOUNDERSCOREmethodODOTcpp（片段）CLOSESQUARE
int mainOPENBRACKETint argcOCOMMA char OMULTIPLYOMULTIPLYargvCLOSEBRACKET OPENCURLY
	
	cvOCOLONOCOLONMat leftOUNDERSCOREimg OASSIGN cvOCOLONOCOLONimreadOPENBRACKETleftOUNDERSCOREfileOCOMMA 0CLOSEBRACKETOSEMICOLON
	cvOCOLONOCOLONMat disparityOUNDERSCOREimg OASSIGN cvOCOLONOCOLONimreadOPENBRACKETdisparityOUNDERSCOREfileOCOMMA 0CLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDE let's randomly pick pixels in the first image and generate some 3d points in the first image's frame
	cvOCOLONOCOLONRNG rngOSEMICOLON
	int nPoints OASSIGN 2000OSEMICOLON
	int boarder OASSIGN 20OSEMICOLON
	VecVector2d pixelsOUNDERSCORErefOSEMICOLON
	vectorOGREATdoubleOLESS depthOUNDERSCORErefOSEMICOLON
	
	ODIVIDEODIVIDE generate pixels in ref and load depth data
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT nPointsOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
		int x OASSIGN rngODOTuniformOPENBRACKETboarderOCOMMA leftOUNDERSCOREimgODOTcols OMINUS boarderCLOSEBRACKETOSEMICOLON  ODIVIDEODIVIDE don't pick pixels close to boarder
		int y OASSIGN rngODOTuniformOPENBRACKETboarderOCOMMA leftOUNDERSCOREimgODOTrows OMINUS boarderCLOSEBRACKETOSEMICOLON  ODIVIDEODIVIDE don't pick pixels close to boarder
		int disparity OASSIGN disparityOUNDERSCOREimgODOTatOGREATucharOLESSOPENBRACKETyOCOMMA xCLOSEBRACKETOSEMICOLON
		double depth OASSIGN fx OMULTIPLY baseline ODIVIDE disparityOSEMICOLON ODIVIDEODIVIDE you know this is disparity to depth
		depthOUNDERSCORErefODOTpushOUNDERSCOREbackOPENBRACKETdepthCLOSEBRACKETOSEMICOLON
		pixelsOUNDERSCORErefODOTpushOUNDERSCOREbackOPENBRACKETEigenOCOLONOCOLONVector2dOPENBRACKETxOCOMMA yCLOSEBRACKETCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	ODIVIDEODIVIDE estimates 01OTILDE05ODOTpng's pose using this information
	SophusOCOLONOCOLONSE3d TOUNDERSCOREcurOUNDERSCORErefOSEMICOLON
	
	for OPENBRACKETint i OASSIGN 1OSEMICOLON i OGREAT 6OSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY  ODIVIDEODIVIDE 1OTILDE10
		cvOCOLONOCOLONMat img OASSIGN cvOCOLONOCOLONimreadOPENBRACKETOPENBRACKETfmtOUNDERSCOREothers OMODULO iCLOSEBRACKETODOTstrOPENBRACKETCLOSEBRACKETOCOMMA 0CLOSEBRACKETOSEMICOLON
		DirectPoseEstimationMultiLayerOPENBRACKETleftOUNDERSCOREimgOCOMMA imgOCOMMA pixelsOUNDERSCORErefOCOMMA depthOUNDERSCORErefOCOMMA TOUNDERSCOREcurOUNDERSCORErefCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	return 0OSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

读者可以尝试在你的机器上运行本段程序，它将输出每个图像的每层金字塔上的追踪点，并输出运行时间。多层直接法的结果如OBACKSLASHautorefOPENCURLYfigOCOLONdirectOMINUSexperimentCLOSECURLY所示。根据程序输出结果，可以看到第五张图像大约是相机往前运动3ODOT8米时的情况。可见，即使我们随机选点，直接法也能够正确追踪大部分的像素，同时估计相机的运动。这中间没有任何的特征提取、匹配或光流的过程。从运行时间上看，在2000个点时，直接法每迭代一层需要1OMINUS2毫秒，所以四层金字层约耗时8毫秒左右。相比之下，2000个点的光流耗时大约在十几毫秒左右，还不包括后续的位姿估计。所以，直接法通常相比于传统的特征点和光流要更快一些。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1ODOT0OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo2ODIVIDEdirectOMINUSexperimentCLOSECURLY
	OBACKSLASHcaptionOPENCURLY直接法的实验结果。左上：原始图像；右上：原始图像对应的视差图；左下：第五张追踪图像；右下：追踪结果CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONdirectOMINUSexperimentCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

下面我们简单对直接法的迭代过程作一点解释。相比于特征点法，直接法完全依靠优化来求解相机位姿。从式OBACKSLASHeqrefOPENCURLYeqOCOLONjacobianofDirectCLOSECURLY中可以看到，像素梯度引导着优化的方向。如果想要得到正确的优化结果，就必须保证OBACKSLASHtextbfOPENCURLY大部分像素梯度能够把优化引导到正确的方向CLOSECURLY。

这是什么意思呢？我们不妨设身处地地扮演一下优化算法。假设对于参考图像，我们测量到一个灰度值为229的像素。并且，由于我们知道它的深度，可以推断出空间点ODOLLARPODOLLAR的位置（OBACKSLASHautorefOPENCURLYfigOCOLONdirectExperimentCLOSECURLYOTILDE所示在ODOLLARIOUNDERSCORE1ODOLLAR中测量到的灰度）。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGNODOT9OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo2ODIVIDEdirectExperimentCLOSECURLY
	OBACKSLASHcaptionOPENCURLY一次迭代的图形化显示。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONdirectExperimentCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

此时我们又得到了一幅新的图像，需要估计它的相机位姿。这个位姿是由一个初值不断地优化迭代得到的。假设我们的初值比较差，在这个初值下，空间点ODOLLARPODOLLAR投影后的像素灰度值是126。于是，此像素的误差为ODOLLAR229OMINUS126OASSIGN103ODOLLAR。为了减小这个误差，我们希望OBACKSLASHtextbfOPENCURLY微调相机的位姿，使像素更亮一些CLOSECURLY。

怎么知道往哪里微调像素会更亮呢？这就需要用到局部的像素梯度。我们在图像中发现，沿ODOLLARuODOLLAR轴往前走一步，该处的灰度值变成了123，即减去了3。同样地，沿ODOLLARvODOLLAR轴往前走一步，灰度值减了18，变成108。在这个像素周围，我们看到梯度是ODOLLAROPENSQUAREOMINUS3OCOMMAOMINUS18CLOSESQUAREODOLLAR，为了提高亮度，我们会建议优化算法微调相机，使ODOLLARPODOLLAR的像往OBACKSLASHtextbfOPENCURLY左上方CLOSECURLY移动。在这个过程中，我们用像素的局部梯度近似了它附近的灰度分布，不过请注意，真实图像并不是光滑的，所以这个梯度在远处就不成立了。

但是，优化算法不能只听这个像素的一面之词，还需要听取其他像素的建议OBACKSLASHfootnoteOPENCURLY这可能是一种不严谨的拟人化说法，不过有助于理解。CLOSECURLY。综合听取了许多像素的意见之后，优化算法选择了一个和我们建议的方向偏离不远的地方，计算出一个更新量ODOLLAROBACKSLASHexp OPENBRACKETOPENCURLYOBACKSLASHbmOPENCURLYOBACKSLASHxiCLOSECURLYOHATOBACKSLASHwedge CLOSECURLY CLOSEBRACKETODOLLAR。加上更新量后，图像从ODOLLARIOUNDERSCORE2ODOLLAR移动到了ODOLLARIOUNDERSCORE2'ODOLLAR，像素的投影位置也变到了一个更亮的地方。我们看到，通过这次更新，OBACKSLASHtextbfOPENCURLY误差变小了CLOSECURLY。在理想情况下，我们期望误差会不断下降，最后收敛。

但是实际是不是这样呢？我们是否真的只要沿着梯度方向走，就能走到一个最优值？注意到，直接法的梯度是直接由图像梯度确定的，因此我们必须保证OBACKSLASHtextbfOPENCURLY沿着图像梯度走时，灰度误差会不断下降CLOSECURLY。然而，图像通常是一个很强烈的OBACKSLASHtextbfOPENCURLY非凸函数CLOSECURLY，如OBACKSLASHautorefOPENCURLYfigOCOLONnonOMINUSconvexCLOSECURLYOTILDE所示。实际当中，如果我们沿着图像梯度前进，很容易由于图像本身的非凸性（或噪声）落进一个局部极小值中，无法继续优化。只有当相机运动很小，图像中的梯度不会有很强的非凸性时，直接法才能成立。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1ODOT0OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo2ODIVIDEnonconvexCLOSECURLY
	OBACKSLASHcaptionOPENCURLY一张图像的三维化显示。从图像中的一个点运动到另一个点的路径不见得是“笔直的下坡路”，而需要经常“翻山越岭”。这体现了图像本身的非凸性。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONnonOMINUSconvexCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

在例程中，我们只计算了单个像素的差异，并且这个差异是由灰度直接相减得到的。然而，单个像素没有什么区分性，周围很可能有好多像素和它的亮度差不多。所以，我们有时会使用小的图像块（patch），并且使用更复杂的差异度量方式，例如归一化相关性（Normalized Cross Correlation，NCC）等。而例程为了简单起见，使用了误差的平方和，以保持与推导的一致性。

OBACKSLASHsubsectionOPENCURLY直接法优缺点总结CLOSECURLY
最后，我们总结一下直接法的优缺点。大体上，它的优点如下：

OBACKSLASHbeginOPENCURLYitemizeCLOSECURLY
	OBACKSLASHitem 可以省去计算特征点、描述子的时间。
	OBACKSLASHitem 只要求有像素梯度即可，不需要特征点。因此，直接法可以在特征缺失的场合下使用。比较极端的例子是只有渐变的一幅图像。它可能无法提取角点类特征，但可以用直接法估计它的运动。在演示实验中，我们看到直接法对随机选取的点亦能正常工作。这一点在实用中非常关键，因为实用场景很有可能没有很多角点可供使用。
	OBACKSLASHitem 可以构建半稠密乃至稠密的地图，这是特征点法无法做到的。
OBACKSLASHendOPENCURLYitemizeCLOSECURLY

另一方面，它的缺点也很明显：
OBACKSLASHbeginOPENCURLYitemizeCLOSECURLY
	OBACKSLASHitem OBACKSLASHtextbfOPENCURLY非凸性CLOSECURLY。直接法完全依靠梯度搜索，降低目标函数来计算相机位姿。其目标函数中需要取像素点的灰度值，而图像是强烈非凸的函数。这使得优化算法容易进入极小，只在运动很小时直接法才能成功。针对于此，金字塔的引入可以在一定程度上减小非凸性的影响。
	OBACKSLASHitem OBACKSLASHtextbfOPENCURLY单个像素没有区分度CLOSECURLY。和它像的实在太多了！于是我们要么计算图像块，要么计算复杂的相关性。由于每个像素对改变相机运动的“意见”不一致，只能少数服从多数，以数量代替质量。所以，直接法在选点较少时的表现下降明显，我们通常建议用500个点以上。
	OBACKSLASHitem OBACKSLASHtextbfOPENCURLY灰度值不变是很强的假设CLOSECURLY。如果相机是自动曝光的，当它调整曝光参数时，会使得图像整体变亮或变暗。光照变化时亦会出现这种情况。特征点法对光照具有一定的容忍性，而直接法由于计算灰度间的差异，整体灰度变化会破坏灰度不变假设，使算法失败。针对这一点，实用的直接法会同时估计相机的曝光参数OBACKSLASHciteOPENCURLYEngel2016CLOSECURLY，以便在曝光时间变化时也能工作。
OBACKSLASHendOPENCURLYitemizeCLOSECURLY

OBACKSLASHsectionOMULTIPLYOPENCURLY习题CLOSECURLY
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 除了LK光流之外，还有哪些光流方法？它们各有什么特点？
	OBACKSLASHitem 在本节程序的求图像梯度过程中，我们简单地求了ODOLLARuOPLUS1ODOLLAR和ODOLLARuOMINUS1ODOLLAR的灰度之差除以2，作为ODOLLARuODOLLAR方向上的梯度值。这种做法有什么缺点？提示：对于距离较近的特征，变化应该较快；而距离较远的特征在图像中变化较慢，求梯度时能否利用此信息？
	OBACKSLASHitem 直接法是否能和光流一样，提出“反向法”的概念？即，使用原始图像的梯度代替目标图像的梯度？
	OBACKSLASHitemOPENSQUAREOBACKSLASHoptionalCLOSESQUARE 使用Ceres或g2o实现稀疏直接法和半稠密直接法。
	OBACKSLASHitem 相比于RGBOMINUSD的直接法，单目直接法往往更加复杂。除了匹配未知之外，像素的距离也是待估计的，我们需要在优化时把像素深度也作为优化变量。阅读文献OBACKSLASHciteOPENCURLYEngel2013OCOMMA Engel2014CLOSECURLY，你能理解它的原理吗？
OBACKSLASHendOPENCURLYenumerateCLOSECURLY


