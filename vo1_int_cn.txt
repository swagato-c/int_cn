OMODULO ONOTModeOCOLONOCOLON "TeXOCOLONUTFOMINUS8"
OBACKSLASHchapterOPENCURLY视觉里程计1CLOSECURLY
OBACKSLASHlabelOPENCURLYcptOCOLON7CLOSECURLY
OBACKSLASHthispagestyleOPENCURLYemptyCLOSECURLY

OBACKSLASHbeginOPENCURLYmdframedCLOSECURLY  
	OBACKSLASHtextbfOPENCURLY主要目标CLOSECURLY
	OBACKSLASHbeginOPENCURLYenumerateCLOSECURLYOPENSQUARElabelindentOASSIGN0emOCOMMAleftmarginOASSIGN1ODOT5emCLOSESQUARE
		OBACKSLASHitem 理解图像特征点的意义OCOMMA 并掌握在单幅图像中提取出特征点及多幅图像中匹配特征点的方法。
		OBACKSLASHitem 理解对极几何的原理，利用对极几何的约束，恢复出图像之间的摄像机的三维运动。
		OBACKSLASHitem 理解PNP问题，以及利用已知三维结构与图像的对应关系求解摄像机的三维运动。
		OBACKSLASHitem 理解ICP问题，以及利用点云的匹配关系求解摄像机的三维运动。
		OBACKSLASHitem 理解如何通过三角化获得二维图像上对应点的三维结构。
	OBACKSLASHendOPENCURLYenumerateCLOSECURLY
OBACKSLASHendOPENCURLYmdframedCLOSECURLY

本书前面介绍了运动方程和观测方程的具体形式，并讲解了以非线性优化为主的求解方法。从本讲开始，我们结束基础知识的铺垫而步入正题：按照第2讲的顺序，分别介绍视觉里程计、优化后端、回环检测和地图构建4个模块。本讲和下一讲主要介绍两类视觉里程计里常用的方法：特征点法和光流法。本讲中，我们将介绍什么是特征点、如何提取和匹配特征点，以及如何根据配对的特征点估计相机运动。

OBACKSLASHnewpage
OBACKSLASHincludepdfOPENCURLYresourcesODIVIDEotherODIVIDEch7ODOTpdfCLOSECURLY

OBACKSLASHnewpage

OBACKSLASHsectionOPENCURLY特征点法CLOSECURLY
在第二讲中，我们说，一个SLAM系统分为前端和后端，其中前端也称为视觉里程计（VO）。VO根据相邻图像的信息估计出粗略的相机运动，给后端提供较好的初始值。VO的算法主要分为两个大类：OBACKSLASHtextbfOPENCURLY特征点法CLOSECURLY和OBACKSLASHtextbfOPENCURLY直接法CLOSECURLY。基于特征点法的前端，长久以来（直到现在）被认为是视觉里程计的主流方法。它具有稳定，对光照、动态物体不敏感的优势，是目前比较成熟的解决方案。在本讲中，我们将从特征点法入手，学习如何提取、匹配图像特征点，然后估计两帧之间的相机运动和场景结构，从而实现一个两帧间视觉里程计。这类算法有时也称为两视图几何（TwoOMINUSview geometry）。

OBACKSLASHsubsectionOPENCURLY特征点CLOSECURLY
VO的核心问题是OBACKSLASHtextbfOPENCURLY如何根据图像来估计相机运动CLOSECURLY。然而，图像本身是一个由亮度和色彩组成的矩阵，如果直接从矩阵层面考虑运动估计，将会非常困难。所以，比较方便的做法是：首先，从图像中选取比较OBACKSLASHtextbfOPENCURLY有代表性CLOSECURLY的OBACKSLASHtextbfOPENCURLY点CLOSECURLY。这些点在相机视角发生少量变化后会保持不变，于是我们能在各个图像中找到相同的点。然后，在这些点的基础上，讨论相机位姿估计问题，以及这些点的定位问题。在经典SLAM模型中，我们称这些点为OBACKSLASHtextbfOPENCURLY路标CLOSECURLY（Landmark）。而在视觉SLAM中，路标则是指图像特征（Feature）。

根据维基百科的定义，图像特征是一组与计算任务相关的信息，计算任务取决于具体的应用OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYwikiOCOLONfeaturecvCLOSECURLYCLOSECURLY。简而言之，OBACKSLASHtextbfOPENCURLY特征是图像信息的另一种数字表达形式CLOSECURLY。一组好的特征对于在指定任务上的最终表现至关重要，所以多年来研究者们花费了大量的精力对特征进行研究。数字图像在计算机中以灰度值矩阵的方式存储，所以最简单的，单个图像像素也是一种“特征”。但是，在视觉里程计中，我们希望OBACKSLASHtextbfOPENCURLY特征点在相机运动之后保持稳定CLOSECURLY，而灰度值受光照、形变、物体材质的影响严重，在不同图像间变化非常大，不够稳定。理想的情况是，当场景和相机视角发生少量改变时，算法还能从图像中判断哪些地方是同一个点。所以，仅凭灰度值是不够的，我们需要对图像提取特征点。

特征点是图像里一些OBACKSLASHtextbfOPENCURLY特别的地方CLOSECURLY。以OBACKSLASHautorefOPENCURLYfigOCOLONcornerOMINUSfeatureCLOSECURLYOTILDE为例。我们可以把图像中的角点、边缘和区块都当成图像中有代表性的地方。不过，我们更容易精确地指出，某两幅图像中出现了同一个角点；同一个边缘则稍微困难一些，因为沿着该边缘前进，图像局部是相似的；同一个区块则是最困难的。我们发现，图像中的角点、边缘相比于像素区块而言更加“特别”，在不同图像之间的辨识度更强。所以，一种直观的提取特征的方式就是在不同图像间辨认角点，确定它们的对应关系。在这种做法中，角点就是所谓的特征。角点的提取算法有很多，例如Harris角点OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYHarris1988CLOSECURLYCLOSECURLY、FAST角点OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYRosten2006CLOSECURLYCLOSECURLY、GFTT角点OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYShi1994CLOSECURLYCLOSECURLY，等等。它们大部分是2000年以前提出的算法。

然而，在大多数应用中，单纯的角点依然不能满足我们的很多需求。例如，从远处看上去是角点的地方，当相机走近之后，可能就不显示为角点了。或者，当旋转相机时，角点的外观会发生变化，我们也就不容易辨认出那是同一个角点。为此，计算机视觉领域的研究者们在长年的研究中设计了许多更加稳定的局部图像特征，如著名的SIFTOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYLowe2004CLOSECURLYCLOSECURLY、SURFOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYBay2006CLOSECURLYCLOSECURLY、ORBOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYRublee2011CLOSECURLYCLOSECURLY，等等。相比于朴素的角点，这些人工设计的特征点能够拥有如下的性质：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
OBACKSLASHitem OBACKSLASHemphOPENCURLY可重复性CLOSECURLY（Repeatability）：相同的特征可以在不同的图像中找到。
OBACKSLASHitem OBACKSLASHemphOPENCURLY可区别性CLOSECURLY（Distinctiveness）：不同的特征有不同的表达。
OBACKSLASHitem OBACKSLASHemphOPENCURLY高效率CLOSECURLY（Efficiency）：同一图像中，特征点的数量应远小于像素的数量。
OBACKSLASHitem OBACKSLASHemphOPENCURLY本地性CLOSECURLY（Locality）：特征仅与一小片图像区域相关。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtCLOSESQUARE
    OBACKSLASHcentering
    OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT8OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEcornerOMINUSflatOMINUSlineCLOSECURLYOBACKSLASHOBACKSLASH
    OBACKSLASHcaptionOPENCURLY可以作为图像特征的部分：角点、边缘、区块。CLOSECURLY
    OBACKSLASHlabelOPENCURLYfigOCOLONcornerOMINUSfeatureCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

特征点由OBACKSLASHtextbfOPENCURLY关键点CLOSECURLY（KeyOMINUSpoint）和OBACKSLASHtextbfOPENCURLY描述子CLOSECURLY（Descriptor）两部分组成。比如，当我们说“在一张图像中计算SIFT特征点”，是指“提取SIFT关键点，并计算SIFT描述子”两件事情。关键点是指该特征点在图像里的位置，有些特征点还具有朝向、大小等信息。描述子通常是一个向量，按照某种人为设计的方式，描述了该关键点周围像素的信息。描述子是按照“OBACKSLASHtextbfOPENCURLY外观相似的特征应该有相似的描述子CLOSECURLY”的原则设计的。因此，只要两个特征点的描述子在向量空间上的距离相近，就可以认为它们是同样的特征点。

历史上，研究者们提出过许多图像特征。它们有些很精确，在相机的运动和光照变化下仍具有相似的表达，但相应地需要较大的计算量。其中，SIFT（尺度不变特征变换，ScaleOMINUSInvariant Feature Transform）当属最为经典的一种。它充分考虑了在图像变换过程中出现的光照、尺度、旋转等变化，但随之而来的是极大的计算量。由于整个SLAM过程中图像特征的提取与匹配仅仅是诸多环节中的一个，到目前（2016年）为止，普通PC的CPU还无法实时地计算SIFT特征，进行定位与建图OBACKSLASHfootnoteOPENCURLY这里是指30Hz的实时速度。CLOSECURLY。所以在SLAM中我们甚少使用这种“奢侈”的图像特征。

另一些特征，则考虑适当降低精度和鲁棒性，以提升计算的速度。例如，FAST关键点属于计算特别快的一种特征点（注意这里“关键点”的表述，说明它没有描述子），而ORB（Oriented FAST and Rotated BRIEF）特征则是目前看来非常具有代表性的实时图像特征。它改进了FAST检测子OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYRosten2006CLOSECURLYCLOSECURLY不具有方向性的问题，并采用速度极快的二进制描述子BRIEFOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYcalonder2010briefCLOSECURLYCLOSECURLY，使整个图像特征提取的环节大大加速。根据作者在论文中所述测试，在同一幅图像中同时提取约1000个特征点的情况下，ORB约要花费15ODOT3ms，SURF约花费217ODOT3ms，SIFT约花费5228ODOT7ms。由此可以看出，ORB在保持了特征子具有旋转、尺度不变性的同时，速度方面提升明显，对于实时性要求很高的SLAM来说是一个很好的选择。

大部分特征提取都具有较好的并行性，可以通过GPU等设备来加速计算。经过GPU加速后的SIFT，就可以满足实时计算要求。但是，引入GPU将带来整个SLAM成本的提升。由此带来的性能提升是否足以抵去付出的计算成本，需要系统的设计人员仔细考量。

显然，计算机视觉领域存在大量的特征点种类，我们不可能在书中一一介绍。在目前的SLAM方案中，ORB是质量与性能之间较好的折中，因此，我们以ORB为代表介绍提取特征的整个过程。如果读者对特征提取和匹配算法感兴趣，我们建议阅读这方面的相关书籍OBACKSLASHciteOPENCURLYNixon2012CLOSECURLY。

OBACKSLASHsubsectionOPENCURLYORB特征CLOSECURLY

ORB特征亦由OBACKSLASHtextbfOPENCURLY关键点CLOSECURLY和OBACKSLASHtextbfOPENCURLY描述子CLOSECURLY两部分组成。它的关键点称为“Oriented FAST”，是一种改进的FAST角点，关于什么是FAST角点我们将在下文介绍。它的描述子称为BRIEF（Binary Robust Independent Elementary Feature）。因此，提取ORB特征分为如下两个步骤：
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
OBACKSLASHitem FAST角点提取：找出图像中的“角点”。相较于原版的FAST，ORB中计算了特征点的主方向，为后续的BRIEF描述子增加了旋转不变特性。
OBACKSLASHitem BRIEF描述子：对前一步提取出特征点的周围图像区域进行描述。ORB对BRIEF进行了一些改进，主要是指在BRIEF中使用了先前计算的方向信息。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

下面分别介绍FAST和BRIEF。
OBACKSLASHsubsubsectionOPENCURLYFAST关键点CLOSECURLY

FAST是一种角点，主要检测局部像素灰度变化明显的地方，以速度快著称。它的思想是：如果一个像素与邻域的像素差别较大（过亮或过暗），那么它更可能是角点。相比于其他角点检测算法，FAST只需比较像素亮度的大小，十分快捷。它的检测过程如下（见OBACKSLASHautorefOPENCURLYfigOCOLONfastcornerCLOSECURLYOTILDE）：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
OBACKSLASHitem 在图像中选取像素ODOLLARpODOLLAR，假设它的亮度为ODOLLARIOUNDERSCOREOPENCURLYpCLOSECURLYODOLLAR。
OBACKSLASHitem 设置一个阈值ODOLLARTODOLLAR（比如，ODOLLARIOUNDERSCOREOPENCURLYpCLOSECURLYODOLLAR的20OBACKSLASHOMODULO）。
OBACKSLASHitem 以像素ODOLLARpODOLLAR为中心，选取半径为3的圆上的16个像素点。
OBACKSLASHitem 假如选取的圆上有连续的ODOLLARNODOLLAR个点的亮度大于ODOLLARIOUNDERSCOREOPENCURLYpCLOSECURLYOPLUSTODOLLAR或小于ODOLLARIOUNDERSCOREOPENCURLYpCLOSECURLYOMINUSTODOLLAR，那么像素ODOLLARpODOLLAR可以被认为是特征点（ODOLLARNODOLLAR通常取12，即为FASTOMINUS12。其他常用的ODOLLARNODOLLAR取值为9和11，它们分别被称为FASTOMINUS9和FASTOMINUS11）。
OBACKSLASHitem 循环以上四步，对每一个像素执行相同的操作。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

在FASTOMINUS12算法中，为了更高效，可以添加一项预测试操作，以快速地排除绝大多数不是角点的像素。具体操作为，对于每个像素，直接检测邻域圆上的第1OCOMMA 5OCOMMA 9OCOMMA 13个像素的亮度。只有当这4个像素中有3个同时大于ODOLLARIOUNDERSCOREOPENCURLYpCLOSECURLYOPLUSTODOLLAR或小于ODOLLARIOUNDERSCOREOPENCURLYpCLOSECURLYOMINUSTODOLLAR时，当前像素才有可能是一个角点，否则应该直接排除。这样的预测试操作大大加速了角点检测。此外，原始的FAST角点经常出现“扎堆”的现象。所以在第一遍检测之后，还需要用非极大值抑制（NonOMINUSmaximal suppression），在一定区域内仅保留响应极大值的角点，避免角点集中的问题。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT9OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEfastOMINUScornerCLOSECURLY
	OBACKSLASHcaptionOPENCURLYFAST特征点OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYRosten2006CLOSECURLYCLOSECURLY。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONfastcornerCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

FAST特征点的计算仅仅是比较像素间亮度的差异所所以速度非常快，但它也有重复性不强，分布不均匀的缺点。此外，FAST角点不具有方向信息。同时，由于它固定取半径为3的圆，存在尺度问题：远处看着像是角点的地方，接近后看可能就不是角点了。针对FAST角点不具有方向性和尺度的弱点，ORB添加了尺度和旋转的描述。尺度不变性由构建图像金字塔OBACKSLASHfootnoteOPENCURLY金字塔是指对图像进行不同层次的降采样，以获得不同分辨率的图像。CLOSECURLY，并在金字塔的每一层上检测角点来实现。而特征的旋转是由灰度质心法（Intensity Centroid）实现的。

金字塔时计算图视觉中常用的一种处理方法，示意图见OBACKSLASHautorefOPENCURLYfigOCOLONpyramidCLOSECURLY。金字塔底层是原始图像。每往上一层，就对图像进行一个固定倍率的缩放，这样我们就有了不同分辨率的图像。较小的图像可以看成是远处看过来的场景。在特征匹配算法中，我们可以匹配不同层上的图像，从而实现尺度不变性。例如，如果相机在后退，那么我们应该能够在上一个图像金字塔的上层和下一个图像的下层中找到匹配。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOTtCLOSESQUARE
    OBACKSLASHcentering
    OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT9OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEpyramidCLOSECURLYOBACKSLASHOBACKSLASH
    OBACKSLASHcaptionOPENCURLY使用金字塔可以匹配不同缩放倍率下的图像。CLOSECURLY
    OBACKSLASHlabelOPENCURLYfigOCOLONpyramidCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

在旋转方面，我们计算特征点附近的图像灰度质心。所谓质心是指以图像块灰度值作为权重的中心。其具体操作步骤如下OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYRosin1999CLOSECURLYCLOSECURLY：
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
OBACKSLASHitem 在一个小的图像块ODOLLARBODOLLAR中，定义图像块的矩为
OBACKSLASHOPENSQUARE
mOUNDERSCOREOPENCURLYpqCLOSECURLYOASSIGNOBACKSLASHsumOUNDERSCOREOPENCURLYxOCOMMAy OBACKSLASHin BCLOSECURLYxOHATOPENCURLYpCLOSECURLYyOHATOPENCURLYqCLOSECURLYIOPENBRACKETxOCOMMAyCLOSEBRACKETOCOMMA OBACKSLASHquad pOCOMMA q OASSIGN OBACKSLASHOPENCURLY0OCOMMA1OBACKSLASHCLOSECURLYODOT
OBACKSLASHCLOSESQUARE
OBACKSLASHitem 通过矩可以找到图像块的质心：
OBACKSLASHOPENSQUARE
COASSIGNOPENBRACKETOBACKSLASHfracOPENCURLYmOUNDERSCOREOPENCURLY10CLOSECURLYCLOSECURLYOPENCURLYmOUNDERSCOREOPENCURLY00CLOSECURLYCLOSECURLYOCOMMAOBACKSLASHfracOPENCURLYmOUNDERSCOREOPENCURLY01CLOSECURLYCLOSECURLYOPENCURLYmOUNDERSCOREOPENCURLY00CLOSECURLYCLOSECURLYCLOSEBRACKETODOT
OBACKSLASHCLOSESQUARE
OBACKSLASHitem 连接图像块的几何中心ODOLLAROODOLLAR与质心ODOLLARCODOLLAR，得到一个方向向量ODOLLAROBACKSLASHoverrightarrowOPENCURLYOCCLOSECURLYODOLLAR，于是特征点的方向可以定义为
OBACKSLASHOPENSQUARE
OBACKSLASHtheta OASSIGN OBACKSLASHarctanOPENBRACKETmOUNDERSCOREOPENCURLY01CLOSECURLYODIVIDEmOUNDERSCOREOPENCURLY10CLOSECURLYCLOSEBRACKETODOT
OBACKSLASHCLOSESQUARE
OBACKSLASHendOPENCURLYenumerateCLOSECURLY
通过以上方法，FAST角点便具有了尺度与旋转的描述，从而大大提升了其在不同图像之间表述的鲁棒性。所以在ORB中，把这种改进后的FAST称为Oriented FAST。

OBACKSLASHsubsubsectionOPENCURLYBRIEF描述子CLOSECURLY
在提取Oriented FAST关键点后，我们对每个点计算其描述子。ORB使用改进的BRIEF特征描述。我们先来介绍一下BRIEF是什么。

BRIEF是一种OBACKSLASHtextbfOPENCURLY二进制CLOSECURLY描述子，其描述向量由许多个0和1组成，这里的0和1编码了关键点附近两个随机像素（比如ODOLLARpODOLLAR和ODOLLARqODOLLAR）的大小关系：如果ODOLLARpODOLLAR比ODOLLARqODOLLAR大，则取1，反之就取0。如果我们取了128个这样的ODOLLARpOCOMMAqODOLLAR，最后就得到128维由0、1组成的向量OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYcalonder2010briefCLOSECURLYCLOSECURLY。BRIEF使用了随机选点的比较，速度非常快，而且由于使用了二进制表达，存储起来也十分方便，适用于实时的图像匹配。原始的BRIEF描述子不具有旋转不变性，因此在图像发生旋转时容易丢失。而ORB在FAST特征点提取阶段计算了关键点的方向，所以可以利用方向信息，计算了旋转之后的“Steer BRIEF”特征使ORB的描述子具有较好的旋转不变性。

由于考虑到了旋转和缩放，使得ORB在平移、旋转和缩放的变换下仍有良好的表现。同时，FAST和BREIF的组合也非常高效，使得ORB特征在实时SLAM中非常受欢迎。我们在OBACKSLASHautorefOPENCURLYfigOCOLONORBCLOSECURLYOTILDE中展示了一张图像提取ORB之后的结果，下面来介绍如何在不同的图像之间进行特征匹配。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
    OBACKSLASHcentering
    OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT9OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEfeatureCLOSECURLYOBACKSLASHOBACKSLASH
    OBACKSLASHcaptionOPENCURLYOpenCV提供的ORB特征点检测结果。CLOSECURLY
    OBACKSLASHlabelOPENCURLYfigOCOLONORBCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

OBACKSLASHsubsectionOPENCURLY特征匹配CLOSECURLY

特征匹配（如OBACKSLASHautorefOPENCURLYfigOCOLONfeatureOMINUSmatchingCLOSECURLYOTILDE所示）是视觉SLAM中极为关键的一步，宽泛地说，特征匹配解决了SLAM中的数据关联问题（data association），即确定当前看到的路标与之前看到的路标之间的对应关系。通过对图像与图像或者图像与地图之间的描述子进行准确匹配，我们可以为后续的姿态估计、优化等操作减轻大量负担。然而，由于图像特征的局部特性，误匹配的情况广泛存在，而且长期以来一直没有得到有效解决，目前已经成为视觉SLAM中制约性能提升的一大瓶颈。部分原因是场景中经常存在大量的重复纹理，使得特征描述非常相似。在这种情况下，仅利用局部特征解决误匹配是非常困难的。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
    OBACKSLASHcentering
    OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT9OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEfeatureOMINUSmatchingCLOSECURLY
    OBACKSLASHcaptionOPENCURLY两帧图像间的特征匹配。CLOSECURLY
    OBACKSLASHlabelOPENCURLYfigOCOLONfeatureOMINUSmatchingCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

不过，让我们先来看正确匹配的情况，等做完实验再回头去讨论误匹配问题。考虑两个时刻的图像。如果在图像ODOLLARIOUNDERSCOREOPENCURLYtCLOSECURLYODOLLAR中提取到特征点ODOLLAR xOUNDERSCOREOPENCURLYtCLOSECURLYOHATOPENCURLYmCLOSECURLYOCOMMA mOASSIGN1OCOMMA2OCOMMAODOTODOTODOTOCOMMAMODOLLAR，在图像ODOLLARIOUNDERSCOREOPENCURLYtOPLUS1CLOSECURLYODOLLAR中提取到特征点ODOLLARxOUNDERSCOREOPENCURLYtOPLUS1CLOSECURLYOHATOPENCURLYnCLOSECURLYOCOMMA nOASSIGN1OCOMMA2OCOMMAODOTODOTODOTOCOMMANODOLLAR，如何寻找这两个集合元素的对应关系呢？最简单的特征匹配方法就是OBACKSLASHtextbfOPENCURLY暴力匹配（BruteOMINUSForce Matcher）CLOSECURLY。即对每一个特征点ODOLLARxOUNDERSCOREOPENCURLYtCLOSECURLYOHATOPENCURLYmCLOSECURLYODOLLAR与所有的ODOLLARxOUNDERSCOREOPENCURLYtOPLUS1CLOSECURLYOHATOPENCURLYnCLOSECURLYODOLLAR测量描述子的距离，然后排序，取最近的一个作为匹配点。描述子距离表示了两个特征之间的OBACKSLASHtextbfOPENCURLY相似程度CLOSECURLY，不过在实际运用中还可以取不同的距离度量范数。对于浮点类型的描述子，使用欧氏距离进行度量即可。而对于二进制的描述子（比如BRIEF这样的），我们往往使用汉明距离（Hamming distance）作为度量——两个二进制串之间的汉明距离，指的是其OBACKSLASHtextbfOPENCURLY不同位数的个数CLOSECURLY。

然而，当特征点数量很大时，暴力匹配法的运算量将变得很大，特别是当想要匹配某个帧和一张地图的时候。这不符合我们在SLAM中的实时性需求。此时OBACKSLASHtextbfOPENCURLY快速近似最近邻（FLANN）CLOSECURLY算法更加适合于匹配点数量极多的情况。由于这些匹配算法理论已经成熟，而且实现上也已集成到OpenCV，所以这里就不再描述它的技术细节了。感兴趣的读者可以参考阅读文献OBACKSLASHciteOPENCURLYMuja2009CLOSECURLY。

OBACKSLASHsectionOPENCURLY实践：特征提取和匹配CLOSECURLY
OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT9OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEexp1OMINUSimagesODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLY实验使用的两帧图像。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONexp1OMINUSimagesCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

OpenCV已经集成了多数主流的图像特征，我们可以很方便地进行调用。下面我们来完成两个实验：第一个实验中，我们演示使用OpenCV进行ORB的特征匹配；第二个实验中，我们演示如何根据前面介绍的原理，手写一个简单的ORB特征。通过手写的过程，读者可以更加清楚地理解ORB的计算过程，并类推到其他特征上去。

OBACKSLASHsubsectionOPENCURLYOpenCV的ORB特征CLOSECURLY
首先我们调用OpenCV来提取和匹配ORB。我为此实验准备了两张图像，位于slambook2ODIVIDEch7ODIVIDE下的1ODOTpng和2ODOTpng，如OBACKSLASHautorefOPENCURLYfigOCOLONexp1OMINUSimagesCLOSECURLYOTILDE所示。它们是来自公开数据集OBACKSLASHciteOPENCURLYSturm2012CLOSECURLY中的两张图像，我们看到相机发生了微小的运动。本节程序演示如何提取ORB特征并进行匹配。下一小节中，我们将演示如何用匹配结果来估计相机运动。

下面程序演示了ORB的使用方法：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch7ODIVIDEorbOUNDERSCOREcvODOTcppCLOSESQUARE
OSINGLEHASHinclude OGREATiostreamOLESS
OSINGLEHASHinclude OGREATopencv2ODIVIDEcoreODIVIDEcoreODOThppOLESS
OSINGLEHASHinclude OGREATopencv2ODIVIDEfeatures2dODIVIDEfeatures2dODOThppOLESS
OSINGLEHASHinclude OGREATopencv2ODIVIDEhighguiODIVIDEhighguiODOThppOLESS
OSINGLEHASHinclude OGREATchronoOLESS

using namespace stdOSEMICOLON
using namespace cvOSEMICOLON

int mainOPENBRACKETint argcOCOMMA char OMULTIPLYOMULTIPLYargvCLOSEBRACKET OPENCURLY
    if OPENBRACKETargc ONOTOASSIGN 3CLOSEBRACKET OPENCURLY
        cout OGREATOGREAT "usageOCOLON featureOUNDERSCOREextraction img1 img2" OGREATOGREAT endlOSEMICOLON
        return 1OSEMICOLON
    CLOSECURLY
    ODIVIDEODIVIDEOMINUSOMINUS 读取图像
    Mat imgOUNDERSCORE1 OASSIGN imreadOPENBRACKETargvOPENSQUARE1CLOSESQUAREOCOMMA CVOUNDERSCORELOADOUNDERSCOREIMAGEOUNDERSCORECOLORCLOSEBRACKETOSEMICOLON
    Mat imgOUNDERSCORE2 OASSIGN imreadOPENBRACKETargvOPENSQUARE2CLOSESQUAREOCOMMA CVOUNDERSCORELOADOUNDERSCOREIMAGEOUNDERSCORECOLORCLOSEBRACKETOSEMICOLON
    assertOPENBRACKETimgOUNDERSCORE1ODOTdata ONOTOASSIGN nullptr OBANDOBAND imgOUNDERSCORE2ODOTdata ONOTOASSIGN nullptrCLOSEBRACKETOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 初始化
    stdOCOLONOCOLONvectorOGREATKeyPointOLESS keypointsOUNDERSCORE1OCOMMA keypointsOUNDERSCORE2OSEMICOLON
    Mat descriptorsOUNDERSCORE1OCOMMA descriptorsOUNDERSCORE2OSEMICOLON
    PtrOGREATFeatureDetectorOLESS detector OASSIGN ORBOCOLONOCOLONcreateOPENBRACKETCLOSEBRACKETOSEMICOLON
    PtrOGREATDescriptorExtractorOLESS descriptor OASSIGN ORBOCOLONOCOLONcreateOPENBRACKETCLOSEBRACKETOSEMICOLON
    PtrOGREATDescriptorMatcherOLESS matcher OASSIGN DescriptorMatcherOCOLONOCOLONcreateOPENBRACKET"BruteForceOMINUSHamming"CLOSEBRACKETOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 第一步OCOLON检测 Oriented FAST 角点位置
    chronoOCOLONOCOLONsteadyOUNDERSCOREclockOCOLONOCOLONtimeOUNDERSCOREpoint t1 OASSIGN chronoOCOLONOCOLONsteadyOUNDERSCOREclockOCOLONOCOLONnowOPENBRACKETCLOSEBRACKETOSEMICOLON
    detectorOMINUSOLESSdetectOPENBRACKETimgOUNDERSCORE1OCOMMA keypointsOUNDERSCORE1CLOSEBRACKETOSEMICOLON
    detectorOMINUSOLESSdetectOPENBRACKETimgOUNDERSCORE2OCOMMA keypointsOUNDERSCORE2CLOSEBRACKETOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 第二步OCOLON根据角点位置计算 BRIEF 描述子
    descriptorOMINUSOLESScomputeOPENBRACKETimgOUNDERSCORE1OCOMMA keypointsOUNDERSCORE1OCOMMA descriptorsOUNDERSCORE1CLOSEBRACKETOSEMICOLON
    descriptorOMINUSOLESScomputeOPENBRACKETimgOUNDERSCORE2OCOMMA keypointsOUNDERSCORE2OCOMMA descriptorsOUNDERSCORE2CLOSEBRACKETOSEMICOLON
    chronoOCOLONOCOLONsteadyOUNDERSCOREclockOCOLONOCOLONtimeOUNDERSCOREpoint t2 OASSIGN chronoOCOLONOCOLONsteadyOUNDERSCOREclockOCOLONOCOLONnowOPENBRACKETCLOSEBRACKETOSEMICOLON
    chronoOCOLONOCOLONdurationOGREATdoubleOLESS timeOUNDERSCOREused OASSIGN chronoOCOLONOCOLONdurationOUNDERSCOREcastOGREATchronoOCOLONOCOLONdurationOGREATdoubleOLESSOLESSOPENBRACKETt2 OMINUS t1CLOSEBRACKETOSEMICOLON
    cout OGREATOGREAT "extract ORB cost OASSIGN " OGREATOGREAT timeOUNDERSCOREusedODOTcountOPENBRACKETCLOSEBRACKET OGREATOGREAT " secondsODOT " OGREATOGREAT endlOSEMICOLON
    
    Mat outimg1OSEMICOLON
    drawKeypointsOPENBRACKETimgOUNDERSCORE1OCOMMA keypointsOUNDERSCORE1OCOMMA outimg1OCOMMA ScalarOCOLONOCOLONallOPENBRACKETOMINUS1CLOSEBRACKETOCOMMA DrawMatchesFlagsOCOLONOCOLONDEFAULTCLOSEBRACKETOSEMICOLON
    imshowOPENBRACKET"ORB features"OCOMMA outimg1CLOSEBRACKETOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 第三步OCOLON对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离
    vectorOGREATDMatchOLESS matchesOSEMICOLON
    t1 OASSIGN chronoOCOLONOCOLONsteadyOUNDERSCOREclockOCOLONOCOLONnowOPENBRACKETCLOSEBRACKETOSEMICOLON
    matcherOMINUSOLESSmatchOPENBRACKETdescriptorsOUNDERSCORE1OCOMMA descriptorsOUNDERSCORE2OCOMMA matchesCLOSEBRACKETOSEMICOLON
    t2 OASSIGN chronoOCOLONOCOLONsteadyOUNDERSCOREclockOCOLONOCOLONnowOPENBRACKETCLOSEBRACKETOSEMICOLON
    timeOUNDERSCOREused OASSIGN chronoOCOLONOCOLONdurationOUNDERSCOREcastOGREATchronoOCOLONOCOLONdurationOGREATdoubleOLESSOLESSOPENBRACKETt2 OMINUS t1CLOSEBRACKETOSEMICOLON
    cout OGREATOGREAT "match ORB cost OASSIGN " OGREATOGREAT timeOUNDERSCOREusedODOTcountOPENBRACKETCLOSEBRACKET OGREATOGREAT " secondsODOT " OGREATOGREAT endlOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 第四步OCOLON匹配点对筛选
    ODIVIDEODIVIDE 计算最小距离和最大距离
    auto minOUNDERSCOREmax OASSIGN minmaxOUNDERSCOREelementOPENBRACKETmatchesODOTbeginOPENBRACKETCLOSEBRACKETOCOMMA matchesODOTendOPENBRACKETCLOSEBRACKETOCOMMA
        OPENSQUARECLOSESQUAREOPENBRACKETconst DMatch OBANDm1OCOMMA const DMatch OBANDm2CLOSEBRACKET OPENCURLY return m1ODOTdistance OGREAT m2ODOTdistanceOSEMICOLON CLOSECURLYCLOSEBRACKETOSEMICOLON
    double minOUNDERSCOREdist OASSIGN minOUNDERSCOREmaxODOTfirstOMINUSOLESSdistanceOSEMICOLON
    double maxOUNDERSCOREdist OASSIGN minOUNDERSCOREmaxODOTsecondOMINUSOLESSdistanceOSEMICOLON
    
    printfOPENBRACKET"OMINUSOMINUS Max dist OCOLON OMODULOf OBACKSLASHn"OCOMMA maxOUNDERSCOREdistCLOSEBRACKETOSEMICOLON
    printfOPENBRACKET"OMINUSOMINUS Min dist OCOLON OMODULOf OBACKSLASHn"OCOMMA minOUNDERSCOREdistCLOSEBRACKETOSEMICOLON
    
    ODIVIDEODIVIDE当描述子之间的距离大于两倍的最小距离时OCOMMA即认为匹配有误ODOT但有时候最小距离会非常小OCOMMA设置一个经验值30作为下限ODOT
    stdOCOLONOCOLONvectorOGREATDMatchOLESS goodOUNDERSCOREmatchesOSEMICOLON
    for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT descriptorsOUNDERSCORE1ODOTrowsOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
        if OPENBRACKETmatchesOPENSQUAREiCLOSESQUAREODOTdistance OGREATOASSIGN maxOPENBRACKET2 OMULTIPLY minOUNDERSCOREdistOCOMMA 30ODOT0CLOSEBRACKETCLOSEBRACKET OPENCURLY
            goodOUNDERSCOREmatchesODOTpushOUNDERSCOREbackOPENBRACKETmatchesOPENSQUAREiCLOSESQUARECLOSEBRACKETOSEMICOLON
        CLOSECURLY
    CLOSECURLY
    
    ODIVIDEODIVIDEOMINUSOMINUS 第五步OCOLON绘制匹配结果
    Mat imgOUNDERSCOREmatchOSEMICOLON
    Mat imgOUNDERSCOREgoodmatchOSEMICOLON
    drawMatchesOPENBRACKETimgOUNDERSCORE1OCOMMA keypointsOUNDERSCORE1OCOMMA imgOUNDERSCORE2OCOMMA keypointsOUNDERSCORE2OCOMMA matchesOCOMMA imgOUNDERSCOREmatchCLOSEBRACKETOSEMICOLON
    drawMatchesOPENBRACKETimgOUNDERSCORE1OCOMMA keypointsOUNDERSCORE1OCOMMA imgOUNDERSCORE2OCOMMA keypointsOUNDERSCORE2OCOMMA goodOUNDERSCOREmatchesOCOMMA imgOUNDERSCOREgoodmatchCLOSEBRACKETOSEMICOLON
    imshowOPENBRACKET"all matches"OCOMMA imgOUNDERSCOREmatchCLOSEBRACKETOSEMICOLON
    imshowOPENBRACKET"good matches"OCOMMA imgOUNDERSCOREgoodmatchCLOSEBRACKETOSEMICOLON
    waitKeyOPENBRACKET0CLOSEBRACKETOSEMICOLON
    
    return 0OSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

运行此程序（需要输入两个图像位置），将输出运行结果：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshOCOMMAcaptionOASSIGN终端输入：CLOSESQUARE
OMODULO buildODIVIDEorbOUNDERSCOREcv 1ODOTpng 2ODOTpng
extract ORB cost OASSIGN 0ODOT0229183 secondsODOT 
match ORB cost OASSIGN 0ODOT000751868 secondsODOT
OMINUSOMINUS Max dist OCOLON 95ODOT000000 
OMINUSOMINUS Min dist OCOLON 4ODOT000000 
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

OBACKSLASHautorefOPENCURLYfigOCOLONexp1OMINUSresultsCLOSECURLYOTILDE显示了例程的运行结果。我们看到未筛选的匹配中带有大量的误匹配。经过一次筛选之后，匹配数量减少了许多，但大多数匹配都是正确的。这里，筛选的依据是OBACKSLASHtextbfOPENCURLY汉明距离小于最小距离的两倍CLOSECURLY，这是一种工程上的经验方法，不一定有理论依据。不过，尽管在示例图像中能够筛选出正确的匹配，但我们仍然不能保证在所有其他图像中得到的匹配都是正确的。因此，在后面的运动估计中，还需要使用去除误匹配的算法。在我的机器上，ORB提取花费了22ODOT9毫秒（两张图像），匹配花费了0ODOT75毫秒，可见大部分计算量花在了特征提取上。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1ODOT0OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEexp1OMINUSresultCLOSECURLY
	OBACKSLASHcaptionOPENCURLY特征提取与匹配结果。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONexp1OMINUSresultsCLOSECURLY 
OBACKSLASHendOPENCURLYfigureCLOSECURLY

OBACKSLASHsubsectionOPENCURLY手写ORB特征CLOSECURLY
下面我们演示手写ORB特征的方法。这部分代码比较多，书上只展示核心部分的代码，其余的周边代码请读者从代码库中获取。
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch7ODIVIDEorbOUNDERSCOREselfODOTcpp（片段）CLOSESQUARE
typedef vectorOGREATuint32OUNDERSCOREtOLESS DescTypeOSEMICOLON
ODIVIDEODIVIDE ODOTODOTODOT 省略图片读取部分代码和测试代码
ODIVIDEODIVIDE compute the descriptor
void ComputeORBOPENBRACKETconst cvOCOLONOCOLONMat OBANDimgOCOMMA vectorOGREATcvOCOLONOCOLONKeyPointOLESS OBANDkeypointsOCOMMA vectorOGREATDescTypeOLESS OBANDdescriptorsCLOSEBRACKET OPENCURLY
    const int halfOUNDERSCOREpatchOUNDERSCOREsize OASSIGN 8OSEMICOLON
    const int halfOUNDERSCOREboundary OASSIGN 16OSEMICOLON
    int badOUNDERSCOREpoints OASSIGN 0OSEMICOLON
    for OPENBRACKETauto OBANDkpOCOLON keypointsCLOSEBRACKET OPENCURLY
        if OPENBRACKETkpODOTptODOTx OGREAT halfOUNDERSCOREboundary OBBOROBBOR kpODOTptODOTy OGREAT halfOUNDERSCOREboundary OBBOROBBOR
        kpODOTptODOTx OLESSOASSIGN imgODOTcols OMINUS halfOUNDERSCOREboundary OBBOROBBOR kpODOTptODOTy OLESSOASSIGN imgODOTrows OMINUS halfOUNDERSCOREboundaryCLOSEBRACKET OPENCURLY
            ODIVIDEODIVIDE outside
            badOUNDERSCOREpointsOPLUSOPLUSOSEMICOLON
            descriptorsODOTpushOUNDERSCOREbackOPENBRACKETOPENCURLYCLOSECURLYCLOSEBRACKETOSEMICOLON
            continueOSEMICOLON
        CLOSECURLY
    
        float m01 OASSIGN 0OCOMMA m10 OASSIGN 0OSEMICOLON
        for OPENBRACKETint dx OASSIGN OMINUShalfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON dx OGREAT halfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON OPLUSOPLUSdxCLOSEBRACKET OPENCURLY
            for OPENBRACKETint dy OASSIGN OMINUShalfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON dy OGREAT halfOUNDERSCOREpatchOUNDERSCOREsizeOSEMICOLON OPLUSOPLUSdyCLOSEBRACKET OPENCURLY
                uchar pixel OASSIGN imgODOTatOGREATucharOLESSOPENBRACKETkpODOTptODOTy OPLUS dyOCOMMA kpODOTptODOTx OPLUS dxCLOSEBRACKETOSEMICOLON
                m01 OPLUSOASSIGN dx OMULTIPLY pixelOSEMICOLON
                m10 OPLUSOASSIGN dy OMULTIPLY pixelOSEMICOLON
            CLOSECURLY
        CLOSECURLY
    
        ODIVIDEODIVIDE angle should be arc tanOPENBRACKETm01ODIVIDEm10CLOSEBRACKETOSEMICOLON
        float mOUNDERSCOREsqrt OASSIGN sqrtOPENBRACKETm01 OMULTIPLY m01 OPLUS m10 OMULTIPLY m10CLOSEBRACKETOSEMICOLON
        float sinOUNDERSCOREtheta OASSIGN m01 ODIVIDE mOUNDERSCOREsqrtOSEMICOLON
        float cosOUNDERSCOREtheta OASSIGN m10 ODIVIDE mOUNDERSCOREsqrtOSEMICOLON
        
        ODIVIDEODIVIDE compute the angle of this point
        DescType descOPENBRACKET8OCOMMA 0CLOSEBRACKETOSEMICOLON
        for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT 8OSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
            uint32OUNDERSCOREt d OASSIGN 0OSEMICOLON
            for OPENBRACKETint k OASSIGN 0OSEMICOLON k OGREAT 32OSEMICOLON kOPLUSOPLUSCLOSEBRACKET OPENCURLY
                int idxOUNDERSCOREpq OASSIGN i OMULTIPLY 8 OPLUS kOSEMICOLON
                cvOCOLONOCOLONPoint2f pOPENBRACKETORBOUNDERSCOREpatternOPENSQUAREidxOUNDERSCOREpq OMULTIPLY 4CLOSESQUAREOCOMMA ORBOUNDERSCOREpatternOPENSQUAREidxOUNDERSCOREpq OMULTIPLY 4 OPLUS 1CLOSESQUARECLOSEBRACKETOSEMICOLON
                cvOCOLONOCOLONPoint2f qOPENBRACKETORBOUNDERSCOREpatternOPENSQUAREidxOUNDERSCOREpq OMULTIPLY 4 OPLUS 2CLOSESQUAREOCOMMA ORBOUNDERSCOREpatternOPENSQUAREidxOUNDERSCOREpq OMULTIPLY 4 OPLUS 3CLOSESQUARECLOSEBRACKETOSEMICOLON
        
                ODIVIDEODIVIDE rotate with theta
                cvOCOLONOCOLONPoint2f pp OASSIGN cvOCOLONOCOLONPoint2fOPENBRACKETcosOUNDERSCOREtheta OMULTIPLY pODOTx OMINUS sinOUNDERSCOREtheta OMULTIPLY pODOTyOCOMMA sinOUNDERSCOREtheta OMULTIPLY pODOTx OPLUS cosOUNDERSCOREtheta OMULTIPLY pODOTyCLOSEBRACKET OPLUS kpODOTptOSEMICOLON
                cvOCOLONOCOLONPoint2f qq OASSIGN cvOCOLONOCOLONPoint2fOPENBRACKETcosOUNDERSCOREtheta OMULTIPLY qODOTx OMINUS sinOUNDERSCOREtheta OMULTIPLY qODOTyOCOMMA sinOUNDERSCOREtheta OMULTIPLY qODOTx OPLUS cosOUNDERSCOREtheta OMULTIPLY qODOTyCLOSEBRACKET OPLUS kpODOTptOSEMICOLON
                if OPENBRACKETimgODOTatOGREATucharOLESSOPENBRACKETppODOTyOCOMMA ppODOTxCLOSEBRACKET OGREAT imgODOTatOGREATucharOLESSOPENBRACKETqqODOTyOCOMMA qqODOTxCLOSEBRACKETCLOSEBRACKET OPENCURLY
                    d OBBOROASSIGN 1 OGREATOGREAT kOSEMICOLON
                CLOSECURLY
            CLOSECURLY
            descOPENSQUAREiCLOSESQUARE OASSIGN dOSEMICOLON
        CLOSECURLY
        descriptorsODOTpushOUNDERSCOREbackOPENBRACKETdescCLOSEBRACKETOSEMICOLON
    CLOSECURLY
    
    cout OGREATOGREAT "badODIVIDEtotalOCOLON " OGREATOGREAT badOUNDERSCOREpoints OGREATOGREAT "ODIVIDE" OGREATOGREAT keypointsODOTsizeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
CLOSECURLY

ODIVIDEODIVIDE bruteOMINUSforce matching
void BfMatchOPENBRACKET
    const vectorOGREATDescTypeOLESS OBANDdesc1OCOMMA const vectorOGREATDescTypeOLESS OBANDdesc2OCOMMA vectorOGREATcvOCOLONOCOLONDMatchOLESS OBANDmatchesCLOSEBRACKET OPENCURLY
    const int dOUNDERSCOREmax OASSIGN 40OSEMICOLON
    
    for OPENBRACKETsizeOUNDERSCOREt i1 OASSIGN 0OSEMICOLON i1 OGREAT desc1ODOTsizeOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSi1CLOSEBRACKET OPENCURLY
        if OPENBRACKETdesc1OPENSQUAREi1CLOSESQUAREODOTemptyOPENBRACKETCLOSEBRACKETCLOSEBRACKET continueOSEMICOLON
        cvOCOLONOCOLONDMatch mOPENCURLYi1OCOMMA 0OCOMMA 256CLOSECURLYOSEMICOLON
        for OPENBRACKETsizeOUNDERSCOREt i2 OASSIGN 0OSEMICOLON i2 OGREAT desc2ODOTsizeOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSi2CLOSEBRACKET OPENCURLY
            if OPENBRACKETdesc2OPENSQUAREi2CLOSESQUAREODOTemptyOPENBRACKETCLOSEBRACKETCLOSEBRACKET continueOSEMICOLON
            int distance OASSIGN 0OSEMICOLON
            for OPENBRACKETint k OASSIGN 0OSEMICOLON k OGREAT 8OSEMICOLON kOPLUSOPLUSCLOSEBRACKET OPENCURLY
                distance OPLUSOASSIGN OUNDERSCOREmmOUNDERSCOREpopcntOUNDERSCOREu32OPENBRACKETdesc1OPENSQUAREi1CLOSESQUAREOPENSQUAREkCLOSESQUARE OHATdesc2OPENSQUAREi2CLOSESQUAREOPENSQUAREkCLOSESQUARECLOSEBRACKETOSEMICOLON
            CLOSECURLY
            if OPENBRACKETdistance OGREAT dOUNDERSCOREmax OBANDOBAND distance OGREAT mODOTdistanceCLOSEBRACKET OPENCURLY
                mODOTdistance OASSIGN distanceOSEMICOLON
                mODOTtrainIdx OASSIGN i2OSEMICOLON
            CLOSECURLY
        CLOSECURLY
        if OPENBRACKETmODOTdistance OGREAT dOUNDERSCOREmaxCLOSEBRACKET OPENCURLY
            matchesODOTpushOUNDERSCOREbackOPENBRACKETmCLOSEBRACKETOSEMICOLON
        CLOSECURLY
    CLOSECURLY
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY
这个演示中我们只展示ORB的计算代码和匹配代码。在计算中，我们用256位的二进制描述，即对应到8个32位的unsigned int数据，用typedef将它表示成DescType。然后，我们根据前面介绍的原理计算FAST特征点的角度，再使用该角度计算描述子。此代码中通过三角函数的原理回避了复杂的ODOLLAROBACKSLASHarctanODOLLAR以及ODOLLAROBACKSLASHsinODOLLAR、ODOLLAROBACKSLASHcosODOLLAR计算，从而达到加速的效果。在BfMatch函数中，我们还使用了SSE指令集中的OBACKSLASHOUNDERSCOREmmOBACKSLASHOUNDERSCOREpopcntOBACKSLASHOUNDERSCOREu32函数来计算一个unsigned int变量中1的个数，从而达到计算汉明距离的效果。该段程序的运行结果如下，匹配结果如OBACKSLASHautorefOPENCURLYfigOCOLONmatchesCLOSECURLY所示：

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshOCOMMAcaptionOASSIGN终端输出：CLOSESQUARE
badODIVIDEtotalOCOLON 43ODIVIDE638
badODIVIDEtotalOCOLON 8ODIVIDE595
extract ORB cost OASSIGN 0ODOT00390721 secondsODOT
match ORB cost OASSIGN 0ODOT000862984 secondsODOT
matchesOCOLON 51
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
    OBACKSLASHcentering
    OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT8OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEmatchesCLOSECURLY
    OBACKSLASHcaptionOPENCURLY匹配结果CLOSECURLY
    OBACKSLASHlabelOPENCURLYfigOCOLONmatchesCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

可见，这个程序中，ORB的提取只需要3ODOT9毫秒，匹配只需0ODOT86毫秒。我们通过一些简单的算法修改，对ORB的提取加速了5ODOT8倍。请读者注意，编译这个程序需要你的CPU支持SSE指令集，这应该在绝大多数现代的家用CPU上都已经支持。如果我们能够对提取特征部分进一步并行化处理，算法还可以有加速的空间。

OBACKSLASHsubsectionOPENCURLY计算相机运动CLOSECURLY
我们已经有了匹配好的点对，接下来，我们要根据点对来估计相机的运动。这里由于相机的原理不同，情况发生了变化：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 当相机为单目时，我们只知道2D的像素坐标，因而问题是根据OBACKSLASHtextbfOPENCURLY两组2D点CLOSECURLY估计运动。该问题用OBACKSLASHtextbfOPENCURLY对极几何CLOSECURLY来解决。
	OBACKSLASHitem 当相机为双目、RGBOMINUSD时，或者通过某种方法得到了距离信息，那么问题就是根据OBACKSLASHtextbfOPENCURLY两组3D点CLOSECURLY估计运动。该问题通常用ICP来解决。
	OBACKSLASHitem 如果一组为3D，一组为2D，即，我们得到了一些3D点和它们在相机的投影位置，也能估计相机的运动。该问题通过OBACKSLASHtextbfOPENCURLYPnPCLOSECURLY求解。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

因此，下面几节就来介绍这三种情形下的相机运动估计。我们将从信息最少的2D−2D情形出发，看看它如何求解，求解过程又有哪些麻烦的问题。

OBACKSLASHsectionOPENCURLY2D−2DOCOLON 对极几何CLOSECURLY
OBACKSLASHlabelOPENCURLYsecOCOLONepipolarOMINUSgeometryCLOSECURLY

OBACKSLASHsubsectionOPENCURLY对极约束CLOSECURLY

现在，假设我们从两张图像中得到了一对配对好的特征点，如OBACKSLASHautorefOPENCURLYfigOCOLONdoubleviewCLOSECURLYOTILDE所示。如果有若干对这样的匹配点，就可以通过这些二维图像点的对应关系，恢复出在两帧之间摄像机的运动。这里“若干对”具体是多少对呢？我们会在下文介绍。下面先来看看两个图像当中的匹配点有什么几何关系。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT6OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEfundamentalCLOSECURLY
	OBACKSLASHcaptionOPENCURLY对极几何约束。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONdoubleviewCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

以OBACKSLASHautorefOPENCURLYfigOCOLONdoubleviewCLOSECURLYOTILDE为例，我们希望求取两帧图像ODOLLARIOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMA IOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR之间的运动，设第一帧到第二帧的运动为ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR。两个相机中心分别为ODOLLAROOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMA OOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR。现在，考虑ODOLLARIOUNDERSCOREOPENCURLY1CLOSECURLYODOLLAR中有一个特征点ODOLLARpOUNDERSCOREOPENCURLY1CLOSECURLYODOLLAR，它在ODOLLARIOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR中对应着特征点ODOLLARpOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR。我们知道两者是通过特征匹配得到的。如果匹配正确，说明它们确实是OBACKSLASHtextbfOPENCURLY同一个空间点在两个成像平面上的投影CLOSECURLY。这里需要一些术语来描述它们之间的几何关系。首先，连线ODOLLAROBACKSLASHoverrightarrowOPENCURLYOOUNDERSCOREOPENCURLY1CLOSECURLYpOUNDERSCOREOPENCURLY1CLOSECURLYCLOSECURLYODOLLAR和连线ODOLLAROBACKSLASHoverrightarrowOPENCURLYOOUNDERSCOREOPENCURLY2CLOSECURLYpOUNDERSCOREOPENCURLY2CLOSECURLYCLOSECURLYODOLLAR在三维空间中会相交于点ODOLLARPODOLLAR。这时候点ODOLLAROOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAOOUNDERSCOREOPENCURLY2CLOSECURLYOCOMMAPODOLLAR三个点可以确定一个平面，称为OBACKSLASHtextbfOPENCURLY极平面（Epipolar plane）CLOSECURLY。ODOLLAROOUNDERSCOREOPENCURLY1CLOSECURLYOOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR连线与像平面ODOLLARIOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAIOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR的交点分别为ODOLLAReOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAeOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR。ODOLLAReOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAeOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR称为OBACKSLASHtextbfOPENCURLY极点（Epipoles）CLOSECURLY，ODOLLAROOUNDERSCOREOPENCURLY1CLOSECURLYOOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR被称为OBACKSLASHtextbfOPENCURLY基线（Baseline）CLOSECURLY。我们称极平面与两个像平面ODOLLARIOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMA IOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR之间的相交线ODOLLARlOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAlOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR为OBACKSLASHtextbfOPENCURLY极线（Epipolar line）CLOSECURLY。

直观讲，从第一帧的角度看，射线ODOLLAROBACKSLASHoverrightarrowOPENCURLYOOUNDERSCORE1 pOUNDERSCORE1CLOSECURLYODOLLAR是OBACKSLASHtextbfOPENCURLY某个像素可能出现的空间位置CLOSECURLY——因为该射线上的所有点都会投影到同一个像素点。同时，如果不知道ODOLLARPODOLLAR的位置，那么当我们在第二幅图像上看时，连线ODOLLAROBACKSLASHoverrightarrowOPENCURLYeOUNDERSCORE2 pOUNDERSCORE2CLOSECURLYODOLLAR（也就是第二幅图像中的极线）就是ODOLLARPODOLLAR可能出现的投影的位置，也就是射线ODOLLAROBACKSLASHoverrightarrowOPENCURLYOOUNDERSCORE1 pOUNDERSCORE1CLOSECURLYODOLLAR在第二个相机中的投影。现在，由于我们通过特征点匹配确定了ODOLLARpOUNDERSCORE2ODOLLAR的像素位置，所以能够推断ODOLLARPODOLLAR的空间位置，以及相机的运动。要提醒读者的是，OBACKSLASHtextbfOPENCURLY这多亏了正确的特征匹配CLOSECURLY。如果没有特征匹配，我们就没法确定ODOLLARpOUNDERSCORE2ODOLLAR到底在极线的哪个位置了。那时，就必须在极线上搜索以获得正确的匹配，这将在第12讲中提到。

现在，我们从代数角度来看一下这里的几何关系。在第一帧的坐标系下，设ODOLLARPODOLLAR的空间位置为
OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYPCLOSECURLYOASSIGNOPENSQUAREXOCOMMAYOCOMMAZCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
OBACKSLASHCLOSESQUARE
根据第5讲介绍的针孔相机模型，我们知道两个像素点ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1OCOMMAOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2ODOLLAR的像素位置为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
sOUNDERSCORE1 OPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYKPCLOSECURLYOCOMMAOBACKSLASHquad sOUNDERSCORE2 OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2 OASSIGN OBACKSLASHbmOPENCURLYKCLOSECURLYOBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYRP OPLUS tCLOSECURLY OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这里ODOLLAROBACKSLASHbmOPENCURLYKCLOSECURLYODOLLAR为相机内参矩阵，ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR为两个坐标系的相机运动。具体来说，这里计算的是ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCOREOPENCURLY21CLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLY21CLOSECURLYODOLLAR，因为它们把第一个坐标系下的坐标转换到第二个坐标系下。如果我们愿意，也可以把它们写成李代数形式。

有时候，我们会使用齐次坐标表示像素点。在使用齐次坐标时，一个向量将等于它自身乘上任意的非零常数。这通常用于表达一个投影关系。例如ODOLLARsOUNDERSCORE1 OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1ODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1ODOLLAR成投影关系，它们在齐次坐标的意义下是相等的。我们称这种相等关系为OBACKSLASHtextbfOPENCURLY尺度意义下相等CLOSECURLY（equal up to a scale），记作：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
sOBACKSLASHbmOPENCURLYpCLOSECURLY OBACKSLASHsimeq OBACKSLASHbmOPENCURLYpCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
那么，上述两个投影关系可写为：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
 OPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1CLOSECURLY OBACKSLASHsimeq OBACKSLASHbmOPENCURLYKPCLOSECURLYOCOMMAOBACKSLASHquad OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2 OBACKSLASHsimeq OBACKSLASHbmOPENCURLYKCLOSECURLYOBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYRP OPLUS tCLOSECURLY OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

现在，取：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE1CLOSECURLY OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYKCLOSECURLYOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1CLOSECURLYOCOMMA OBACKSLASHquad OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2CLOSECURLY OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYKCLOSECURLYOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2CLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这里的ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2ODOLLAR是两个像素点的归一化平面上的坐标。代入上式，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2CLOSECURLY OBACKSLASHsimeq OBACKSLASHbmOPENCURLYRCLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE1CLOSECURLY OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

两边同时左乘ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYOHATOBACKSLASHwedgeODOLLAR。回忆ODOLLAROHATOBACKSLASHwedgeODOLLAR的定义，这相当于两侧同时与ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR做外积：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYtCLOSECURLYOHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2 OBACKSLASHsimeq OBACKSLASHbmOPENCURLYtCLOSECURLYOHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE1ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

然后，两侧同时左乘ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYtCLOSECURLYOHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2 OBACKSLASHsimeq OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYtCLOSECURLYOHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE1ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

观察等式左侧，ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYOHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2ODOLLAR是一个与ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2ODOLLAR都垂直的向量。把它再和ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2ODOLLAR做内积时，将得到0。由于等式左侧严格为零，那么乘以任意非零常数之后也为零，于是我们可以把ODOLLAROBACKSLASHsimeqODOLLAR写成通常的等号。因此，我们就得到了一个简洁的式子：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
 OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYtCLOSECURLYOHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE1 OASSIGN 0ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

重新代入ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2ODOLLAR，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYKCLOSECURLYOHATOPENCURLYOMINUSOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OBACKSLASHbmOPENCURLYtCLOSECURLYOHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYKCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1  OASSIGN 0ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这两个式子都称为OBACKSLASHtextbfOPENCURLY对极约束CLOSECURLY，它以形式简洁著名。它的几何意义是ODOLLAROOUNDERSCORE1OCOMMA POCOMMA OOUNDERSCORE2ODOLLAR三者共面。对极约束中同时包含了平移和旋转。我们把中间部分记作两个矩阵：基础矩阵（Fundamental Matrix）ODOLLAROBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR和本质矩阵（Essential Matrix）ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR，于是可以进一步简化对极约束：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYECLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYtCLOSECURLYOHAT OBACKSLASHwedge OBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHquad OBACKSLASHbmOPENCURLYFCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYKCLOSECURLYOHATOPENCURLY OMINUSOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OBACKSLASHbmOPENCURLYECLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYKCLOSECURLYOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYOCOMMA OBACKSLASHquad OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYECLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE1CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYFCLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1CLOSECURLY OASSIGN 0ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

对极约束简洁地给出了两个匹配点的空间位置关系。于是，相机位姿估计问题变为以下两步：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 根据配对点的像素位置求出ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR或者ODOLLAROBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR。
	OBACKSLASHitem 根据ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR或者ODOLLAROBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR求出ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

由于ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR只相差了相机内参，而内参在SLAM中通常是已知的OBACKSLASHfootnoteOPENCURLY在SfM研究中则有可能是未知而有待估计的。CLOSECURLY，所以实践当中往往使用形式更简单的ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR。我们以ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR为例，介绍上面两个问题如何求解。

OBACKSLASHsubsectionOPENCURLY本质矩阵CLOSECURLY
根据定义，本质矩阵ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYtCLOSECURLYOHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR。它是一个ODOLLAR3OBACKSLASHtimes 3ODOLLAR的矩阵，内有9个未知数。那么，是不是任意一个ODOLLAR3 OBACKSLASHtimes 3ODOLLAR的矩阵都可以被当成本质矩阵呢？从ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR的构造方式上看，有以下值得注意的地方：

OBACKSLASHbeginOPENCURLYitemizeCLOSECURLY
	OBACKSLASHitem 本质矩阵是由对极约束定义的。由于对极约束是OBACKSLASHtextbfOPENCURLY等式为零CLOSECURLY的约束，所以对ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR乘以任意非零常数后，OBACKSLASHtextbfOPENCURLY对极约束依然满足CLOSECURLY。我们把这件事情称为ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR在不同尺度下是等价的。
	OBACKSLASHitem 根据ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYtCLOSECURLYOHAT OBACKSLASHwedge OBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR，可以证明OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYHartley2003CLOSECURLYCLOSECURLY，本质矩阵ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR的奇异值必定是ODOLLAROPENSQUAREOBACKSLASHsigmaOCOMMA OBACKSLASHsigmaOCOMMA 0CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR的形式。这称为OBACKSLASHtextbfOPENCURLY本质矩阵的内在性质CLOSECURLY。
	OBACKSLASHitem 另一方面，由于平移和旋转各有3个自由度，故ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYOHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR共有6个自由度。但由于尺度等价性，故ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR实际上有5个自由度。
OBACKSLASHendOPENCURLYitemizeCLOSECURLY

ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR具有5个自由度的事实，表明我们最少可以用5对点来求解ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR。但是，ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR的内在性质是一种非线性性质，在估计时会带来麻烦，因此，也可以只考虑它的OBACKSLASHtextbfOPENCURLY尺度等价性CLOSECURLY，使用8对点来估计ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR——这就是经典的OBACKSLASHtextbfOPENCURLY八点法（EightOMINUSpointOMINUSalgorithm）CLOSECURLYOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYHartley1997OCOMMA LonguetOMINUSHiggins1987CLOSECURLYCLOSECURLY。八点法只利用了ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR的线性性质，因此可以在线性代数框架下求解。下面我们来看八点法是如何工作的。

考虑一对匹配点，它们的归一化坐标为ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLY1CLOSECURLYOASSIGNOPENSQUAREuOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAvOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMA1CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAROCOMMA ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCOREOPENCURLY2CLOSECURLYOASSIGNOPENSQUAREuOUNDERSCOREOPENCURLY2CLOSECURLYOCOMMAvOUNDERSCOREOPENCURLY2CLOSECURLYOCOMMA1CLOSESQUAREOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYODOLLAR。根据对极约束，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY 
uOUNDERSCOREOPENCURLY2CLOSECURLYOCOMMAvOUNDERSCOREOPENCURLY2CLOSECURLYOCOMMA1
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
 eOUNDERSCOREOPENCURLY1CLOSECURLY OBAND eOUNDERSCOREOPENCURLY2CLOSECURLY OBAND eOUNDERSCOREOPENCURLY3CLOSECURLYOBACKSLASHOBACKSLASH 
 eOUNDERSCOREOPENCURLY4CLOSECURLY OBAND eOUNDERSCOREOPENCURLY5CLOSECURLY OBAND eOUNDERSCOREOPENCURLY6CLOSECURLYOBACKSLASHOBACKSLASH 
 eOUNDERSCOREOPENCURLY7CLOSECURLY OBAND eOUNDERSCOREOPENCURLY8CLOSECURLY OBAND eOUNDERSCOREOPENCURLY9CLOSECURLY 
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY 
uOUNDERSCOREOPENCURLY1CLOSECURLYOBACKSLASHOBACKSLASHvOUNDERSCOREOPENCURLY1CLOSECURLYOBACKSLASHOBACKSLASH1
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OASSIGN0ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

我们把矩阵ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR展开，写成向量的形式：
OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYeCLOSECURLYOASSIGN OPENSQUAREeOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAeOUNDERSCOREOPENCURLY2CLOSECURLYOCOMMAeOUNDERSCOREOPENCURLY3CLOSECURLYOCOMMAeOUNDERSCOREOPENCURLY4CLOSECURLYOCOMMAeOUNDERSCOREOPENCURLY5CLOSECURLYOCOMMAeOUNDERSCOREOPENCURLY6CLOSECURLYOCOMMAeOUNDERSCOREOPENCURLY7CLOSECURLYOCOMMAeOUNDERSCOREOPENCURLY8CLOSECURLYOCOMMAeOUNDERSCOREOPENCURLY9CLOSECURLYCLOSESQUAREOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOCOMMA
OBACKSLASHCLOSESQUARE
那么对极约束可以写成与ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYODOLLAR有关的线性形式：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OPENSQUAREuOUNDERSCOREOPENCURLY2CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAuOUNDERSCOREOPENCURLY2CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAuOUNDERSCOREOPENCURLY2CLOSECURLYOCOMMAvOUNDERSCOREOPENCURLY2CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAvOUNDERSCOREOPENCURLY2CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAvOUNDERSCOREOPENCURLY2CLOSECURLYOCOMMAuOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAvOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMA1CLOSESQUARE OBACKSLASHcdot  OBACKSLASHbmOPENCURLYeCLOSECURLYOASSIGN0ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

同理，对于其他点对也有相同的表示。我们把所有点都放到一个方程中，变成线性方程组（ODOLLARuOHATiOCOMMA vOHATiODOLLAR表示第ODOLLARiODOLLAR个特征点，依此类推）：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYEqOCOLONeightOMINUSpointCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
uOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYOBAND uOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYOBAND uOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLYOBAND vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYOBAND vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYOBAND vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLY OBANDuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLY OBANDvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYOBAND1OBACKSLASHOBACKSLASH
uOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYOBAND uOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYOBAND uOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLYOBAND vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYOBAND vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYOBAND vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLY OBANDuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLY OBANDvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYOBAND1OBACKSLASHOBACKSLASH
OBACKSLASHvdots OBAND OBACKSLASHvdots OBAND OBACKSLASHvdots OBAND OBACKSLASHvdots OBAND OBACKSLASHvdots OBAND OBACKSLASHvdots OBAND OBACKSLASHvdots OBAND OBACKSLASHvdots OBACKSLASHOBACKSLASH
uOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY8CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY8CLOSECURLYOBAND uOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY8CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY8CLOSECURLYOBAND uOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY8CLOSECURLYOBAND vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY8CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY8CLOSECURLYOBAND vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY8CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY8CLOSECURLYOBAND vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY8CLOSECURLY OBANDuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY8CLOSECURLYOBANDvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY8CLOSECURLYOBAND1OBACKSLASHOBACKSLASH
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
eOUNDERSCOREOPENCURLY1CLOSECURLYOBACKSLASHOBACKSLASH eOUNDERSCOREOPENCURLY2CLOSECURLYOBACKSLASHOBACKSLASH eOUNDERSCOREOPENCURLY3CLOSECURLYOBACKSLASHOBACKSLASH  eOUNDERSCOREOPENCURLY4CLOSECURLYOBACKSLASHOBACKSLASH eOUNDERSCOREOPENCURLY5CLOSECURLYOBACKSLASHOBACKSLASH eOUNDERSCOREOPENCURLY6CLOSECURLYOBACKSLASHOBACKSLASH eOUNDERSCOREOPENCURLY7CLOSECURLYOBACKSLASHOBACKSLASH eOUNDERSCOREOPENCURLY8CLOSECURLYOBACKSLASHOBACKSLASH eOUNDERSCOREOPENCURLY9CLOSECURLY  
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OASSIGN0ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这8个方程构成了一个线性方程组。它的系数矩阵由特征点位置构成，大小为ODOLLAR8 OBACKSLASHtimes 9ODOLLAR。ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYODOLLAR位于该矩阵的零空间中。如果系数矩阵是满秩的（即秩为8），那么它的零空间维数为1，也就是ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYODOLLAR构成一条线。这与ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYODOLLAR的尺度等价性是一致的。如果8对匹配点组成的矩阵满足秩为8的条件，那么ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR的各元素就可由上述方程解得。

接下来的问题是如何根据已经估得的本质矩阵ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR，恢复出相机的运动ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR。这个过程是由奇异值分解（SVD）得到的。设ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR的SVD分解为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYECLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYUCLOSECURLY OBACKSLASHbmOPENCURLYOBACKSLASHSigmaCLOSECURLY OBACKSLASHbmOPENCURLYVCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOCOMMA
OBACKSLASHendOPENCURLYequationCLOSECURLY
其中ODOLLAROBACKSLASHbmOPENCURLYUCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYVCLOSECURLYODOLLAR为正交阵，ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHSigmaCLOSECURLYODOLLAR为奇异值矩阵。根据ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR的内在性质，我们知道ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHSigmaCLOSECURLY OASSIGN OBACKSLASHmathrmOPENCURLYdiagCLOSECURLYOPENBRACKET OBACKSLASHsigmaOCOMMA OBACKSLASHsigmaOCOMMA 0 CLOSEBRACKETODOLLAR。在SVD分解中，对于任意一个ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR，存在两个可能的ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR与它对应：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE1OHAT OBACKSLASHwedge  OASSIGN OBACKSLASHbmOPENCURLYUCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCOREZCLOSECURLYOPENBRACKETOBACKSLASHfracOPENCURLYOBACKSLASHpi CLOSECURLYOPENCURLY2CLOSECURLYCLOSEBRACKET OBACKSLASHbmOPENCURLYOBACKSLASHSigmaCLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYUCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOCOMMA OBACKSLASHquad OPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE1CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYUCLOSECURLY OBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCOREZOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOPENBRACKETOBACKSLASHfracOPENCURLYOBACKSLASHpi CLOSECURLYOPENCURLY2CLOSECURLYCLOSEBRACKETOPENCURLY OBACKSLASHbmOPENCURLYVCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE2OHAT OBACKSLASHwedge  OASSIGN OBACKSLASHbmOPENCURLYUCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCOREZCLOSECURLYOPENBRACKET OMINUS OBACKSLASHfracOPENCURLYOBACKSLASHpi CLOSECURLYOPENCURLY2CLOSECURLYCLOSEBRACKETOBACKSLASHbmOPENCURLYOBACKSLASHSigmaCLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYUCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOCOMMA OBACKSLASHquad  OPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE2CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYUCLOSECURLY OBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCOREZOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOPENBRACKET OMINUS OBACKSLASHfracOPENCURLYOBACKSLASHpi CLOSECURLYOPENCURLY2CLOSECURLYCLOSEBRACKETOPENCURLYOBACKSLASHbmOPENCURLYVCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYODOT
OBACKSLASHendOPENCURLYarrayCLOSECURLY
OBACKSLASHendOPENCURLYequationCLOSECURLY

其中ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCOREZOPENBRACKETOBACKSLASHfracOPENCURLYOBACKSLASHpi CLOSECURLYOPENCURLY2CLOSECURLYCLOSEBRACKETODOLLAR表示沿ODOLLARZODOLLAR轴旋转ODOLLAR90OHATOBACKSLASHcircODOLLAR得到的旋转矩阵。同时，由于ODOLLAROMINUSOBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR等价，所以对任意一个ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR取负号，也会得到同样的结果。因此，从ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR分解到ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR时，一共存在OBACKSLASHtextbfOPENCURLY4个CLOSECURLY可能的解。

OBACKSLASHautorefOPENCURLYfigOCOLONepipolarOMINUSsolutionCLOSECURLYOTILDE形象地展示了分解本质矩阵得到的4个解。我们已知空间点在相机（蓝色线）上的投影（红色点），想要求解相机的运动。在保持红色点不变的情况下，可以画出4种可能的情况。不过幸运的是，只有第一种解中ODOLLARPODOLLAR在两个相机中都具有正的深度。因此，只要把任意一点代入4种解中，检测该点在两个相机下的深度，就可以确定哪个解是正确的了。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1ODOT0OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEepipolarOMINUSsolutionCLOSECURLY
	OBACKSLASHcaptionOPENCURLY分解本质矩阵得到的4个解。在保持投影点（红色点）不变的情况下，两个相机及空间点一共有4种可能的情况。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONepipolarOMINUSsolutionCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

如果利用ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR的内在性质，那么它只有5个自由度。所以最少可以通过5对点来求解相机运动OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYLi2006OCOMMA Nister2004aCLOSECURLYCLOSECURLY。然而这种做法形式复杂，从工程实现角度考虑，由于平时通常会有几十对乃至上百对的匹配点，从8对减至5对意义并不明显。为保持简单，我们这里就只介绍基本的八点法。

剩下的问题还有一个：根据线性方程解出的ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR，可能不满足ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR的内在性质——它的奇异值不一定为ODOLLAROPENCURLYOBACKSLASHsigmaCLOSECURLYOCOMMA OPENCURLYOBACKSLASHsigmaCLOSECURLYOCOMMA 0ODOLLAR的形式。这时，我们会刻意地把ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHSigmaCLOSECURLYODOLLAR矩阵调整成上面的样子。通常的做法是，对八点法求得的ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR进行SVD分解后，会得到奇异值矩阵ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHSigmaCLOSECURLY OASSIGN  OBACKSLASHmathrmOPENCURLYdiagCLOSECURLY OPENBRACKET OBACKSLASHsigmaOUNDERSCORE1OCOMMA OBACKSLASHsigmaOUNDERSCORE2OCOMMA OBACKSLASHsigmaOUNDERSCORE3CLOSEBRACKETODOLLAR，不妨设ODOLLAROBACKSLASHsigmaOUNDERSCORE1 OBACKSLASHgeqslant OBACKSLASHsigmaOUNDERSCORE2 OBACKSLASHgeqslant OBACKSLASHsigmaOUNDERSCORE3ODOLLAR。取：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYECLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYUCLOSECURLY OBACKSLASHmathrmOPENCURLYdiagCLOSECURLY OPENBRACKETOBACKSLASHfracOPENCURLYOBACKSLASHsigmaOUNDERSCORE1OPLUSOBACKSLASHsigmaOUNDERSCORE2CLOSECURLYOPENCURLY2CLOSECURLYOCOMMA OBACKSLASHfracOPENCURLYOBACKSLASHsigmaOUNDERSCORE1OPLUSOBACKSLASHsigmaOUNDERSCORE2CLOSECURLYOPENCURLY2CLOSECURLYOCOMMA 0CLOSEBRACKET OBACKSLASHbmOPENCURLYVCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
这相当于是把求出来的矩阵投影到了ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR所在的流形上。当然，更简单的做法是将奇异值矩阵取成ODOLLAROBACKSLASHmathrmOPENCURLYdiagCLOSECURLY OPENBRACKET1OCOMMA1OCOMMA0CLOSEBRACKETODOLLAR，因为ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR具有尺度等价性，所以这样做也是合理的。

OBACKSLASHsubsectionOPENCURLY单应矩阵CLOSECURLY
除了基本矩阵和本质矩阵，二视图几何中还存在另一种常见的矩阵：单应矩阵（Homography）ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR，它描述了两个平面之间的映射关系。若场景中的特征点都落在同一平面上（比如墙、地面等），则可以通过单应性来进行运动估计。这种情况在无人机携带的俯视相机或扫地机携带的顶视相机中比较常见。由于之前没有提到过单应，因此这里稍微介绍一下。

单应矩阵通常描述处于共同平面上的一些点在两张图像之间的变换关系。考虑在图像ODOLLARIOUNDERSCOREOPENCURLY1CLOSECURLYODOLLAR和ODOLLARIOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR有一对匹配好的特征点ODOLLARpOUNDERSCOREOPENCURLY1CLOSECURLYODOLLAR和ODOLLARpOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR。这些特征点落在平面ODOLLARPODOLLAR上，设这个平面满足方程：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYnCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYPCLOSECURLY OPLUS d OASSIGN 0ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
稍加整理，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMINUS OBACKSLASHfracOPENCURLYOBACKSLASHbmOPENCURLYnCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYPCLOSECURLY CLOSECURLYOPENCURLYdCLOSECURLY OASSIGN 1ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

然后，回顾本节开头的式OPENBRACKET7ODOT1CLOSEBRACKET，得：
OBACKSLASHbeginOPENCURLYalignOMULTIPLYCLOSECURLY
OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2 OBANDOBACKSLASHsimeq OBACKSLASHbmOPENCURLYKCLOSECURLY OPENBRACKET OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYPCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLY CLOSEBRACKET OBACKSLASHOBACKSLASH 
OBANDOBACKSLASHsimeq OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYPCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLY OBACKSLASHcdot OPENBRACKETOMINUS OBACKSLASHfracOPENCURLYOBACKSLASHbmOPENCURLYnCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYPCLOSECURLY CLOSECURLYOPENCURLYdCLOSECURLYCLOSEBRACKET OBACKSLASHrightCLOSEBRACKET OBACKSLASHOBACKSLASH
OBANDOBACKSLASHsimeq OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYRCLOSECURLY OMINUS OBACKSLASHfracOPENCURLYOBACKSLASHbmOPENCURLYtCLOSECURLY OBACKSLASHbmOPENCURLYnCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY CLOSECURLYOPENCURLYdCLOSECURLY OBACKSLASHrightCLOSEBRACKET OBACKSLASHbmOPENCURLYPCLOSECURLY OBACKSLASHOBACKSLASH 
OBANDOBACKSLASHsimeq OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYRCLOSECURLY OMINUS OBACKSLASHfracOPENCURLYOBACKSLASHbmOPENCURLYtCLOSECURLY OBACKSLASHbmOPENCURLYnCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY CLOSECURLYOPENCURLYdCLOSECURLY OBACKSLASHrightCLOSEBRACKET OBACKSLASHbmOPENCURLYKCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1ODOT
OBACKSLASHendOPENCURLYalignOMULTIPLYCLOSECURLY

于是，我们得到了一个直接描述图像坐标ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1ODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2ODOLLAR之间的变换，把中间这部分记为ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR，于是：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2 OBACKSLASHsimeq OBACKSLASHbmOPENCURLYHCLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

它的定义与旋转、平移及平面的参数有关。与基础矩阵ODOLLAROBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR类似，单应矩阵ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR也是一个ODOLLAR3 OBACKSLASHtimes 3ODOLLAR的矩阵，求解时的思路也和ODOLLAROBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR类似，同样可以先根据匹配点计算ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR，然后将它分解以计算旋转和平移。把上式展开，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY 
uOUNDERSCOREOPENCURLY2CLOSECURLYOBACKSLASHOBACKSLASHvOUNDERSCOREOPENCURLY2CLOSECURLYOBACKSLASHOBACKSLASH1
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OBACKSLASHsimeq
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
 hOUNDERSCOREOPENCURLY1CLOSECURLY OBAND hOUNDERSCOREOPENCURLY2CLOSECURLY OBAND hOUNDERSCOREOPENCURLY3CLOSECURLYOBACKSLASHOBACKSLASH 
 hOUNDERSCOREOPENCURLY4CLOSECURLY OBAND hOUNDERSCOREOPENCURLY5CLOSECURLY OBAND hOUNDERSCOREOPENCURLY6CLOSECURLYOBACKSLASHOBACKSLASH 
 hOUNDERSCOREOPENCURLY7CLOSECURLY OBAND hOUNDERSCOREOPENCURLY8CLOSECURLY OBAND hOUNDERSCOREOPENCURLY9CLOSECURLY 
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY 
uOUNDERSCOREOPENCURLY1CLOSECURLYOBACKSLASHOBACKSLASHvOUNDERSCOREOPENCURLY1CLOSECURLYOBACKSLASHOBACKSLASH1
OBACKSLASHendOPENCURLYpmatrixCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

请注意，这里的等号依然是ODOLLAROBACKSLASHsimeqODOLLAR而不是普通的等号，所以ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵也可以乘以任意非零常数。我们在实际处理中可以令ODOLLARhOUNDERSCORE9 OASSIGN 1ODOLLAR（在它取非零值时）。然后根据第3行，去掉这个非零因子，于是有：
OBACKSLASHOPENSQUARE
OBACKSLASHbeginOPENCURLYalignedCLOSECURLY
uOUNDERSCOREOPENCURLY2CLOSECURLYOBANDOASSIGNOBACKSLASHfracOPENCURLYhOUNDERSCOREOPENCURLY1CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY2CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY3CLOSECURLYCLOSECURLYOPENCURLYhOUNDERSCOREOPENCURLY7CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY8CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY9CLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
vOUNDERSCOREOPENCURLY2CLOSECURLYOBANDOASSIGNOBACKSLASHfracOPENCURLYhOUNDERSCOREOPENCURLY4CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY5CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY6CLOSECURLYCLOSECURLYOPENCURLYhOUNDERSCOREOPENCURLY7CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY8CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY9CLOSECURLYCLOSECURLYODOT
OBACKSLASHendOPENCURLYalignedCLOSECURLY
OBACKSLASHCLOSESQUARE
整理得：
OBACKSLASHOPENSQUARE
OBACKSLASHbeginOPENCURLYgatheredCLOSECURLY
hOUNDERSCOREOPENCURLY1CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY2CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY3CLOSECURLYOMINUShOUNDERSCOREOPENCURLY7CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYuOUNDERSCOREOPENCURLY2CLOSECURLYOMINUShOUNDERSCOREOPENCURLY8CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYuOUNDERSCOREOPENCURLY2CLOSECURLYOASSIGNuOUNDERSCOREOPENCURLY2CLOSECURLYOBACKSLASHOBACKSLASH
hOUNDERSCOREOPENCURLY4CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY5CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYOPLUShOUNDERSCOREOPENCURLY6CLOSECURLYOMINUShOUNDERSCOREOPENCURLY7CLOSECURLYuOUNDERSCOREOPENCURLY1CLOSECURLYvOUNDERSCOREOPENCURLY2CLOSECURLYOMINUShOUNDERSCOREOPENCURLY8CLOSECURLYvOUNDERSCOREOPENCURLY1CLOSECURLYvOUNDERSCOREOPENCURLY2CLOSECURLYOASSIGNvOUNDERSCOREOPENCURLY2CLOSECURLYODOT
OBACKSLASHendOPENCURLYgatheredCLOSECURLY
OBACKSLASHCLOSESQUARE

这样一组匹配点对就可以构造出两项约束（事实上有三个约束，但是因为线性相关，只取前两个），于是自由度为8的单应矩阵可以通过4对匹配特征点算出（在非退化的情况下，即这些特征点不能有三点共线的情况），即求解以下的线性方程组（当ODOLLARhOUNDERSCORE9 OASSIGN 0ODOLLAR时，右侧为零）：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
uOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYOBAND vOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYOBAND 1 OBAND 0 OBAND 0 OBAND 0 OBAND OMINUSuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYuOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLY OBAND OMINUSvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYuOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLYOBACKSLASHOBACKSLASH
0 OBAND 0 OBAND 0OBAND uOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYOBAND vOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYOBAND 1 OBAND  OMINUSuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYvOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLY OBAND OMINUSvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY1CLOSECURLYvOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLYOBACKSLASHOBACKSLASH
uOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYOBAND vOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYOBAND 1 OBAND 0 OBAND 0 OBAND 0 OBAND OMINUSuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYuOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLY OBAND OMINUSvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYuOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLYOBACKSLASHOBACKSLASH
0 OBAND 0 OBAND 0OBAND uOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYOBAND vOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYOBAND 1 OBAND  OMINUSuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYvOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLY OBAND OMINUSvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY2CLOSECURLYvOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLYOBACKSLASHOBACKSLASH
uOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY3CLOSECURLYOBAND vOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY3CLOSECURLYOBAND 1 OBAND 0 OBAND 0 OBAND 0 OBAND OMINUSuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY3CLOSECURLYuOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY3CLOSECURLY OBAND OMINUSvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY3CLOSECURLYuOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY3CLOSECURLYOBACKSLASHOBACKSLASH
0 OBAND 0 OBAND 0OBAND uOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY3CLOSECURLYOBAND vOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY3CLOSECURLYOBAND 1 OBAND  OMINUSuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY3CLOSECURLYvOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY3CLOSECURLY OBAND OMINUSvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY3CLOSECURLYvOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY3CLOSECURLYOBACKSLASHOBACKSLASH
uOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY4CLOSECURLYOBAND vOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY4CLOSECURLYOBAND 1 OBAND 0 OBAND 0 OBAND 0 OBAND OMINUSuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY4CLOSECURLYuOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY4CLOSECURLY OBAND OMINUSvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY4CLOSECURLYuOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY4CLOSECURLYOBACKSLASHOBACKSLASH
0 OBAND 0 OBAND 0OBAND uOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY4CLOSECURLYOBAND vOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY4CLOSECURLYOBAND 1 OBAND  OMINUSuOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY4CLOSECURLYvOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY4CLOSECURLY OBAND OMINUSvOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLY4CLOSECURLYvOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY4CLOSECURLY
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
 hOUNDERSCOREOPENCURLY1CLOSECURLYOBACKSLASHOBACKSLASHhOUNDERSCOREOPENCURLY2CLOSECURLYOBACKSLASHOBACKSLASHhOUNDERSCOREOPENCURLY3CLOSECURLYOBACKSLASHOBACKSLASH hOUNDERSCOREOPENCURLY4CLOSECURLYOBACKSLASHOBACKSLASHhOUNDERSCOREOPENCURLY5CLOSECURLYOBACKSLASHOBACKSLASHhOUNDERSCOREOPENCURLY6CLOSECURLYOBACKSLASHOBACKSLASH hOUNDERSCOREOPENCURLY7CLOSECURLYOBACKSLASHOBACKSLASHhOUNDERSCOREOPENCURLY8CLOSECURLYOBACKSLASHOBACKSLASH  
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OASSIGN
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
uOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLYOBACKSLASHOBACKSLASH vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY1CLOSECURLYOBACKSLASHOBACKSLASH uOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLYOBACKSLASHOBACKSLASH vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY2CLOSECURLYOBACKSLASHOBACKSLASHuOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY3CLOSECURLYOBACKSLASHOBACKSLASH vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY3CLOSECURLYOBACKSLASHOBACKSLASHuOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY4CLOSECURLYOBACKSLASHOBACKSLASH vOUNDERSCOREOPENCURLY2CLOSECURLYOHATOPENCURLY4CLOSECURLY
OBACKSLASHendOPENCURLYpmatrixCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这种做法把ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR矩阵看成了向量，通过解该向量的线性方程来恢复ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR，又称直接线性变换法（Direct Linear Transform）。与本质矩阵相似，求出单应矩阵以后需要对其进行分解，才可以得到相应的旋转矩阵ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR和平移向量ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR。分解的方法包括数值法OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYfaugeras1988motionOCOMMA Zhang1996CLOSECURLYCLOSECURLY与解析法OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYmalis2007deeperCLOSECURLYCLOSECURLY。与本质矩阵的分解类似，单应矩阵的分解同样会返回4组旋转矩阵与平移向量，并且同时可以计算出它们分别对应的场景点所在平面的法向量。如果已知成像的地图点的深度全为正值（即在相机前方），则又可以排除两组解。最后仅剩两组解，这时需要通过更多的先验信息进行判断。通常我们可以通过假设已知场景平面的法向量来解决，如场景平面与相机平面平行，那么法向量ODOLLAROBACKSLASHbmOPENCURLYnCLOSECURLYODOLLAR的理论值为ODOLLAROBACKSLASHbmOPENCURLY1CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR。

单应性在SLAM中具有重要意义。当特征点共面或者相机发生纯旋转时，基础矩阵的自由度下降，这就出现了所谓的退化（degenerate）。现实中的数据总包含一些噪声，这时候如果继续使用八点法求解基础矩阵，基础矩阵多余出来的自由度将会主要由噪声决定。为了能够避免退化现象造成的影响，通常我们会同时估计基础矩阵ODOLLAROBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR和单应矩阵ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR，选择重投影误差比较小的那个作为最终的运动估计矩阵。

OBACKSLASHsectionOPENCURLY实践：对极约束求解相机运动CLOSECURLY
下面，我们来练习一下如何通过本质矩阵求解相机运动。上一节实践部分的程序提供了特征匹配，而这次我们就使用匹配好的特征点来计算ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR，进而分解ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR得到ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR。整个程序使用OpenCV提供的算法进行求解。我们把上一节的特征提取封装成函数，以供后面使用。本节只展示位姿估计部分的代码。

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch7ODIVIDEposeOUNDERSCOREestimationOUNDERSCORE2d2dODOTcpp （片段）CLOSESQUARE
void poseOUNDERSCOREestimationOUNDERSCORE2d2dOPENBRACKETstdOCOLONOCOLONvectorOGREATKeyPointOLESS keypointsOUNDERSCORE1OCOMMA
    stdOCOLONOCOLONvectorOGREATKeyPointOLESS keypointsOUNDERSCORE2OCOMMA
    stdOCOLONOCOLONvectorOGREATDMatchOLESS matchesOCOMMA
    Mat OBANDROCOMMA Mat OBANDtCLOSEBRACKET OPENCURLY
    ODIVIDEODIVIDE 相机内参OCOMMATUM Freiburg2
    Mat K OASSIGN OPENBRACKETMatOUNDERSCOREOGREATdoubleOLESSOPENBRACKET3OCOMMA 3CLOSEBRACKET OGREATOGREAT 520ODOT9OCOMMA 0OCOMMA 325ODOT1OCOMMA 0OCOMMA 521ODOT0OCOMMA 249ODOT7OCOMMA 0OCOMMA 0OCOMMA 1CLOSEBRACKETOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 把匹配点转换为vectorOGREATPoint2fOLESS的形式
    vectorOGREATPoint2fOLESS points1OSEMICOLON
    vectorOGREATPoint2fOLESS points2OSEMICOLON
    
    for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT OPENBRACKETintCLOSEBRACKET matchesODOTsizeOPENBRACKETCLOSEBRACKETOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
        points1ODOTpushOUNDERSCOREbackOPENBRACKETkeypointsOUNDERSCORE1OPENSQUAREmatchesOPENSQUAREiCLOSESQUAREODOTqueryIdxCLOSESQUAREODOTptCLOSEBRACKETOSEMICOLON
        points2ODOTpushOUNDERSCOREbackOPENBRACKETkeypointsOUNDERSCORE2OPENSQUAREmatchesOPENSQUAREiCLOSESQUAREODOTtrainIdxCLOSESQUAREODOTptCLOSEBRACKETOSEMICOLON
    CLOSECURLY
    
    ODIVIDEODIVIDEOMINUSOMINUS 计算基础矩阵
    Mat fundamentalOUNDERSCOREmatrixOSEMICOLON
    fundamentalOUNDERSCOREmatrix OASSIGN findFundamentalMatOPENBRACKETpoints1OCOMMA points2OCOMMA CVOUNDERSCOREFMOUNDERSCORE8POINTCLOSEBRACKETOSEMICOLON
    cout OGREATOGREAT "fundamentalOUNDERSCOREmatrix is " OGREATOGREAT endl OGREATOGREAT fundamentalOUNDERSCOREmatrix OGREATOGREAT endlOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 计算本质矩阵
    Point2d principalOUNDERSCOREpointOPENBRACKET325ODOT1OCOMMA 249ODOT7CLOSEBRACKETOSEMICOLON  ODIVIDEODIVIDE相机光心OCOMMA TUM dataset标定值
    double focalOUNDERSCORElength OASSIGN 521OSEMICOLON      ODIVIDEODIVIDE相机焦距OCOMMA TUM dataset标定值
    Mat essentialOUNDERSCOREmatrixOSEMICOLON
    essentialOUNDERSCOREmatrix OASSIGN findEssentialMatOPENBRACKETpoints1OCOMMA points2OCOMMA focalOUNDERSCORElengthOCOMMA principalOUNDERSCOREpointCLOSEBRACKETOSEMICOLON
    cout OGREATOGREAT "essentialOUNDERSCOREmatrix is " OGREATOGREAT endl OGREATOGREAT essentialOUNDERSCOREmatrix OGREATOGREAT endlOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 计算单应矩阵
    ODIVIDEODIVIDEOMINUSOMINUS 但是本例中场景不是平面，单应矩阵意义不大
    Mat homographyOUNDERSCOREmatrixOSEMICOLON
    homographyOUNDERSCOREmatrix OASSIGN findHomographyOPENBRACKETpoints1OCOMMA points2OCOMMA RANSACOCOMMA 3CLOSEBRACKETOSEMICOLON
    cout OGREATOGREAT "homographyOUNDERSCOREmatrix is " OGREATOGREAT endl OGREATOGREAT homographyOUNDERSCOREmatrix OGREATOGREAT endlOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 从本质矩阵中恢复旋转和平移信息ODOT
    recoverPoseOPENBRACKETessentialOUNDERSCOREmatrixOCOMMA points1OCOMMA points2OCOMMA ROCOMMA tOCOMMA focalOUNDERSCORElengthOCOMMA principalOUNDERSCOREpointCLOSEBRACKETOSEMICOLON
    cout OGREATOGREAT "R is " OGREATOGREAT endl OGREATOGREAT R OGREATOGREAT endlOSEMICOLON
    cout OGREATOGREAT "t is " OGREATOGREAT endl OGREATOGREAT t OGREATOGREAT endlOSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

该函数提供了从特征点求解相机运动的部分，然后，我们在主函数中调用它，就能得到相机的运动：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch7ODIVIDEposeOUNDERSCOREestimationOUNDERSCORE2d2dODOTcpp （片段）CLOSESQUARE
int mainOPENBRACKET int argcOCOMMA charOMULTIPLYOMULTIPLY argv CLOSEBRACKETOPENCURLY
    if OPENBRACKETargc ONOTOASSIGN 3CLOSEBRACKET OPENCURLY
        cout OGREATOGREAT "usageOCOLON poseOUNDERSCOREestimationOUNDERSCORE2d2d img1 img2" OGREATOGREAT endlOSEMICOLON
        return 1OSEMICOLON
    CLOSECURLY
    ODIVIDEODIVIDEOMINUSOMINUS 读取图像
    Mat imgOUNDERSCORE1 OASSIGN imreadOPENBRACKETargvOPENSQUARE1CLOSESQUAREOCOMMA CVOUNDERSCORELOADOUNDERSCOREIMAGEOUNDERSCORECOLORCLOSEBRACKETOSEMICOLON
    Mat imgOUNDERSCORE2 OASSIGN imreadOPENBRACKETargvOPENSQUARE2CLOSESQUAREOCOMMA CVOUNDERSCORELOADOUNDERSCOREIMAGEOUNDERSCORECOLORCLOSEBRACKETOSEMICOLON
    assertOPENBRACKETimgOUNDERSCORE1ODOTdata OBANDOBAND imgOUNDERSCORE2ODOTdata OBANDOBAND "Can not load imagesONOT"CLOSEBRACKETOSEMICOLON
    
    vectorOGREATKeyPointOLESS keypointsOUNDERSCORE1OCOMMA keypointsOUNDERSCORE2OSEMICOLON
    vectorOGREATDMatchOLESS matchesOSEMICOLON
    findOUNDERSCOREfeatureOUNDERSCOREmatchesOPENBRACKETimgOUNDERSCORE1OCOMMA imgOUNDERSCORE2OCOMMA keypointsOUNDERSCORE1OCOMMA keypointsOUNDERSCORE2OCOMMA matchesCLOSEBRACKETOSEMICOLON
    cout OGREATOGREAT "一共找到了" OGREATOGREAT matchesODOTsizeOPENBRACKETCLOSEBRACKET OGREATOGREAT "组匹配点" OGREATOGREAT endlOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 估计两张图像间运动
    Mat ROCOMMA tOSEMICOLON
    poseOUNDERSCOREestimationOUNDERSCORE2d2dOPENBRACKETkeypointsOUNDERSCORE1OCOMMA keypointsOUNDERSCORE2OCOMMA matchesOCOMMA ROCOMMA tCLOSEBRACKETOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 验证EOASSIGNtOHATROMULTIPLYscale
    Mat tOUNDERSCOREx OASSIGN
        OPENBRACKETMatOUNDERSCOREOGREATdoubleOLESSOPENBRACKET3OCOMMA 3CLOSEBRACKET OGREATOGREAT 0OCOMMA OMINUStODOTatOGREATdoubleOLESSOPENBRACKET2OCOMMA 0CLOSEBRACKETOCOMMA tODOTatOGREATdoubleOLESSOPENBRACKET1OCOMMA 0CLOSEBRACKETOCOMMA
        tODOTatOGREATdoubleOLESSOPENBRACKET2OCOMMA 0CLOSEBRACKETOCOMMA 0OCOMMA OMINUStODOTatOGREATdoubleOLESSOPENBRACKET0OCOMMA 0CLOSEBRACKETOCOMMA
        OMINUStODOTatOGREATdoubleOLESSOPENBRACKET1OCOMMA 0CLOSEBRACKETOCOMMA tODOTatOGREATdoubleOLESSOPENBRACKET0OCOMMA 0CLOSEBRACKETOCOMMA 0CLOSEBRACKETOSEMICOLON
    cout OGREATOGREAT "tOHATROASSIGN" OGREATOGREAT endl OGREATOGREAT tOUNDERSCOREx OMULTIPLY R OGREATOGREAT endlOSEMICOLON
    
    ODIVIDEODIVIDEOMINUSOMINUS 验证对极约束
    Mat K OASSIGN OPENBRACKETMatOUNDERSCOREOGREATdoubleOLESSOPENBRACKET3OCOMMA 3CLOSEBRACKET OGREATOGREAT 520ODOT9OCOMMA 0OCOMMA 325ODOT1OCOMMA 0OCOMMA 521ODOT0OCOMMA 249ODOT7OCOMMA 0OCOMMA 0OCOMMA 1CLOSEBRACKETOSEMICOLON
    for OPENBRACKETDMatch mOCOLON matchesCLOSEBRACKET OPENCURLY
        Point2d pt1 OASSIGN pixel2camOPENBRACKETkeypointsOUNDERSCORE1OPENSQUAREmODOTqueryIdxCLOSESQUAREODOTptOCOMMA KCLOSEBRACKETOSEMICOLON
        Mat y1 OASSIGN OPENBRACKETMatOUNDERSCOREOGREATdoubleOLESSOPENBRACKET3OCOMMA 1CLOSEBRACKET OGREATOGREAT pt1ODOTxOCOMMA pt1ODOTyOCOMMA 1CLOSEBRACKETOSEMICOLON
        Point2d pt2 OASSIGN pixel2camOPENBRACKETkeypointsOUNDERSCORE2OPENSQUAREmODOTtrainIdxCLOSESQUAREODOTptOCOMMA KCLOSEBRACKETOSEMICOLON
        Mat y2 OASSIGN OPENBRACKETMatOUNDERSCOREOGREATdoubleOLESSOPENBRACKET3OCOMMA 1CLOSEBRACKET OGREATOGREAT pt2ODOTxOCOMMA pt2ODOTyOCOMMA 1CLOSEBRACKETOSEMICOLON
        Mat d OASSIGN y2ODOTtOPENBRACKETCLOSEBRACKET OMULTIPLY tOUNDERSCOREx OMULTIPLY R OMULTIPLY y1OSEMICOLON
        cout OGREATOGREAT "epipolar constraint OASSIGN " OGREATOGREAT d OGREATOGREAT endlOSEMICOLON
    CLOSECURLY
    return 0OSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

我们在函数中输出了ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR的数值，然后验证了对极约束是否成立，以及ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYOHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR在非零数乘下等价的事实。现在，调用此程序即可看到输出结果：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshOCOMMAcaptionOASSIGN终端输入：CLOSESQUARE
OMODULO buildODIVIDEposeOUNDERSCOREestimationOUNDERSCORE2d2d 1ODOTpng 2ODOTpng
OMINUSOMINUS Max dist OCOLON 95ODOT000000 
OMINUSOMINUS Min dist OCOLON 4ODOT000000 
一共找到了 79 组匹配点
fundamentalOUNDERSCOREmatrix is 
OPENSQUARE4ODOT844484382466111eOMINUS06OCOMMA 0ODOT0001222601840188731OCOMMA OMINUS0ODOT01786737827487386OSEMICOLON
OMINUS0ODOT0001174326832719333OCOMMA 2ODOT122888800459598eOMINUS05OCOMMA OMINUS0ODOT01775877156212593OSEMICOLON
0ODOT01799658210895528OCOMMA 0ODOT008143605989020664OCOMMA 1CLOSESQUARE
essentialOUNDERSCOREmatrix is 
OPENSQUAREOMINUS0ODOT0203618550523477OCOMMA OMINUS0ODOT4007110038118445OCOMMA OMINUS0ODOT03324074249824097OSEMICOLON
0ODOT3939270778216369OCOMMA OMINUS0ODOT03506401846698079OCOMMA 0ODOT5857110303721015OSEMICOLON
OMINUS0ODOT006788487241438284OCOMMA OMINUS0ODOT5815434272915686OCOMMA OMINUS0ODOT01438258684486258CLOSESQUARE
homographyOUNDERSCOREmatrix is 
OPENSQUARE0ODOT9497129583105288OCOMMA OMINUS0ODOT143556453147626OCOMMA 31ODOT20121878625771OSEMICOLON
0ODOT04154536627445031OCOMMA 0ODOT9715568969832015OCOMMA 5ODOT306887618807696OSEMICOLON
OMINUS2ODOT81813676978796eOMINUS05OCOMMA 4ODOT353702039810921eOMINUS05OCOMMA 1CLOSESQUARE
R is 
OPENSQUARE0ODOT9985961798781875OCOMMA OMINUS0ODOT05169917220143662OCOMMA 0ODOT01152671359827873OSEMICOLON
0ODOT05139607508976055OCOMMA 0ODOT9983603445075083OCOMMA 0ODOT02520051547522442OSEMICOLON
OMINUS0ODOT01281065954813571OCOMMA OMINUS0ODOT02457271064688495OCOMMA 0ODOT9996159607036126CLOSESQUARE
t is 
OPENSQUAREOMINUS0ODOT8220841067933337OSEMICOLON
OMINUS0ODOT03269742706405412OSEMICOLON
0ODOT5684264241053522CLOSESQUARE

tOHATROASSIGN
OPENSQUARE0ODOT02879601157010516OCOMMA 0ODOT5666909361828478OCOMMA 0ODOT04700950886436416OSEMICOLON
OMINUS0ODOT5570970160413605OCOMMA 0ODOT0495880104673049OCOMMA OMINUS0ODOT8283204827837456OSEMICOLON
0ODOT009600370724838804OCOMMA 0ODOT8224266019846683OCOMMA 0ODOT02034004937801349CLOSESQUARE
epipolar constraint OASSIGN OPENSQUARE0ODOT002528128704106625CLOSESQUARE
epipolar constraint OASSIGN OPENSQUAREOMINUS0ODOT001663727901710724CLOSESQUARE
epipolar constraint OASSIGN OPENSQUAREOMINUS0ODOT0008009088410884102CLOSESQUARE
ODOTODOTODOTODOTODOTODOT
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

在程序的输出结果可以看出，对极约束的满足精度约在ODOLLAR10 OHATOPENCURLYOMINUS3CLOSECURLYODOLLAR量级。根据前面的讨论，分解得到的ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR一共有4种可能性。不过，OpenCV会替我们使用三角化检测角点的深度是否为正，从而选出正确的解。

OBACKSLASHsubsectionOMULTIPLYOPENCURLY讨论CLOSECURLY
从演示程序中可以看到，输出的ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR之间相差了相机内参矩阵。虽然它们在数值上并不直观，但可以验证它们的数学关系。从ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYFCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR都可以分解出运动，不过ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR需要假设特征点位于平面上。对于本实验的数据，这个假设是不好的，所以我们这里主要用ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR来分解运动。

值得一提的是，由于ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR本身具有尺度等价性，它分解得到的ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR也有一个尺度等价性。而ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHin OBACKSLASHmathrmOPENCURLYSOCLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR自身具有约束，所以我们认为ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR具有一个OBACKSLASHtextbfOPENCURLY尺度CLOSECURLY。换言之，在分解过程中，对ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR乘以任意非零常数，分解都是成立的。因此，我们通常把ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR进行OBACKSLASHtextbfOPENCURLY归一化CLOSECURLY，让它的长度等于1。

OBACKSLASHsubsubsectionOPENCURLY尺度不确定性CLOSECURLY
对ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR长度的归一化，直接导致了OBACKSLASHtextbfOPENCURLY单目视觉的尺度不确定性（Scale Ambiguity）CLOSECURLY。例如，程序中输出的ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR第一维约为0ODOT822。这个0ODOT822究竟是指0ODOT822米还是0ODOT822厘米，我们是没法确定的。因为对ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR乘以任意比例常数后，对极约束依然是成立的。换言之，在单目SLAM中，对轨迹和地图同时缩放任意倍数，我们得到的图像依然是一样的。这在第2讲中就已经向读者介绍过了。

在单目视觉中，我们对两张图像的ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR归一化相当于OBACKSLASHtextbfOPENCURLY固定了尺度CLOSECURLY。虽然我们不知道它的实际长度是多少，但我们以这时的ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR为单位1，计算相机运动和特征点的3D位置。这被称为单目SLAM的OBACKSLASHtextbfOPENCURLY初始化CLOSECURLY。在初始化之后，就可以用3D−2D来计算相机运动了。初始化之后的轨迹和地图的单位，就是初始化时固定的尺度。因此，单目SLAM有一步不可避免的OBACKSLASHtextbfOPENCURLY初始化CLOSECURLY。初始化的两张图像必须有一定程度的平移，而后的轨迹和地图都将以此步的平移为单位。

除了对ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR进行归一化之外，另一种方法是令初始化时所有的特征点平均深度为1，也可以固定一个尺度。相比于令ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR长度为1的做法，把特征点深度归一化可以控制场景的规模大小，使计算在数值上更稳定些。不过这并没有理论上的差别。

OBACKSLASHsubsubsectionOPENCURLY初始化的纯旋转问题CLOSECURLY
从ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR分解到ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR的过程中，如果相机发生的是纯旋转，导致ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR为零，那么，得到的ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR也将为零，这将导致我们无从求解ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR。不过，此时我们可以依靠ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR求取旋转，但仅有旋转时，我们无法用三角测量估计特征点的空间位置（这将在下文提到），于是，另一个结论是，OBACKSLASHtextbfOPENCURLY单目初始化不能只有纯旋转，必须要有一定程度的平移CLOSECURLY。如果没有平移，单目将无法初始化。在实践当中，如果初始化时平移太小，会使得位姿求解与三角化结果不稳定，从而导致失败。相对地，如果把相机左右移动而不是原地旋转，就容易让单目SLAM初始化。因而，有经验的SLAM研究人员，在单目SLAM情况下经常选择让相机进行左右平移以顺利地进行初始化。

OBACKSLASHsubsubsectionOPENCURLY多于8对点的情况CLOSECURLY
当给定的点数多于8对时（比如，例程找到了79对匹配），我们可以计算一个最小二乘解。回忆式OBACKSLASHeqrefOPENCURLYEqOCOLONeightOMINUSpointCLOSECURLY中线性化后的对极约束，我们把左侧的系数矩阵记为ODOLLAROBACKSLASHbmOPENCURLYACLOSECURLYODOLLAR：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYACLOSECURLY OBACKSLASHbmOPENCURLYeCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLY0CLOSECURLY ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

对于八点法，ODOLLAROBACKSLASHbmOPENCURLYACLOSECURLYODOLLAR的大小为ODOLLAR8 OBACKSLASHtimes 9ODOLLAR。如果给定的匹配点多于ODOLLAR8ODOLLAR，该方程构成一个超定方程，即不一定存在ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYODOLLAR使得上式成立。因此，可以通过最小化一个二次型来求：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHmathop OPENCURLYOBACKSLASHmin CLOSECURLYOBACKSLASHlimitsOUNDERSCOREOPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYCLOSECURLY OBACKSLASHleftOBACKSLASHOBBOR OBACKSLASHbmOPENCURLYAeCLOSECURLY OBACKSLASHrightOBACKSLASHOBBOROUNDERSCORE2OHAT2 OASSIGN OBACKSLASHmathop OPENCURLYOBACKSLASHmin CLOSECURLYOBACKSLASHlimitsOUNDERSCOREOPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYCLOSECURLY OPENCURLY OBACKSLASHbmOPENCURLYeCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYACLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OBACKSLASHbmOPENCURLYAeCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

于是就求出了在最小二乘意义下的ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR矩阵。不过，当可能存在误匹配的情况时，我们会更倾向于使用OBACKSLASHtextbfOPENCURLY随机采样一致性（Random Sample Concensus，RANSAC）CLOSECURLY来求，而不是最小二乘。RANSAC是一种通用的做法，适用于很多带错误数据的情况，可以处理带有错误匹配的数据。

OBACKSLASHsectionOPENCURLY三角测量CLOSECURLY
之前两节我们使用对极几何约束估计了相机运动，也讨论了这种方法的局限性。在得到运动之后，下一步我们需要用相机的运动估计特征点的空间位置。在单目SLAM中，仅通过单张图像无法获得像素的深度信息，我们需要通过OBACKSLASHtextbfOPENCURLY三角测量（Triangulation）（或三角化）CLOSECURLY的方法来估计地图点的深度，如OBACKSLASHautorefOPENCURLYfigOCOLONtriangluarCLOSECURLY所示。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT9OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEtriangularizationCLOSECURLY
	OBACKSLASHcaptionOPENCURLY三角化获得地图点深度。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONtriangluarCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

三角测量是指，通过在不同位置在同一个路标点进行观察，从观察到的位置推断确定路标点的距离。三角测量最早由高斯提出并应用于测量学中，它在天文学、地理学的测量中都有应用。例如，我们可以通过不同季节观察到的星星的角度，估计它离我们的距离。在SLAM中，我们主要用三角化来估计像素点的距离。

和上一节类似，考虑图像ODOLLARIOUNDERSCOREOPENCURLY1CLOSECURLYODOLLAR和ODOLLARIOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR，以左图为参考，右图的变换矩阵为ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR。相机光心为ODOLLAROOUNDERSCOREOPENCURLY1CLOSECURLYODOLLAR和ODOLLAROOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR。在ODOLLARIOUNDERSCOREOPENCURLY1CLOSECURLYODOLLAR中有特征点ODOLLARpOUNDERSCOREOPENCURLY1CLOSECURLYODOLLAR，对应ODOLLARIOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR中有特征点ODOLLARpOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR。理论上直线ODOLLAROOUNDERSCOREOPENCURLY1CLOSECURLYpOUNDERSCOREOPENCURLY1CLOSECURLYODOLLAR与ODOLLAROOUNDERSCOREOPENCURLY2CLOSECURLYpOUNDERSCOREOPENCURLY2CLOSECURLYODOLLAR在场景中会相交于一点ODOLLARPODOLLAR，该点即两个特征点所对应的地图点在三维场景中的位置。然而由于噪声的影响，这两条直线往往无法相交。因此，可以通过最二小乘法求解。

按照对极几何中的定义，设ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2ODOLLAR为两个特征点的归一化坐标，那么它们满足：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
sOUNDERSCORE2 OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2 OASSIGN sOUNDERSCORE1  OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE1 OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLYODOT  
OBACKSLASHendOPENCURLYequationCLOSECURLY

现在已知ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR，我们想要求解两个特征点的深度ODOLLARsOUNDERSCORE1OCOMMA sOUNDERSCORE2ODOLLAR。从几何上看，可以在射线ODOLLAROOUNDERSCORE1 pOUNDERSCORE1ODOLLAR上寻找3D点，使其投影位置接近ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE2ODOLLAR，同理也可以在ODOLLAROOUNDERSCORE2 pOUNDERSCORE2ODOLLAR上找，或者在两条线的中间。不同的策略对应着不同的计算方式，当然它们大同小异。比如，我们希望计算ODOLLARsOUNDERSCORE1ODOLLAR，那么先对上式两侧左乘一个ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2OHATOBACKSLASHwedgeODOLLAR，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONx1tox2CLOSECURLY
sOUNDERSCORE2 OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2OHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2 OASSIGN 0 OASSIGN sOUNDERSCORE1 OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2OHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE1 OPLUS OBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE2OHATOBACKSLASHwedge OBACKSLASHbmOPENCURLYtCLOSECURLYODOT 
OBACKSLASHendOPENCURLYequationCLOSECURLY

该式左侧为零，右侧可看成ODOLLARsOUNDERSCORE2ODOLLAR的一个方程，可以根据它直接求得ODOLLARsOUNDERSCORE2ODOLLAR。有了ODOLLARsOUNDERSCORE2ODOLLAR，ODOLLARsOUNDERSCORE1ODOLLAR也非常容易求出。于是，我们就得到了两帧下的点的深度，确定了它们的空间坐标。当然，由于噪声的存在，我们估得的ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR不一定精确使式OBACKSLASHeqrefOPENCURLYeqOCOLONx1tox2CLOSECURLY为零，所以更常见的做法是求最小二乘解而不是直接的解。

OBACKSLASHsectionOPENCURLY实践：三角测量CLOSECURLY
OBACKSLASHsubsectionOPENCURLY三角测量代码CLOSECURLY
下面，我们演示如何根据之前利用对极几何求解的相机位姿，通过三角化求出上一节特征点的空间位置。我们调用OpenCV提供的triangulation函数进行三角化。

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch7ODIVIDEtriangulationODOTcpp（片段）CLOSESQUARE
void triangulationOPENBRACKET
	const vectorOGREATKeyPointOLESS OBANDkeypointOUNDERSCORE1OCOMMA
	const vectorOGREATKeyPointOLESS OBANDkeypointOUNDERSCORE2OCOMMA
	const stdOCOLONOCOLONvectorOGREATDMatchOLESS OBANDmatchesOCOMMA
	const Mat OBANDROCOMMA const Mat OBANDtOCOMMA
	vectorOGREATPoint3dOLESS OBANDpointsCLOSEBRACKET OPENCURLY
	Mat T1 OASSIGN OPENBRACKETMatOUNDERSCOREOGREATfloatOLESSOPENBRACKET3OCOMMA 4CLOSEBRACKET OGREATOGREAT
		1OCOMMA 0OCOMMA 0OCOMMA 0OCOMMA
		0OCOMMA 1OCOMMA 0OCOMMA 0OCOMMA
		0OCOMMA 0OCOMMA 1OCOMMA 0CLOSEBRACKETOSEMICOLON
	Mat T2 OASSIGN OPENBRACKETMatOUNDERSCOREOGREATfloatOLESSOPENBRACKET3OCOMMA 4CLOSEBRACKET OGREATOGREAT
		RODOTatOGREATdoubleOLESSOPENBRACKET0OCOMMA 0CLOSEBRACKETOCOMMA RODOTatOGREATdoubleOLESSOPENBRACKET0OCOMMA 1CLOSEBRACKETOCOMMA RODOTatOGREATdoubleOLESSOPENBRACKET0OCOMMA 2CLOSEBRACKETOCOMMA tODOTatOGREATdoubleOLESSOPENBRACKET0OCOMMA 0CLOSEBRACKETOCOMMA
		RODOTatOGREATdoubleOLESSOPENBRACKET1OCOMMA 0CLOSEBRACKETOCOMMA RODOTatOGREATdoubleOLESSOPENBRACKET1OCOMMA 1CLOSEBRACKETOCOMMA RODOTatOGREATdoubleOLESSOPENBRACKET1OCOMMA 2CLOSEBRACKETOCOMMA tODOTatOGREATdoubleOLESSOPENBRACKET1OCOMMA 0CLOSEBRACKETOCOMMA
		RODOTatOGREATdoubleOLESSOPENBRACKET2OCOMMA 0CLOSEBRACKETOCOMMA RODOTatOGREATdoubleOLESSOPENBRACKET2OCOMMA 1CLOSEBRACKETOCOMMA RODOTatOGREATdoubleOLESSOPENBRACKET2OCOMMA 2CLOSEBRACKETOCOMMA tODOTatOGREATdoubleOLESSOPENBRACKET2OCOMMA 0CLOSEBRACKET
	CLOSEBRACKETOSEMICOLON
	
	Mat K OASSIGN OPENBRACKETMatOUNDERSCOREOGREATdoubleOLESSOPENBRACKET3OCOMMA 3CLOSEBRACKET OGREATOGREAT 520ODOT9OCOMMA 0OCOMMA 325ODOT1OCOMMA 0OCOMMA 521ODOT0OCOMMA 249ODOT7OCOMMA 0OCOMMA 0OCOMMA 1CLOSEBRACKETOSEMICOLON
	vectorOGREATPoint2fOLESS ptsOUNDERSCORE1OCOMMA ptsOUNDERSCORE2OSEMICOLON
	for OPENBRACKETDMatch mOCOLONmatchesCLOSEBRACKET OPENCURLY
		ODIVIDEODIVIDE 将像素坐标转换至相机坐标
		ptsOUNDERSCORE1ODOTpushOUNDERSCOREbackOPENBRACKETpixel2camOPENBRACKETkeypointOUNDERSCORE1OPENSQUAREmODOTqueryIdxCLOSESQUAREODOTptOCOMMA KCLOSEBRACKETCLOSEBRACKETOSEMICOLON
		ptsOUNDERSCORE2ODOTpushOUNDERSCOREbackOPENBRACKETpixel2camOPENBRACKETkeypointOUNDERSCORE2OPENSQUAREmODOTtrainIdxCLOSESQUAREODOTptOCOMMA KCLOSEBRACKETCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	Mat ptsOUNDERSCORE4dOSEMICOLON
	cvOCOLONOCOLONtriangulatePointsOPENBRACKETT1OCOMMA T2OCOMMA ptsOUNDERSCORE1OCOMMA ptsOUNDERSCORE2OCOMMA ptsOUNDERSCORE4dCLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDE 转换成非齐次坐标
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT ptsOUNDERSCORE4dODOTcolsOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
		Mat x OASSIGN ptsOUNDERSCORE4dODOTcolOPENBRACKETiCLOSEBRACKETOSEMICOLON
		x ODIVIDEOASSIGN xODOTatOGREATfloatOLESSOPENBRACKET3OCOMMA 0CLOSEBRACKETOSEMICOLON ODIVIDEODIVIDE 归一化
		Point3d pOPENBRACKET
			xODOTatOGREATfloatOLESSOPENBRACKET0OCOMMA 0CLOSEBRACKETOCOMMA
			xODOTatOGREATfloatOLESSOPENBRACKET1OCOMMA 0CLOSEBRACKETOCOMMA
			xODOTatOGREATfloatOLESSOPENBRACKET2OCOMMA 0CLOSEBRACKET
		CLOSEBRACKETOSEMICOLON
		pointsODOTpushOUNDERSCOREbackOPENBRACKETpCLOSEBRACKETOSEMICOLON
	CLOSECURLY
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

同时，在main函数中加入三角测量部分，然后画出各点的深度示意图。读者可以自行运行此程序查看三角化结果。

OBACKSLASHsubsectionOPENCURLY讨论CLOSECURLY
关于三角测量，还有一个必须注意的地方。

三角测量是由OBACKSLASHtextbfOPENCURLY平移CLOSECURLY得到的，有平移才会有对极几何中的三角形，才谈得上三角测量。因此，纯旋转是无法使用三角测量的，因为对极约束将永远满足。当然实际数据往往不会完全等于零。在平移存在的情况下，我们还要关心三角测量的不确定性，这会引出一个OBACKSLASHtextbfOPENCURLY三角测量的矛盾CLOSECURLY。

如OBACKSLASHautorefOPENCURLYfigOCOLONtriangulationOMINUSdiscussCLOSECURLYOTILDE所示，当平移很小时，像素上的不确定性将导致较大的深度不确定性。也就是说，如果特征点运动一个像素ODOLLAROBACKSLASHdelta xODOLLAR，使得视线角变化了一个角度ODOLLAROBACKSLASHdelta OBACKSLASHthetaODOLLAR，那么将测量到深度值有ODOLLAROBACKSLASHdelta dODOLLAR的变化。从几何关系可以看到，当ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR较大时，ODOLLAROBACKSLASHdelta dODOLLAR将明显变小，这说明平移较大时，在同样的相机分辨率下，三角化测量将更精确。对该过程的定量分析可以使用正弦定理得到。

因此，要提高三角化的精度，其一是提高特征点的提取精度，也就是提高图像分辨率——但这会导致图像变大，增加计算成本。另一方式是使平移量增大。但是，这会导致图像的OBACKSLASHtextbfOPENCURLY外观CLOSECURLY发生明显的变化，比如箱子原先被挡住的侧面显示出来，或者物体的光照发生变化，等等。外观变化会使得特征提取与匹配变得困难。总而言之，增大平移，可能导致匹配失效；而平移太小，则三角化精度不够——这就是三角化的矛盾。我们把这个问题称为“视差”（parallax）。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1ODOT0OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEtriangulationOMINUSdiscussODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLY三角测量的矛盾。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONtriangulationOMINUSdiscussCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

在单目视觉中，由于单目图像没有深度信息，我们要等待特征点被追踪几帧之后，产生了足够的视角，再用三角化来确定新增特征点的深度值。这个又时也被称为延迟三角化OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYDavison2003CLOSECURLYCLOSECURLY。但是，如果相机发生了原地旋转，导致视差很小，那么就不好估计新观测到的特征点的深度。这种情况在机器人场合下更加常见，因为原地旋转往往是一个机器人常见的指令。在这种情况下，单目视觉就可能出现追踪失败、尺度不正确等情况。

虽然本节只介绍了三角化的深度估计，但只要我们愿意，也能够定量地计算每个特征点的OBACKSLASHtextbfOPENCURLY位置CLOSECURLY及OBACKSLASHtextbfOPENCURLY不确定性CLOSECURLY。所以，如果假设特征点服从高斯分布，并且不断地对它进行观测，在信息正确的情况下，我们就能够期望OBACKSLASHtextbfOPENCURLY它的方差会不断减小乃至收敛CLOSECURLY。这就得到了一个OBACKSLASHtextbfOPENCURLY滤波器CLOSECURLY，称为OBACKSLASHtextbfOPENCURLY深度滤波器（Depth Filter）CLOSECURLY。不过，由于它的原理较复杂，我们将留到后面再详细讨论它。下面，我们来讨论从3D−2D的匹配点来估计相机运动，以及3D−3D的估计方法。

OBACKSLASHsectionOPENCURLY3D−2D：PnPCLOSECURLY
PnP（PerspectiveOMINUSnOMINUSPoint）是求解3D到2D点对运动的方法。它描述了当知道ODOLLARnODOLLAR个3D空间点及其投影位置时，如何估计相机的位姿。前面说到，2D−2D的对极几何方法需要8个或8个以上的点对（以八点法为例），且存在着初始化、纯旋转和尺度的问题。然而，如果两张图像中其中一张特征点的3D位置已知，那么最少只需3个点对（以及至少一个额外点验证结果）就可以估计相机运动。特征点的3D位置可以由三角化或者RGBOMINUSD相机的深度图确定。因此，在双目或RGBOMINUSD的视觉里程计中，我们可以直接使用PnP估计相机运动。而在单目视觉里程计中，必须先进行初始化，然后才能使用PnP。3D−2D方法不需要使用对极约束，又可以在很少的匹配点中获得较好的运动估计，是最重要的一种姿态估计方法。

PnP问题有很多种求解方法，例如，用3对点估计位姿的P3POBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYGaoHouTangEtAl2003CLOSECURLYCLOSECURLY、直接线性变换（DLT）、EPnP（Efficient PnP）OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYLepetitMorenoOMINUSNoguerFua2008CLOSECURLYCLOSECURLY、UPnPOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYPenateOMINUSSanchezAndradeOMINUSCettoMorenoOMINUSNoguer2013CLOSECURLYCLOSECURLY，等等。此外，还能用OBACKSLASHtextbfOPENCURLY非线性优化CLOSECURLY的方式，构建最小二乘问题并迭代求解，也就是万金油式的Bundle Adjustment。我们先来看DLT，然后再讲解Bundle Adjustment。

OBACKSLASHsubsectionOPENCURLY直接线性变换CLOSECURLY
我们考虑这样一个问题：已知一组3D点的位置，以及它们在某个相机中的投影位置，求该相机的位姿。这个问题也可以用于求解给定地图和图像时的相机状态问题。如果把3D点看成在另一个相机坐标系中的点的话，也可以用来求解两个相机的相对运动问题。我们从简单的问题出发。

考虑某个空间点ODOLLARPODOLLAR，它的齐次坐标为ODOLLAROPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOASSIGNOPENBRACKETXOCOMMAYOCOMMAZOCOMMA1CLOSEBRACKETOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYODOLLAR。在图像ODOLLARIOUNDERSCOREOPENCURLY1CLOSECURLYODOLLAR中，投影到特征点ODOLLAROPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLYOUNDERSCOREOPENCURLY1CLOSECURLYOASSIGNOPENBRACKETuOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAvOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMA1CLOSEBRACKETOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYODOLLAR（以归一化平面齐次坐标表示）。此时相机的位姿ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR是未知的。与单应矩阵的求解类似，我们定义增广矩阵ODOLLAROPENSQUAREOBACKSLASHbmOPENCURLYRCLOSECURLYOBBOROBACKSLASHbmOPENCURLYtCLOSECURLYCLOSESQUAREODOLLAR为一个ODOLLAR3OBACKSLASHtimes 4ODOLLAR的矩阵，包含了旋转与平移信息OBACKSLASHfootnoteOPENCURLY请注意，这和ODOLLAROBACKSLASHmathrmOPENCURLYSECLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR中的变换矩阵ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR是不同的。CLOSECURLY。我们将其展开形式列写如下：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
s
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
uOUNDERSCOREOPENCURLY1CLOSECURLY OBACKSLASHOBACKSLASH vOUNDERSCOREOPENCURLY1CLOSECURLY OBACKSLASHOBACKSLASH 1
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OASSIGN
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
tOUNDERSCOREOPENCURLY1CLOSECURLY OBAND tOUNDERSCOREOPENCURLY2CLOSECURLY OBAND tOUNDERSCOREOPENCURLY3CLOSECURLY OBAND tOUNDERSCOREOPENCURLY4CLOSECURLYOBACKSLASHOBACKSLASH 
tOUNDERSCOREOPENCURLY5CLOSECURLY OBAND tOUNDERSCOREOPENCURLY6CLOSECURLY OBAND tOUNDERSCOREOPENCURLY7CLOSECURLY OBAND tOUNDERSCOREOPENCURLY8CLOSECURLYOBACKSLASHOBACKSLASH 
tOUNDERSCOREOPENCURLY9CLOSECURLY OBAND tOUNDERSCOREOPENCURLY10CLOSECURLY OBAND tOUNDERSCOREOPENCURLY11CLOSECURLY OBAND tOUNDERSCOREOPENCURLY12CLOSECURLY
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
X OBACKSLASHOBACKSLASH Y OBACKSLASHOBACKSLASH Z OBACKSLASHOBACKSLASH 1
OBACKSLASHendOPENCURLYpmatrixCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

用最后一行把ODOLLARsODOLLAR消去，得到两个约束：
OBACKSLASHOPENSQUARE
uOUNDERSCOREOPENCURLY1CLOSECURLYOASSIGNOBACKSLASHfracOPENCURLYtOUNDERSCOREOPENCURLY1CLOSECURLYXOPLUStOUNDERSCOREOPENCURLY2CLOSECURLYYOPLUStOUNDERSCOREOPENCURLY3CLOSECURLYZOPLUStOUNDERSCOREOPENCURLY4CLOSECURLYCLOSECURLYOPENCURLYtOUNDERSCOREOPENCURLY9CLOSECURLYXOPLUStOUNDERSCOREOPENCURLY10CLOSECURLYYOPLUStOUNDERSCOREOPENCURLY11CLOSECURLYZOPLUStOUNDERSCOREOPENCURLY12CLOSECURLYCLOSECURLYOCOMMAOBACKSLASHquad
vOUNDERSCOREOPENCURLY1CLOSECURLYOASSIGNOBACKSLASHfracOPENCURLYtOUNDERSCOREOPENCURLY5CLOSECURLYXOPLUStOUNDERSCOREOPENCURLY6CLOSECURLYYOPLUStOUNDERSCOREOPENCURLY7CLOSECURLYZOPLUStOUNDERSCOREOPENCURLY8CLOSECURLYCLOSECURLYOPENCURLYtOUNDERSCOREOPENCURLY9CLOSECURLYXOPLUStOUNDERSCOREOPENCURLY10CLOSECURLYYOPLUStOUNDERSCOREOPENCURLY11CLOSECURLYZOPLUStOUNDERSCOREOPENCURLY12CLOSECURLYCLOSECURLYODOT
OBACKSLASHCLOSESQUARE

为了简化表示，定义ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR的行向量：
OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLY1CLOSECURLYOASSIGNOPENBRACKETtOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAtOUNDERSCOREOPENCURLY2CLOSECURLYOCOMMAtOUNDERSCOREOPENCURLY3CLOSECURLYOCOMMAtOUNDERSCOREOPENCURLY4CLOSECURLYCLOSEBRACKETOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOCOMMA
OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLY2CLOSECURLYOASSIGNOPENBRACKETtOUNDERSCOREOPENCURLY5CLOSECURLYOCOMMAtOUNDERSCOREOPENCURLY6CLOSECURLYOCOMMAtOUNDERSCOREOPENCURLY7CLOSECURLYOCOMMAtOUNDERSCOREOPENCURLY8CLOSECURLYCLOSEBRACKETOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOCOMMA
OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLY3CLOSECURLYOASSIGNOPENBRACKETtOUNDERSCOREOPENCURLY9CLOSECURLYOCOMMAtOUNDERSCOREOPENCURLY10CLOSECURLYOCOMMAtOUNDERSCOREOPENCURLY11CLOSECURLYOCOMMAtOUNDERSCOREOPENCURLY12CLOSECURLYCLOSEBRACKETOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOCOMMA
OBACKSLASHCLOSESQUARE
于是有：
OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE1OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYPCLOSECURLYOMINUSOBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE3OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYPCLOSECURLY uOUNDERSCORE1OASSIGN0OCOMMA
OBACKSLASHCLOSESQUARE
和
OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYPCLOSECURLYOMINUSOBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE3OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYPCLOSECURLY vOUNDERSCORE1OASSIGN0ODOT
OBACKSLASHCLOSESQUARE

请注意，ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR是待求的变量，可以看到，每个特征点提供了两个关于ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR的线性约束。假设一共有ODOLLARNODOLLAR个特征点，则可以列出如下线性方程组：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
OBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OBAND 0 OBAND OMINUSuOUNDERSCOREOPENCURLY1CLOSECURLYOBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY	OBACKSLASHOBACKSLASH
0 OBAND OBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OBAND OMINUSvOUNDERSCOREOPENCURLY1CLOSECURLYOBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREOPENCURLY1CLOSECURLYOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY	OBACKSLASHOBACKSLASH
OBACKSLASHvdots OBAND OBACKSLASHvdots OBAND OBACKSLASHvdots			OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREOPENCURLYNCLOSECURLYOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OBAND 0 OBAND OMINUSuOUNDERSCOREOPENCURLYNCLOSECURLYOBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREOPENCURLYNCLOSECURLYOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OBACKSLASHOBACKSLASH
0 OBAND OBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREOPENCURLYNCLOSECURLYOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OBAND OMINUSvOUNDERSCOREOPENCURLYNCLOSECURLYOBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREOPENCURLYNCLOSECURLYOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OBACKSLASHbeginOPENCURLYpmatrixCLOSECURLY
OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLY1CLOSECURLY OBACKSLASHOBACKSLASH OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLY2CLOSECURLY OBACKSLASHOBACKSLASH OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLY3CLOSECURLY
OBACKSLASHendOPENCURLYpmatrixCLOSECURLY
OASSIGN0ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

由于ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR一共有12维，因此，最少通过6对匹配点即可实现矩阵ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR的线性求解，这种方法称为直接线性变换（Direct Linear Transform，DLT）。当匹配点大于6对时，也可以使用SVD等方法对超定方程求最小二乘解。

在DLT求解中，我们直接将ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR矩阵看成了12个未知数，忽略了它们之间的联系。因为旋转矩阵ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHin OBACKSLASHmathrmOPENCURLYSOCLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR，用DLT求出的解不一定满足该约束，它是一个一般矩阵。平移向量比较好办，它属于向量空间。对于旋转矩阵ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR，我们必须针对DLT估计的ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR左边ODOLLAR3 OBACKSLASHtimes 3ODOLLAR的矩阵块，寻找一个最好的旋转矩阵对它进行近似。这可以由QR分解完成OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYHartley2003OCOMMA Chen1994CLOSECURLYCLOSECURLY，也可以像这样来计算OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYBarfoot2016OCOMMAGreen1952CLOSECURLYCLOSECURLY：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHleftarrow OPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOHATOPENCURLY OMINUS OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHbmOPENCURLYRCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
这相当于把结果从矩阵空间重新投影到ODOLLAROBACKSLASHmathrmOPENCURLYSECLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR流形上，转换成旋转和平移两部分。

需要解释的是，我们这里的ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYOUNDERSCORE1ODOLLAR使用了归一化平面坐标，去掉了内参矩阵ODOLLAROBACKSLASHbmOPENCURLYKCLOSECURLYODOLLAR的影响——这是因为内参ODOLLAROBACKSLASHbmOPENCURLYKCLOSECURLYODOLLAR在SLAM中通常假设为已知。即使内参未知，也能用PnP去估计ODOLLAROBACKSLASHbmOPENCURLYKCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR三个量。然而由于未知量增多，效果会差一些。

OBACKSLASHsubsectionOPENCURLYP3PCLOSECURLY
下面讲的P3P是另一种解PnP的方法。它仅使用3对匹配点，对数据要求较少，因此这里也简单介绍一下（这部分推导借鉴了文献OBACKSLASHciteOPENCURLYwebOCOLONp3pCLOSECURLY）。

P3P需要利用给定的3个点的几何关系。它的输入数据为3对3D−2D匹配点。记3D点为ODOLLARAOCOMMA BOCOMMA CODOLLAR，2D点为ODOLLARaOCOMMAbOCOMMAcODOLLAR，其中小写字母代表的点为对应大写字母代表的点在相机成像平面上的投影，如OBACKSLASHautorefOPENCURLYfigOCOLONp3pCLOSECURLYOTILDE所示。此外，P3P还需要使用一对验证点，以从可能的解中选出正确的那一个（类似于对极几何情形）。记验证点对为ODOLLARDOMINUSdODOLLAR，相机光心为ODOLLAROODOLLAR。请注意，我们知道的是ODOLLARAOCOMMABOCOMMACODOLLAR在OBACKSLASHtextbfOPENCURLY世界坐标系中的坐标CLOSECURLY，而不是OBACKSLASHtextbfOPENCURLY在相机坐标系中的坐标CLOSECURLY。一旦3D点在相机坐标系下的坐标能够算出，我们就得到了3D−3D的对应点，把PnP问题转换为了ICP问题。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT54OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEp3pODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLYP3P问题示意图。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONp3pCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

首先，显然三角形之间存在对应关系：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHDelta Oab OMINUS OBACKSLASHDelta OABOCOMMA OBACKSLASHquad OBACKSLASHDelta Obc OMINUS OBACKSLASHDelta OBCOCOMMA OBACKSLASHquad OBACKSLASHDelta Oac OMINUS OBACKSLASHDelta OACODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

来考虑ODOLLAROabODOLLAR和ODOLLAROABODOLLAR的关系。利用余弦定理，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OOPENCURLYAOHAT2CLOSECURLY OPLUS OOPENCURLYBOHAT2CLOSECURLY OMINUS 2OA OBACKSLASHcdot OB OBACKSLASHcdot OBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle aOCOMMAb OBACKSLASHright OBACKSLASHrangle  OASSIGN AOPENCURLYBOHAT2CLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

对于其他两个三角形亦有类似性质，于是有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OOPENCURLYAOHAT2CLOSECURLY OPLUS OOPENCURLYBOHAT2CLOSECURLY OMINUS 2OA OBACKSLASHcdot OB OBACKSLASHcdot OBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle aOCOMMAb OBACKSLASHright OBACKSLASHrangle  OASSIGN AOPENCURLYBOHAT2CLOSECURLYOBACKSLASHOBACKSLASH
OOPENCURLYBOHAT2CLOSECURLY OPLUS OOPENCURLYCOHAT2CLOSECURLY OMINUS 2OB OBACKSLASHcdot OC OBACKSLASHcdot OBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle bOCOMMAc OBACKSLASHright OBACKSLASHrangle  OASSIGN BOPENCURLYCOHAT2CLOSECURLYOBACKSLASHOBACKSLASH
OOPENCURLYAOHAT2CLOSECURLY OPLUS OOPENCURLYCOHAT2CLOSECURLY OMINUS 2OA OBACKSLASHcdot OC OBACKSLASHcdot OBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle aOCOMMAc OBACKSLASHright OBACKSLASHrangle  OASSIGN AOPENCURLYCOHAT2CLOSECURLYODOT
OBACKSLASHendOPENCURLYarrayCLOSECURLY
OBACKSLASHendOPENCURLYequationCLOSECURLY

对以上三式全体除以ODOLLAROCOHAT2ODOLLAR，并且记ODOLLARxOASSIGNOAODIVIDEOCOCOMMA yOASSIGNOBODIVIDEOCODOLLAR，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OPENCURLYxOHAT2CLOSECURLY OPLUS OPENCURLYyOHAT2CLOSECURLY OMINUS 2xyOBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle aOCOMMAb OBACKSLASHright OBACKSLASHrangle  OASSIGN AOPENCURLYBOHAT2CLOSECURLYODIVIDEOOPENCURLYCOHAT2CLOSECURLYOBACKSLASHOBACKSLASH
OPENCURLYyOHAT2CLOSECURLY OPLUS OPENCURLY1OHAT2CLOSECURLY OMINUS 2yOBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle bOCOMMAc OBACKSLASHright OBACKSLASHrangle  OASSIGN BOPENCURLYCOHAT2CLOSECURLYODIVIDEOOPENCURLYCOHAT2CLOSECURLYOBACKSLASHOBACKSLASH
OPENCURLYxOHAT2CLOSECURLY OPLUS OPENCURLY1OHAT2CLOSECURLY OMINUS 2xOBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle aOCOMMAc OBACKSLASHright OBACKSLASHrangle  OASSIGN AOPENCURLYCOHAT2CLOSECURLYODIVIDEOOPENCURLYCOHAT2CLOSECURLYODOT
OBACKSLASHendOPENCURLYarrayCLOSECURLY
OBACKSLASHendOPENCURLYequationCLOSECURLY

记ODOLLARv OASSIGN ABOHAT2ODIVIDEOCOHAT2OCOMMA uv OASSIGN BCOHAT2ODIVIDEOCOHAT2OCOMMA wv OASSIGN ACOHAT2ODIVIDEOCOHAT2ODOLLAR，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OPENCURLYxOHAT2CLOSECURLY OPLUS OPENCURLYyOHAT2CLOSECURLY OMINUS 2xyOBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle aOCOMMAb OBACKSLASHright OBACKSLASHrangle  OMINUS v OASSIGN 0OBACKSLASHOBACKSLASH
OPENCURLYyOHAT2CLOSECURLY OPLUS OPENCURLY1OHAT2CLOSECURLY OMINUS 2yOBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle bOCOMMAc OBACKSLASHright OBACKSLASHrangle  OMINUS uv OASSIGN 0OBACKSLASHOBACKSLASH
OPENCURLYxOHAT2CLOSECURLY OPLUS OPENCURLY1OHAT2CLOSECURLY OMINUS 2xOBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle aOCOMMAc OBACKSLASHright OBACKSLASHrangle  OMINUS wv OASSIGN 0ODOT
OBACKSLASHendOPENCURLYarrayCLOSECURLY
OBACKSLASHendOPENCURLYequationCLOSECURLY

我们可以把第一个式子中的ODOLLARvODOLLAR放到等式一边，并代入其后两式，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHleftOPENBRACKET OPENCURLY1 OMINUS uCLOSECURLY OBACKSLASHrightCLOSEBRACKETOPENCURLYyOHAT2CLOSECURLY OMINUS uOPENCURLYxOHAT2CLOSECURLY OMINUS OBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle bOCOMMAc OBACKSLASHright OBACKSLASHrangle y OPLUS 2uxyOBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle aOCOMMAb OBACKSLASHright OBACKSLASHrangle  OPLUS 1 OASSIGN 0 OBACKSLASHOBACKSLASH
OBACKSLASHleftOPENBRACKET OPENCURLY1 OMINUS wCLOSECURLY OBACKSLASHrightCLOSEBRACKETOPENCURLYxOHAT2CLOSECURLY OMINUS wOPENCURLYyOHAT2CLOSECURLY OMINUS OBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle aOCOMMAc OBACKSLASHright OBACKSLASHrangle x OPLUS 2wxyOBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle aOCOMMAb OBACKSLASHright OBACKSLASHrangle  OPLUS 1 OASSIGN 0ODOT
OBACKSLASHendOPENCURLYarrayCLOSECURLY
OBACKSLASHendOPENCURLYequationCLOSECURLY

注意这些方程中的已知量和未知量。由于我们知道2D点的图像位置，3个余弦角ODOLLAROBACKSLASHcos OBACKSLASHleft OBACKSLASHlangle aOCOMMAb OBACKSLASHright OBACKSLASHrangleODOLLAROCOMMA ODOLLAROBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle bOCOMMAc OBACKSLASHright OBACKSLASHrangleODOLLAROCOMMA ODOLLAROBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle aOCOMMAc OBACKSLASHright OBACKSLASHrangleODOLLAR是已知的。同时，ODOLLARuOASSIGNBCOHAT2ODIVIDEABOHAT2OCOMMA wOASSIGNACOHAT2ODIVIDEABOHAT2ODOLLAR可以通过ODOLLARAOCOMMABOCOMMACODOLLAR在世界坐标系下的坐标算出，变换到相机坐标系下之后，这个比值并不改变。该式中的ODOLLARxOCOMMAyODOLLAR是未知的，随着相机移动会发生变化。因此，该方程组是关于ODOLLARxOCOMMAyODOLLAR的一个二元二次方程（多项式方程）。解析地求解该方程组是一个复杂的过程，需要用吴消元法。这里不展开对该方程解法的介绍，感兴趣的读者请参阅文献OBACKSLASHciteOPENCURLYGaoHouTangEtAl2003CLOSECURLY。类似于分解ODOLLAROBACKSLASHbmOPENCURLYECLOSECURLYODOLLAR的情况，该方程最多可能得到4个解，但我们可以用验证点来计算最可能的解，得到ODOLLARAOCOMMABOCOMMACODOLLAR在相机坐标系下的3D坐标。然后，根据3D−3D的点对，计算相机的运动ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR。这部分将在7ODOT9节介绍。

从P3P的原理可以看出，为了求解PnP，我们利用了三角形相似性质，求解投影点ODOLLARaOCOMMAbOCOMMAcODOLLAR在相机坐标系下的3D坐标，最后把问题转换成一个3D到3D的位姿估计问题。在后文将看到，带有匹配信息的3D−3D位姿求解非常容易，所以这种思路是非常有效的。其他的一些方法，例如EPnP，亦采用了这种思路。然而，P3P也存在着一些问题：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem P3P只利用3个点的信息。当给定的配对点多于3组时，难以利用更多的信息。
	OBACKSLASHitem 如果3D点或2D点受噪声影响，或者存在误匹配，则算法失效。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

所以后续人们还提出了许多别的方法，如EPnP、UPnP等。它们利用更多的信息，而且用迭代的方式对相机位姿进行优化，以尽可能地消除噪声的影响。不过，相对于P3P来说，原理会更加复杂一些，所以我们建议读者阅读原始的论文，或通过实践来理解PnP过程。在SLAM当中，通常的做法是先使用P3PODIVIDEEPnP等方法估计相机位姿，然后构建最小二乘优化问题对估计值进行调整（Bundle Adjustment）。在相机运动足够连续时，也可以假设相机不动或匀速运动，用推测值作为初始值进行优化。接下来我们从非线性优化角度来看一下PnP问题。

OMODULO
OMODULOOBACKSLASHsubsubsectionOPENCURLY随机采样一致（RANSAC）CLOSECURLY
OMODULO特征匹配的环节会不可避免地出现大量的错误匹配，它们将严重影响之后姿态估计的准确度，因此我们需要设法把错误的匹配剔除。下面以八点法计算基础矩阵为例，讲解RANSAC如何执行，基础矩阵的意义与推导，及八点法将在本书的第OBACKSLASHrefOPENCURLYsecOCOLONfunmatrixCLOSECURLY节进行详细讲解。OBACKSLASHpar
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
OMODULO	OBACKSLASHitem 随机在所有匹配点对中抽取8对，设为组ODOLLARMOUNDERSCOREOPENCURLYkCLOSECURLYODOLLAROCOMMAODOLLARkOASSIGN1OCOMMA2OCOMMAODOTODOTODOTOCOMMAKODOLLAR。
OMODULO	OBACKSLASHitem 使用组ODOLLARMOUNDERSCOREOPENCURLYkCLOSECURLYODOLLAROCOMMA使用八点法计算相应的基础矩阵，ODOLLARFOUNDERSCOREOPENCURLYkCLOSECURLYODOLLAR。
OMODULO	OBACKSLASHitem 对于当前的每一个内点点对ODOLLARInOUNDERSCOREOPENCURLYiCLOSECURLYODOLLAROCOMMAODOLLARiOASSIGN1OCOMMA2OCOMMAODOTODOTODOTOCOMMAIODOLLAROCOMMA 计算ODOLLARFOUNDERSCOREOPENCURLYkCLOSECURLYODOLLAR的重投影误差ODOLLAReOUNDERSCOREOPENCURLYkCLOSECURLYODOLLAR （关于重投影误差请参阅本书第OBACKSLASHrefOPENCURLYsecOCOLONreprojectionCLOSECURLY节）。若ODOLLAReOUNDERSCOREOPENCURLYkCLOSECURLYOHATOPENCURLYiCLOSECURLYODOLLAR小于指定阈值ODOLLARthresholdODOLLAROCOMMA则判断该点对有效，对ODOLLARFOUNDERSCOREOPENCURLYkCLOSECURLYOHATOPENCURLYiCLOSECURLYODOLLAR的评分为ODOLLARscoreOUNDERSCOREOPENCURLYkCLOSECURLYOHATOPENCURLYiCLOSECURLYOASSIGNOBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLYeOUNDERSCOREOPENCURLYkCLOSECURLYOHATOPENCURLYiCLOSECURLYCLOSECURLYODOLLAR。否则将该点对从内点点对中剔除。最终对ODOLLARFOUNDERSCOREOPENCURLYkCLOSECURLYODOLLAR的评分ODOLLARscoreOUNDERSCOREOPENCURLYkCLOSECURLYODOLLAR就是所有有效点评分ODOLLARscoreOUNDERSCOREOPENCURLYkCLOSECURLYOHATOPENCURLYiCLOSECURLYODOLLAR之和。
OMODULO	OBACKSLASHitem 重复1OCOMMA2OCOMMA3步OCOMMA直到达到最大的迭代次数ODOLLARMaxIterationODOLLAR，该值手动设定。最终要取的8对匹配点就是评分最高的ODOLLARFOUNDERSCOREOPENCURLYkCLOSECURLYODOLLAR所对应的组ODOLLARMOUNDERSCOREOPENCURLYkCLOSECURLYODOLLAR。
OMODULOOBACKSLASHendOPENCURLYenumerateCLOSECURLY
OMODULO
OMODULO
OMODULO事实上RANSAC是一种算法思想，对于不同的模型，有不同的参数及评价标准。如上述例子中是基础矩阵，参数是8对匹配点，而评价标准是最小化重投影误差。理论上迭代次数越大，越有可能找到模型的最佳参数。但是由于SLAM中实时性的需要，我们需要在找到合理模型参数的情况下，迭代次数最少。假设ODOLLARuODOLLAR是找到一组内点的概率，ODOLLARvOASSIGN1OMINUSuODOLLAR是找到一组外点的概率，ODOLLARpODOLLAR是至少有一组参数不包含外点的概率（通常设为ODOLLAR99OBACKSLASHOMODULOODOLLAR），ODOLLARmODOLLAR为所需的参数数量OCOMMAODOLLARNODOLLAR为迭代次数。则有：
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULO1OMINUSpOASSIGNOPENBRACKET1OMINUSuOHATOPENCURLYmCLOSECURLYCLOSEBRACKETOHATOPENCURLYNCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULO所以最小迭代次数可以由以下式子找出，ODOLLARuODOLLAR和ODOLLARvODOLLAR通常使用经验值。
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULONOASSIGNOBACKSLASHfracOPENCURLYlogOPENBRACKET1OMINUSpCLOSEBRACKETCLOSECURLYOPENCURLY1OMINUSOPENBRACKET1OMINUSvCLOSEBRACKETOHATOPENCURLYmCLOSECURLYCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY


OBACKSLASHsubsectionOPENCURLY最小化重投影误差求解PnPCLOSECURLY
OBACKSLASHlabelOPENCURLYsecOCOLONBAOMINUSvo1CLOSECURLY
除了使用线性方法之外，我们还可以把PnP问题构建成一个关于重投影误差的非线性最小二乘问题。这将用到本书第OBACKSLASHrefOPENCURLYcptOCOLON4CLOSECURLY讲和第OBACKSLASHrefOPENCURLYcptOCOLON5CLOSECURLY讲的知识。前面说的线性方法，往往是OBACKSLASHtextbfOPENCURLY先求相机位姿，再求空间点位置CLOSECURLY，而非线性优化则是把它们都看成优化变量，放在一起优化。这是一种非常通用的求解方式，我们可以用它对PnP或ICP给出的结果进行优化。这一类OBACKSLASHtextbfOPENCURLY把相机和三维点放在一起进行最小化CLOSECURLY的问题，统称为Bundle Adjustment（光束法平差），简称为BAOBACKSLASHfootnoteOPENCURLY需要说明的是，BA在不同文献、语境下的意义并不完全一致。有些学者仅把最小化重投影误差的问题称为BA，而另一些学者的BA概念更加宽泛一些，即使这个BA只有一个相机，或加入了其他类似的传感器，可以都称为BA。我个人更喜欢宽泛一些的BA概念，所以在这里计算PnP的方法也称为BA。CLOSECURLY。

我们完全可以在PnP中构建一个Bundle Adjustment问题对相机位姿进行优化。如果相机是连续运动的（比如大多数SLAM过程），也可以直接用BA求解相机位姿。我们将在本节给出此问题在两个视图下的基本形式，然后在第9讲讨论较大规模的BA问题。

考虑ODOLLARnODOLLAR个三维空间点ODOLLARPODOLLAR及其投影ODOLLARpODOLLAR，我们希望计算相机的位姿ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR，它的李群表示为ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR。假设某空间点坐标为ODOLLAROBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREiOASSIGNOPENSQUAREXOUNDERSCOREiOCOMMAYOUNDERSCOREiOCOMMAZOUNDERSCOREiCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR，其投影的像素坐标为ODOLLAROBACKSLASHbmOPENCURLYuCLOSECURLYOUNDERSCOREiOASSIGNOPENSQUAREuOUNDERSCOREiOCOMMAvOUNDERSCOREiCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR。根据第OBACKSLASHrefOPENCURLYcptOCOLON5CLOSECURLY讲的内容，像素位置与空间点位置的关系如下：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
sOUNDERSCOREi OBACKSLASHleftOPENSQUARE 
OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
uOUNDERSCOREi OBACKSLASHOBACKSLASH vOUNDERSCOREi OBACKSLASHOBACKSLASH 1
OBACKSLASHendOPENCURLYarrayCLOSECURLY
OBACKSLASHrightCLOSESQUARE OASSIGN OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHbmOPENCURLYTCLOSECURLY OBACKSLASHleftOPENSQUARE 
OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
XOUNDERSCOREi OBACKSLASHOBACKSLASH YOUNDERSCOREi OBACKSLASHOBACKSLASH ZOUNDERSCOREi OBACKSLASHOBACKSLASH 1
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE  ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
写成矩阵形式就是：
OBACKSLASHOPENSQUARE
OPENCURLYOPENCURLYsOUNDERSCOREi OPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYCLOSECURLYOUNDERSCOREiCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHbmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREiODOT
OBACKSLASHCLOSESQUARE

这个式子隐含了一次从齐次坐标到非齐次的转换，否则按矩阵的乘法来说，维度是不对的OBACKSLASHfootnoteOPENCURLY ODOLLAR OBACKSLASHbmOPENCURLYTCLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREiCLOSECURLYODOLLAR结果是ODOLLAR4 OBACKSLASHtimes 1ODOLLAR的，而其左侧的ODOLLAROBACKSLASHbmOPENCURLYKCLOSECURLYODOLLAR是ODOLLAR3 OBACKSLASHtimes 3ODOLLAR的，所以必须把ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREiODOLLAR的前三维取出来，变成三维的非齐次坐标。或者，用ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOBACKSLASHbmOPENCURLYPCLOSECURLYOPLUSOBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR亦无不可。CLOSECURLY。现在，由于相机位姿未知及观测点的噪声，该等式存在一个误差。因此，我们把误差求和，构建最小二乘问题，然后寻找最好的相机位姿，使它最小化：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OPENCURLYOBACKSLASHbmOPENCURLYTCLOSECURLYOHATOMULTIPLYCLOSECURLY OASSIGN OBACKSLASHarg OBACKSLASHmathop OPENCURLYOBACKSLASHmin CLOSECURLYOBACKSLASHlimitsOUNDERSCOREOPENCURLYOBACKSLASHbmOPENCURLYTCLOSECURLYCLOSECURLY  OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OPENCURLYOBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLYsOUNDERSCOREiCLOSECURLY OBACKSLASHbmOPENCURLYKCLOSECURLYOBACKSLASHbmOPENCURLYTCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLYOUNDERSCOREiCLOSECURLY OBACKSLASHrightOBACKSLASHOBBOROUNDERSCORE2OHAT2CLOSECURLY ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

该问题的误差项，是将3D点的投影位置与观测位置作差，所以称为OBACKSLASHtextbfOPENCURLY重投影误差CLOSECURLY。使用齐次坐标时，这个误差有3维。不过，由于ODOLLAROPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYCLOSECURLYODOLLAR最后一维为1，该维度的误差一直为零，因而我们更多时候使用非齐次坐标，于是误差就只有2维了。如OBACKSLASHautorefOPENCURLYfigOCOLONreprojectionCLOSECURLYOTILDE所示，我们通过特征匹配知道了ODOLLARpOUNDERSCORE1ODOLLAR和ODOLLARpOUNDERSCORE2ODOLLAR是同一个空间点ODOLLARPODOLLAR的投影，但是不知道相机的位姿。在初始值中，ODOLLARPODOLLAR的投影ODOLLAROBACKSLASHhatOPENCURLYpCLOSECURLYOUNDERSCORE2ODOLLAR与实际的ODOLLARpOUNDERSCORE2ODOLLAR之间有一定的距离。于是我们调整相机的位姿，使得这个距离变小。不过，由于这个调整需要考虑很多个点，所以最后的效果是整体误差的缩小，而每个点的误差通常都不会精确为零。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT8OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEreprojectionCLOSECURLY
	OBACKSLASHcaptionOPENCURLY重投影误差示意图。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONreprojectionCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

最小二乘优化问题已经在第OBACKSLASHrefOPENCURLYcptOCOLON6CLOSECURLY讲介绍过了。使用李代数，可以构建无约束的优化问题，很方便地通过高斯牛顿法、列文伯格—马夸尔特方法等优化算法进行求解。不过，在使用高斯牛顿法和列文伯格—马夸尔特方法之前，我们需要知道每个误差项关于优化变量的导数，也就是OBACKSLASHtextbfOPENCURLY线性化CLOSECURLY：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYeCLOSECURLYOPENBRACKET OBACKSLASHbmOPENCURLYxCLOSECURLY OPLUS OBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLY CLOSEBRACKET OBACKSLASHapprox OBACKSLASHbmOPENCURLYeCLOSECURLYOPENBRACKETOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSEBRACKET OPLUS OBACKSLASHbmOPENCURLYJCLOSECURLY OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHDelta OBACKSLASHbmOPENCURLYxCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这里的ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR的形式是值得讨论的，甚至可以说是关键所在。我们固然可以使用数值导数，但如果能够推导出解析形式，则优先考虑解析导数。现在，当ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYODOLLAR为像素坐标误差（2维），ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR为相机位姿（6维）时，ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR将是一个ODOLLAR2 OBACKSLASHtimes 6ODOLLAR的矩阵。我们来推导ODOLLAROBACKSLASHbmOPENCURLYJCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR的形式。

回忆李代数的内容，我们介绍了如何使用扰动模型来求李代数的导数。首先，记变换到相机坐标系下的空间点坐标为ODOLLAROBACKSLASHbmOPENCURLYPCLOSECURLY'ODOLLAR，并且将其前3维取出来：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYPCLOSECURLY' OASSIGN OBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYTCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOUNDERSCOREOPENCURLY1OCOLON3CLOSECURLYOASSIGN OPENSQUAREX'OCOMMA Y'OCOMMA Z'CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

那么，相机投影模型相对于ODOLLAROBACKSLASHbmOPENCURLYPCLOSECURLY'ODOLLAR为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
s OPENCURLYOBACKSLASHbmOPENCURLYuCLOSECURLYCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYKCLOSECURLY OBACKSLASHbmOPENCURLYPCLOSECURLY'ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

展开：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
suOBACKSLASHOBACKSLASH
svOBACKSLASHOBACKSLASH
s
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYCLOSECURLYOBAND0OBANDOPENCURLYOPENCURLYcOUNDERSCORExCLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	0OBANDOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYcOUNDERSCOREyCLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	0OBAND0OBAND1
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREOBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
X'OBACKSLASHOBACKSLASH
Y'OBACKSLASHOBACKSLASH
Z'
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

利用第3行消去ODOLLARsODOLLAR（实际上就是ODOLLAROBACKSLASHbmOPENCURLYPCLOSECURLY'ODOLLAR的距离），得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONuv2xyzCLOSECURLY
u OASSIGN OPENCURLYfOUNDERSCORExCLOSECURLYOBACKSLASHfracOPENCURLYOPENCURLYX'CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYZ'CLOSECURLYCLOSECURLY OPLUS OPENCURLYcOUNDERSCORExCLOSECURLYOCOMMA OBACKSLASHquad v OASSIGN OPENCURLYfOUNDERSCOREyCLOSECURLYOBACKSLASHfracOPENCURLYOPENCURLYY'CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYZ'CLOSECURLYCLOSECURLY OPLUS OPENCURLYcOUNDERSCOREyCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这与第OBACKSLASHrefOPENCURLYcptOCOLON5CLOSECURLY讲的相机模型是一致的。当我们求误差时，可以把这里的ODOLLARuOCOMMAvODOLLAR与实际的测量值比较，求差。在定义了中间变量后，我们对ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR左乘扰动量ODOLLAROBACKSLASHdelta OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLYODOLLAR，然后考虑ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYODOLLAR的变化关于扰动量的导数。利用链式法则，可以列写如下：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHdelta OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYCLOSECURLY OASSIGN OBACKSLASHmathop OPENCURLYOBACKSLASHlim CLOSECURLYOBACKSLASHlimitsOUNDERSCOREOPENCURLYOBACKSLASHdelta OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLY  OBACKSLASHto 0CLOSECURLY OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHdelta OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLY  OBACKSLASHoplus OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLY OBACKSLASHrightCLOSEBRACKETOMINUSOBACKSLASHbmOPENCURLYeCLOSECURLYOPENBRACKETOBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLYCLOSEBRACKETCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHdelta OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYCLOSECURLY  OASSIGN OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYPCLOSECURLY'CLOSECURLYCLOSECURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYPCLOSECURLY'CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHdelta OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这里的ODOLLAROBACKSLASHoplusODOLLAR指李代数上的左乘扰动。第一项是误差关于投影点的导数，在式OBACKSLASHeqrefOPENCURLYeqOCOLONuv2xyzCLOSECURLY已经列出了变量之间的关系，易得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYPCLOSECURLY'CLOSECURLYCLOSECURLY OASSIGN OMINUSOBACKSLASHleftOPENSQUARE 
OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial uCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial X'CLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial uCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial Y'CLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial uCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial Z'CLOSECURLYCLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial vCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial X'CLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial vCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial Y'CLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial vCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial Z'CLOSECURLYCLOSECURLYCLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUARE 
OASSIGN OMINUS OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYZ'CLOSECURLYCLOSECURLYOBAND0OBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYX'CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZ'OHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	0OBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYZ'CLOSECURLYCLOSECURLYOBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYY'CLOSECURLYCLOSECURLYOPENCURLYZ'OHAT2CLOSECURLYCLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

而第二项为变换后的点关于李代数的导数，根据OBACKSLASHrefOPENCURLYsecOCOLONse3OMINUSdiffCLOSECURLY节中的推导，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYTPCLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHdelta OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYCLOSECURLY OASSIGN OPENCURLYOBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYTPCLOSECURLY OBACKSLASHrightCLOSEBRACKETOHAT OBACKSLASHodot CLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE 
OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYccCLOSECURLYCLOSECURLY
OBACKSLASHbmOPENCURLYICLOSECURLY OBANDOMINUS OBACKSLASHbmOPENCURLYPCLOSECURLY'OHAT OBACKSLASHwedge OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLY0CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBANDOBACKSLASHbmOPENCURLY0CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY 
OBACKSLASHendOPENCURLYarrayCLOSECURLY
OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

而在ODOLLAROBACKSLASHbmOPENCURLYPCLOSECURLY'ODOLLAR的定义中，我们取出了前3维，于是得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYPCLOSECURLY'CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHdelta OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLY OBACKSLASHbmOPENCURLYICLOSECURLYOCOMMA OMINUS OPENCURLYOBACKSLASHbmOPENCURLYPCLOSECURLY'OHAT OBACKSLASHwedge CLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

将这两项相乘，就得到了ODOLLAR2 OBACKSLASHtimes 6ODOLLAR的雅可比矩阵：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONjacobOMINUSuv2xiCLOSECURLY
OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHdelta OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYCLOSECURLY OASSIGN OMINUS OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYZ'CLOSECURLYCLOSECURLYOBAND0OBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYX'CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZ'OHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYX'Y'CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZ'OHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLY OPLUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYOPENCURLYX'OHAT2CLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZ'OHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCORExCLOSECURLYY'CLOSECURLYCLOSECURLYOPENCURLYZ'CLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	0OBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYZ'CLOSECURLYCLOSECURLYOBANDOPENCURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYY'CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZ'OHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLY OMINUS OPENCURLYfOUNDERSCOREyCLOSECURLY OMINUS OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYOPENCURLYY'OHAT2CLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZ'OHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYX'Y'CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOPENCURLYZ'OHAT2CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLYOBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYfOUNDERSCOREyCLOSECURLYX'CLOSECURLYCLOSECURLYOPENCURLYZ'CLOSECURLYCLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这个雅可比矩阵描述了重投影误差关于相机位姿李代数的一阶变化关系。我们保留了前面的负号，这是因为误差是由OBACKSLASHtextbfOPENCURLY观测值减预测值CLOSECURLY定义的。它当然也可反过来，定义成“预测值减观测值”的形式。在那种情况下，只要去掉前面的负号即可。此外，如果ODOLLAROBACKSLASHmathfrakOPENCURLYseCLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR的定义方式是旋转在前，平移在后，只要把这个矩阵的前3列与后3列对调即可。

另一方面，除了优化位姿，我们还希望优化特征点的空间位置。因此，需要讨论ODOLLAROBACKSLASHbmOPENCURLYeCLOSECURLYODOLLAR关于空间点ODOLLAROBACKSLASHbmOPENCURLYPCLOSECURLYODOLLAR的导数。所幸这个导数矩阵相对来说容易一些。仍利用链式法则，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYPCLOSECURLY CLOSECURLYCLOSECURLY OASSIGN OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYPCLOSECURLY'CLOSECURLYCLOSECURLYOBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYPCLOSECURLY'CLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYPCLOSECURLY CLOSECURLYCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

第一项在前面已推导，关于第二项，按照定义
OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYPCLOSECURLY'OASSIGN OPENBRACKETOBACKSLASHbmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYPCLOSECURLYCLOSEBRACKETOUNDERSCOREOPENCURLY1OCOLON3CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYPCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLYOCOMMA
OBACKSLASHCLOSESQUARE
我们发现ODOLLAROBACKSLASHbmOPENCURLYPCLOSECURLY'ODOLLAR对ODOLLAROBACKSLASHbmOPENCURLYPCLOSECURLYODOLLAR求导后将只剩下ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR。于是：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONjacobOMINUSuv2PCLOSECURLY
OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYPCLOSECURLY CLOSECURLYCLOSECURLY OASSIGN OMINUSOBACKSLASHleftOPENSQUARE 
OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OBACKSLASHfracOPENCURLYfOUNDERSCORExCLOSECURLYOPENCURLYZ'CLOSECURLY OBAND 0 OBANDOMINUS OBACKSLASHfracOPENCURLYfOUNDERSCOREx X'CLOSECURLYOPENCURLYZ'OHAT2CLOSECURLY OBACKSLASHOBACKSLASH
	0 OBAND OBACKSLASHfracOPENCURLYfOUNDERSCOREyCLOSECURLYOPENCURLYZ'CLOSECURLY OBAND OMINUS OBACKSLASHfracOPENCURLYfOUNDERSCOREy Y'CLOSECURLYOPENCURLYZ'OHAT2CLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OBACKSLASHbmOPENCURLYRCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

于是，我们推导出了观测相机方程关于相机位姿与特征点的两个导数矩阵。它们OBACKSLASHtextbfOPENCURLY十分重要CLOSECURLY，能够在优化过程中提供重要的梯度方向，指导优化的迭代。

OBACKSLASHsectionOPENCURLY实践：求解PnPCLOSECURLY
OBACKSLASHsubsectionOPENCURLY使用EPnP求解位姿CLOSECURLY
下面，我们通过实验理解一下PnP的过程。首先，我们演示如何使用OpenCV的EPnP求解PnP问题，然后通过非线性优化再次求解。在第二版书中，我们将增加一个手写优化的实验。由于PnP需要使用3D点，为了避免初始化带来的麻烦，我们使用了RGBOMINUSD相机中的深度图（1OUNDERSCOREdepthODOTpng）作为特征点的3D位置。首先来看OpenCV提供的PnP函数：

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch7ODIVIDEposeOUNDERSCOREestimationOUNDERSCORE3d2dODOTcpp（片段）CLOSESQUARE
int mainOPENBRACKET int argcOCOMMA charOMULTIPLYOMULTIPLY argv CLOSEBRACKET OPENCURLY
    Mat rOCOMMA tOSEMICOLON
   solvePnPOPENBRACKETptsOUNDERSCORE3dOCOMMA ptsOUNDERSCORE2dOCOMMA KOCOMMA MatOPENBRACKETCLOSEBRACKETOCOMMA rOCOMMA tOCOMMA falseCLOSEBRACKETOSEMICOLON ODIVIDEODIVIDE 调用OpenCV 的 PnP 求解，可选择EPNP，DLS等方法
   Mat ROSEMICOLON
   cvOCOLONOCOLONRodriguesOPENBRACKETrOCOMMA RCLOSEBRACKETOSEMICOLON ODIVIDEODIVIDE r为旋转向量形式，用Rodrigues公式转换为矩阵
   cout OGREATOGREAT "ROASSIGN" OGREATOGREAT endl OGREATOGREAT R OGREATOGREAT endlOSEMICOLON
   cout OGREATOGREAT "tOASSIGN" OGREATOGREAT endl OGREATOGREAT t OGREATOGREAT endlOSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

在例程中，得到配对特征点后，我们在第一个图的深度图中寻找它们的深度，并求出空间位置。以此空间位置为3D点，再以第二个图像的像素位置为2D点，调用EPnP求解PnP问题。程序输出如下：

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshOCOMMAcaptionOASSIGN终端输入：CLOSESQUARE
OMODULO buildODIVIDEposeOUNDERSCOREestimationOUNDERSCORE3d2d 1ODOTpng 2ODOTpng d1ODOTpng d2ODOTpng
OMINUSOMINUS Max dist OCOLON 95ODOT000000 
OMINUSOMINUS Min dist OCOLON 4ODOT000000 
一共找到了79组匹配点
3dOMINUS2d pairsOCOLON 76
ROASSIGN
OPENSQUARE0ODOT9978662025826269OCOMMA OMINUS0ODOT05167241613316376OCOMMA 0ODOT03991244360207524OSEMICOLON
0ODOT0505958915956335OCOMMA 0ODOT998339762771668OCOMMA 0ODOT02752769192381471OSEMICOLON
OMINUS0ODOT04126860182960625OCOMMA OMINUS0ODOT025449547736074OCOMMA 0ODOT998823919929363CLOSESQUARE
tOASSIGN
OPENSQUAREOMINUS0ODOT1272259656955879OSEMICOLON
OMINUS0ODOT007507297652615337OSEMICOLON
0ODOT06138584177157709CLOSESQUARE
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

读者可以对比先前2D−2D情况下求解的ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR看看有什么不同。可以看到，在有3D信息时，估计的ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR几乎是相同的，而ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR相差得较多。这是由于引入了新的深度信息所致。不过，由于Kinect采集的深度图本身会有一些误差，所以这里的3D点也不是准确的。在较大规模的BA中，我们会希望把位姿和所有三维特征点同时优化。


OBACKSLASHsubsectionOPENCURLY手写位姿估计CLOSECURLY
下面演示如何使用非线性优化的方式计算相机位姿。我们先手写一个高斯牛顿法的PnP，然后再演示如何调用g2o来求解。  
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch7ODIVIDEposeOUNDERSCOREestimationOUNDERSCORE3d2dODOTcpp（片段）CLOSESQUARE
void bundleAdjustmentGaussNewtonOPENBRACKET
const VecVector3d OBANDpointsOUNDERSCORE3dOCOMMA
const VecVector2d OBANDpointsOUNDERSCORE2dOCOMMA
const Mat OBANDKOCOMMA
SophusOCOLONOCOLONSE3d OBANDposeCLOSEBRACKET OPENCURLY
	typedef EigenOCOLONOCOLONMatrixOGREATdoubleOCOMMA 6OCOMMA 1OLESS Vector6dOSEMICOLON
	const int iterations OASSIGN 10OSEMICOLON
	double cost OASSIGN 0OCOMMA lastCost OASSIGN 0OSEMICOLON
	double fx OASSIGN KODOTatOGREATdoubleOLESSOPENBRACKET0OCOMMA 0CLOSEBRACKETOSEMICOLON
	double fy OASSIGN KODOTatOGREATdoubleOLESSOPENBRACKET1OCOMMA 1CLOSEBRACKETOSEMICOLON
	double cx OASSIGN KODOTatOGREATdoubleOLESSOPENBRACKET0OCOMMA 2CLOSEBRACKETOSEMICOLON
	double cy OASSIGN KODOTatOGREATdoubleOLESSOPENBRACKET1OCOMMA 2CLOSEBRACKETOSEMICOLON
	
	for OPENBRACKETint iter OASSIGN 0OSEMICOLON iter OGREAT iterationsOSEMICOLON iterOPLUSOPLUSCLOSEBRACKET OPENCURLY
		EigenOCOLONOCOLONMatrixOGREATdoubleOCOMMA 6OCOMMA 6OLESS H OASSIGN EigenOCOLONOCOLONMatrixOGREATdoubleOCOMMA 6OCOMMA 6OLESSOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
		Vector6d b OASSIGN Vector6dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
		
		cost OASSIGN 0OSEMICOLON
		ODIVIDEODIVIDE compute cost
		for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT pointsOUNDERSCORE3dODOTsizeOPENBRACKETCLOSEBRACKETOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
			EigenOCOLONOCOLONVector3d pc OASSIGN pose OMULTIPLY pointsOUNDERSCORE3dOPENSQUAREiCLOSESQUAREOSEMICOLON
			double invOUNDERSCOREz OASSIGN 1ODOT0 ODIVIDE pcOPENSQUARE2CLOSESQUAREOSEMICOLON
			double invOUNDERSCOREz2 OASSIGN invOUNDERSCOREz OMULTIPLY invOUNDERSCOREzOSEMICOLON
			EigenOCOLONOCOLONVector2d projOPENBRACKETfx OMULTIPLY pcOPENSQUARE0CLOSESQUARE ODIVIDE pcOPENSQUARE2CLOSESQUARE OPLUS cxOCOMMA fy OMULTIPLY pcOPENSQUARE1CLOSESQUARE ODIVIDE pcOPENSQUARE2CLOSESQUARE OPLUS cyCLOSEBRACKETOSEMICOLON
			EigenOCOLONOCOLONVector2d e OASSIGN pointsOUNDERSCORE2dOPENSQUAREiCLOSESQUARE OMINUS projOSEMICOLON
			cost OPLUSOASSIGN eODOTsquaredNormOPENBRACKETCLOSEBRACKETOSEMICOLON
			EigenOCOLONOCOLONMatrixOGREATdoubleOCOMMA 2OCOMMA 6OLESS JOSEMICOLON
			J OGREATOGREAT OMINUSfx OMULTIPLY invOUNDERSCOREzOCOMMA
			0OCOMMA
			fx OMULTIPLY pcOPENSQUARE0CLOSESQUARE OMULTIPLY invOUNDERSCOREz2OCOMMA
			fx OMULTIPLY pcOPENSQUARE0CLOSESQUARE OMULTIPLY pcOPENSQUARE1CLOSESQUARE OMULTIPLY invOUNDERSCOREz2OCOMMA
			OMINUSfx OMINUS fx OMULTIPLY pcOPENSQUARE0CLOSESQUARE OMULTIPLY pcOPENSQUARE0CLOSESQUARE OMULTIPLY invOUNDERSCOREz2OCOMMA
			fx OMULTIPLY pcOPENSQUARE1CLOSESQUARE OMULTIPLY invOUNDERSCOREzOCOMMA
			0OCOMMA
			OMINUSfy OMULTIPLY invOUNDERSCOREzOCOMMA
			fy OMULTIPLY pcOPENSQUARE1CLOSESQUARE OMULTIPLY invOUNDERSCOREzOCOMMA
			fy OPLUS fy OMULTIPLY pcOPENSQUARE1CLOSESQUARE OMULTIPLY pcOPENSQUARE1CLOSESQUARE OMULTIPLY invOUNDERSCOREz2OCOMMA
			OMINUSfy OMULTIPLY pcOPENSQUARE0CLOSESQUARE OMULTIPLY pcOPENSQUARE1CLOSESQUARE OMULTIPLY invOUNDERSCOREz2OCOMMA
			OMINUSfy OMULTIPLY pcOPENSQUARE0CLOSESQUARE OMULTIPLY invOUNDERSCOREzOSEMICOLON
			
			H OPLUSOASSIGN JODOTtransposeOPENBRACKETCLOSEBRACKET OMULTIPLY JOSEMICOLON
			b OPLUSOASSIGN OMINUSJODOTtransposeOPENBRACKETCLOSEBRACKET OMULTIPLY eOSEMICOLON
		CLOSECURLY
		
		Vector6d dxOSEMICOLON
		dx OASSIGN HODOTldltOPENBRACKETCLOSEBRACKETODOTsolveOPENBRACKETbCLOSEBRACKETOSEMICOLON
		
		if OPENBRACKETisnanOPENBRACKETdxOPENSQUARE0CLOSESQUARECLOSEBRACKETCLOSEBRACKET OPENCURLY
			cout OGREATOGREAT "result is nanONOT" OGREATOGREAT endlOSEMICOLON
			breakOSEMICOLON
		CLOSECURLY
		
		if OPENBRACKETiter OLESS 0 OBANDOBAND cost OLESSOASSIGN lastCostCLOSEBRACKET OPENCURLY
			ODIVIDEODIVIDE cost increaseOCOMMA update is not good
			cout OGREATOGREAT "costOCOLON " OGREATOGREAT cost OGREATOGREAT "OCOMMA last costOCOLON " OGREATOGREAT lastCost OGREATOGREAT endlOSEMICOLON
			breakOSEMICOLON
		CLOSECURLY
		
		ODIVIDEODIVIDE update your estimation
		pose OASSIGN SophusOCOLONOCOLONSE3dOCOLONOCOLONexpOPENBRACKETdxCLOSEBRACKET OMULTIPLY poseOSEMICOLON
		lastCost OASSIGN costOSEMICOLON
		
		cout OGREATOGREAT "iteration " OGREATOGREAT iter OGREATOGREAT " costOASSIGN" OGREATOGREAT coutODOTprecisionOPENBRACKET12CLOSEBRACKET OGREATOGREAT cost OGREATOGREAT endlOSEMICOLON
		if OPENBRACKETdxODOTnormOPENBRACKETCLOSEBRACKET OGREAT 1eOMINUS6CLOSEBRACKET OPENCURLY
			ODIVIDEODIVIDE converge
			breakOSEMICOLON
		CLOSECURLY
	CLOSECURLY
	
	cout OGREATOGREAT "pose by gOMINUSnOCOLON OBACKSLASHn" OGREATOGREAT poseODOTmatrixOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

在这个小函数中，我们根据前面的理论推导，实现一个简单的高斯牛顿迭代优化。之后我们将比较OpenCV、手写实现和g2o实现之间的效率差异。

OBACKSLASHsubsectionOPENCURLY使用g2o进行BA优化CLOSECURLY
在手写了一遍优化流程之后，我们再来看如何用g2o实现同样的操作（事实上用Ceres也完全类似）。g2o的基本知识在第OBACKSLASHrefOPENCURLYcptOCOLON6CLOSECURLY讲中已经介绍过了。在使用g2o之前，我们要把问题建模成一个图优化问题，如OBACKSLASHautorefOPENCURLYfigOCOLONbaOMINUSgraphCLOSECURLYOTILDE所示。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT9OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEbaOMINUSgraphCLOSECURLY
	OBACKSLASHcaptionOPENCURLYPnP的Bundle Adjustment的图优化表示。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONbaOMINUSgraphCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

在这个图优化中，节点和边的选择如下：
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem OBACKSLASHtextbfOPENCURLY节点CLOSECURLY：第二个相机的位姿节点ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLY OBACKSLASHin OBACKSLASHmathrmOPENCURLYSECLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR。
	OBACKSLASHitem OBACKSLASHtextbfOPENCURLY边CLOSECURLY：每个3D点在第二个相机中的投影，以观测方程来描述：
	OBACKSLASHOPENSQUARE
	OBACKSLASHbmOPENCURLYzCLOSECURLYOUNDERSCOREj OASSIGN hOPENBRACKETOBACKSLASHbmOPENCURLYTCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYPCLOSECURLYOUNDERSCOREOPENCURLYjCLOSECURLYCLOSEBRACKETODOT
	OBACKSLASHCLOSESQUARE
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

由于第一个相机位姿固定为零，我们没有把它写到优化变量里，但在更多的场合里，我们会考虑更多相机的估计。现在我们根据一组3D点和第二个图像中的2D投影，估计第二个相机的位姿。所以我们把第一个相机画成虚线，表明不希望考虑它。

g2o提供了许多关于BA的节点和边，例如g2oODIVIDEOBACKSLASHOBACKSLASHtypesODIVIDEsbaODIVIDEtypesOBACKSLASHOUNDERSCOREsixOBACKSLASHOUNDERSCOREdofOBACKSLASHOUNDERSCOREexpmapODOTh中提供了李代数表达的节点和边。在第二版书中，我们自己实现一个VertexPose顶点和EdgeProjection边，如下：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch7ODIVIDEposeOUNDERSCOREestimationOUNDERSCORE3d2dODOTcpp（片段）CLOSESQUARE
ODIVIDEODIVIDEODIVIDE vertex and edges used in g2o ba
class VertexPose OCOLON public g2oOCOLONOCOLONBaseVertexOGREAT6OCOMMA SophusOCOLONOCOLONSE3dOLESS OPENCURLY
	publicOCOLON
	EIGENOUNDERSCOREMAKEOUNDERSCOREALIGNEDOUNDERSCOREOPERATOROUNDERSCORENEWOSEMICOLON
	
	virtual void setToOriginImplOPENBRACKETCLOSEBRACKET override OPENCURLY
		OUNDERSCOREestimate OASSIGN SophusOCOLONOCOLONSE3dOPENBRACKETCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	ODIVIDEODIVIDEODIVIDE left multiplication on SE3
	virtual void oplusImplOPENBRACKETconst double OMULTIPLYupdateCLOSEBRACKET override OPENCURLY
		EigenOCOLONOCOLONMatrixOGREATdoubleOCOMMA 6OCOMMA 1OLESS updateOUNDERSCOREeigenOSEMICOLON
		updateOUNDERSCOREeigen OGREATOGREAT updateOPENSQUARE0CLOSESQUAREOCOMMA updateOPENSQUARE1CLOSESQUAREOCOMMA updateOPENSQUARE2CLOSESQUAREOCOMMA updateOPENSQUARE3CLOSESQUAREOCOMMA updateOPENSQUARE4CLOSESQUAREOCOMMA updateOPENSQUARE5CLOSESQUAREOSEMICOLON
		OUNDERSCOREestimate OASSIGN SophusOCOLONOCOLONSE3dOCOLONOCOLONexpOPENBRACKETupdateOUNDERSCOREeigenCLOSEBRACKET OMULTIPLY OUNDERSCOREestimateOSEMICOLON
	CLOSECURLY
	
	virtual bool readOPENBRACKETistream OBANDinCLOSEBRACKET override OPENCURLYCLOSECURLY
	
	virtual bool writeOPENBRACKETostream OBANDoutCLOSEBRACKET const override OPENCURLYCLOSECURLY
CLOSECURLYOSEMICOLON

class EdgeProjection OCOLON public g2oOCOLONOCOLONBaseUnaryEdgeOGREAT2OCOMMA EigenOCOLONOCOLONVector2dOCOMMA VertexPoseOLESS OPENCURLY
	publicOCOLON
	EIGENOUNDERSCOREMAKEOUNDERSCOREALIGNEDOUNDERSCOREOPERATOROUNDERSCORENEWOSEMICOLON
	
	EdgeProjectionOPENBRACKETconst EigenOCOLONOCOLONVector3d OBANDposOCOMMA const EigenOCOLONOCOLONMatrix3d OBANDKCLOSEBRACKET OCOLON OUNDERSCOREpos3dOPENBRACKETposCLOSEBRACKETOCOMMA OUNDERSCOREKOPENBRACKETKCLOSEBRACKET OPENCURLYCLOSECURLY
	
	virtual void computeErrorOPENBRACKETCLOSEBRACKET override OPENCURLY
		const VertexPose OMULTIPLYv OASSIGN staticOUNDERSCOREcastOGREATVertexPose OMULTIPLYOLESS OPENBRACKETOUNDERSCOREverticesOPENSQUARE0CLOSESQUARECLOSEBRACKETOSEMICOLON
		SophusOCOLONOCOLONSE3d T OASSIGN vOMINUSOLESSestimateOPENBRACKETCLOSEBRACKETOSEMICOLON
		EigenOCOLONOCOLONVector3d posOUNDERSCOREpixel OASSIGN OUNDERSCOREK OMULTIPLY OPENBRACKETT OMULTIPLY OUNDERSCOREpos3dCLOSEBRACKETOSEMICOLON
		posOUNDERSCOREpixel ODIVIDEOASSIGN posOUNDERSCOREpixelOPENSQUARE2CLOSESQUAREOSEMICOLON
		OUNDERSCOREerror OASSIGN OUNDERSCOREmeasurement OMINUS posOUNDERSCOREpixelODOTheadOGREAT2OLESSOPENBRACKETCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	virtual void linearizeOplusOPENBRACKETCLOSEBRACKET override OPENCURLY
		const VertexPose OMULTIPLYv OASSIGN staticOUNDERSCOREcastOGREATVertexPose OMULTIPLYOLESS OPENBRACKETOUNDERSCOREverticesOPENSQUARE0CLOSESQUARECLOSEBRACKETOSEMICOLON
		SophusOCOLONOCOLONSE3d T OASSIGN vOMINUSOLESSestimateOPENBRACKETCLOSEBRACKETOSEMICOLON
		EigenOCOLONOCOLONVector3d posOUNDERSCOREcam OASSIGN T OMULTIPLY OUNDERSCOREpos3dOSEMICOLON
		double fx OASSIGN OUNDERSCOREKOPENBRACKET0OCOMMA 0CLOSEBRACKETOSEMICOLON
		double fy OASSIGN OUNDERSCOREKOPENBRACKET1OCOMMA 1CLOSEBRACKETOSEMICOLON
		double cx OASSIGN OUNDERSCOREKOPENBRACKET0OCOMMA 2CLOSEBRACKETOSEMICOLON
		double cy OASSIGN OUNDERSCOREKOPENBRACKET1OCOMMA 2CLOSEBRACKETOSEMICOLON
		double X OASSIGN posOUNDERSCOREcamOPENSQUARE0CLOSESQUAREOSEMICOLON
		double Y OASSIGN posOUNDERSCOREcamOPENSQUARE1CLOSESQUAREOSEMICOLON
		double Z OASSIGN posOUNDERSCOREcamOPENSQUARE2CLOSESQUAREOSEMICOLON
		double Z2 OASSIGN Z OMULTIPLY ZOSEMICOLON
		OUNDERSCOREjacobianOplusXi
		OGREATOGREAT OMINUSfx ODIVIDE ZOCOMMA 0OCOMMA fx OMULTIPLY X ODIVIDE Z2OCOMMA fx OMULTIPLY X OMULTIPLY Y ODIVIDE Z2OCOMMA OMINUSfx OMINUS fx OMULTIPLY X OMULTIPLY X ODIVIDE Z2OCOMMA fx OMULTIPLY Y ODIVIDE ZOCOMMA
		0OCOMMA OMINUSfy ODIVIDE ZOCOMMA fy OMULTIPLY Y ODIVIDE OPENBRACKETZ OMULTIPLY ZCLOSEBRACKETOCOMMA fy OPLUS fy OMULTIPLY Y OMULTIPLY Y ODIVIDE Z2OCOMMA OMINUSfy OMULTIPLY X OMULTIPLY Y ODIVIDE Z2OCOMMA OMINUSfy OMULTIPLY X ODIVIDE ZOSEMICOLON
	CLOSECURLY
	
	virtual bool readOPENBRACKETistream OBANDinCLOSEBRACKET override OPENCURLYCLOSECURLY
	
	virtual bool writeOPENBRACKETostream OBANDoutCLOSEBRACKET const override OPENCURLYCLOSECURLY
	
	privateOCOLON
	EigenOCOLONOCOLONVector3d OUNDERSCOREpos3dOSEMICOLON
	EigenOCOLONOCOLONMatrix3d OUNDERSCOREKOSEMICOLON
CLOSECURLYOSEMICOLON
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

这里实现了顶点的更新和边的误差计算。下面就是将它们组成一个图优化问题：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch7ODIVIDEposeOUNDERSCOREestimationOUNDERSCORE3d2dODOTcpp（片段）CLOSESQUARE
void bundleAdjustmentG2OOPENBRACKET
const VecVector3d OBANDpointsOUNDERSCORE3dOCOMMA
const VecVector2d OBANDpointsOUNDERSCORE2dOCOMMA
const Mat OBANDKOCOMMA
SophusOCOLONOCOLONSE3d OBANDposeCLOSEBRACKET OPENCURLY
	ODIVIDEODIVIDE 构建图优化，先设定g2o
	typedef g2oOCOLONOCOLONBlockSolverOGREATg2oOCOLONOCOLONBlockSolverTraitsOGREAT6OCOMMA 3OLESSOLESS BlockSolverTypeOSEMICOLON  ODIVIDEODIVIDE pose is 6OCOMMA landmark is 3
	typedef g2oOCOLONOCOLONLinearSolverDenseOGREATBlockSolverTypeOCOLONOCOLONPoseMatrixTypeOLESS LinearSolverTypeOSEMICOLON ODIVIDEODIVIDE 线性求解器类型
	ODIVIDEODIVIDE 梯度下降方法，可以从GNOCOMMA LMOCOMMA DogLeg 中选
	auto solver OASSIGN new g2oOCOLONOCOLONOptimizationAlgorithmsGaussNewtonOPENBRACKET
		g2oOCOLONOCOLONmakeOUNDERSCOREuniqueOGREATBlockSolverTypeOLESSOPENBRACKETg2oOCOLONOCOLONmakeOUNDERSCOREuniqueOGREATLinearSolverTypeOLESSOPENBRACKETCLOSEBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
	g2oOCOLONOCOLONSparseOptimizer optimizerOSEMICOLON     ODIVIDEODIVIDE 图模型
	optimizerODOTsetAlgorithmOPENBRACKETsolverCLOSEBRACKETOSEMICOLON   ODIVIDEODIVIDE 设置求解器
	optimizerODOTsetVerboseOPENBRACKETtrueCLOSEBRACKETOSEMICOLON       ODIVIDEODIVIDE 打开调试输出
	
	ODIVIDEODIVIDE vertex
	VertexPose OMULTIPLYvertexOUNDERSCOREpose OASSIGN new VertexPoseOPENBRACKETCLOSEBRACKETOSEMICOLON ODIVIDEODIVIDE camera vertexOUNDERSCOREpose
	vertexOUNDERSCOREposeOMINUSOLESSsetIdOPENBRACKET0CLOSEBRACKETOSEMICOLON
	vertexOUNDERSCOREposeOMINUSOLESSsetEstimateOPENBRACKETSophusOCOLONOCOLONSE3dOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
	optimizerODOTaddVertexOPENBRACKETvertexOUNDERSCOREposeCLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDE K
	EigenOCOLONOCOLONMatrix3d KOUNDERSCOREeigenOSEMICOLON
	KOUNDERSCOREeigen OGREATOGREAT
	KODOTatOGREATdoubleOLESSOPENBRACKET0OCOMMA 0CLOSEBRACKETOCOMMA KODOTatOGREATdoubleOLESSOPENBRACKET0OCOMMA 1CLOSEBRACKETOCOMMA KODOTatOGREATdoubleOLESSOPENBRACKET0OCOMMA 2CLOSEBRACKETOCOMMA
	KODOTatOGREATdoubleOLESSOPENBRACKET1OCOMMA 0CLOSEBRACKETOCOMMA KODOTatOGREATdoubleOLESSOPENBRACKET1OCOMMA 1CLOSEBRACKETOCOMMA KODOTatOGREATdoubleOLESSOPENBRACKET1OCOMMA 2CLOSEBRACKETOCOMMA
	KODOTatOGREATdoubleOLESSOPENBRACKET2OCOMMA 0CLOSEBRACKETOCOMMA KODOTatOGREATdoubleOLESSOPENBRACKET2OCOMMA 1CLOSEBRACKETOCOMMA KODOTatOGREATdoubleOLESSOPENBRACKET2OCOMMA 2CLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDE edges
	int index OASSIGN 1OSEMICOLON
	for OPENBRACKETsizeOUNDERSCOREt i OASSIGN 0OSEMICOLON i OGREAT pointsOUNDERSCORE2dODOTsizeOPENBRACKETCLOSEBRACKETOSEMICOLON OPLUSOPLUSiCLOSEBRACKET OPENCURLY
		auto p2d OASSIGN pointsOUNDERSCORE2dOPENSQUAREiCLOSESQUAREOSEMICOLON
		auto p3d OASSIGN pointsOUNDERSCORE3dOPENSQUAREiCLOSESQUAREOSEMICOLON
		EdgeProjection OMULTIPLYedge OASSIGN new EdgeProjectionOPENBRACKETp3dOCOMMA KOUNDERSCOREeigenCLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetIdOPENBRACKETindexCLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetVertexOPENBRACKET0OCOMMA vertexOUNDERSCOREposeCLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetMeasurementOPENBRACKETp2dCLOSEBRACKETOSEMICOLON
		edgeOMINUSOLESSsetInformationOPENBRACKETEigenOCOLONOCOLONMatrix2dOCOLONOCOLONIdentityOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
		optimizerODOTaddEdgeOPENBRACKETedgeCLOSEBRACKETOSEMICOLON
		indexOPLUSOPLUSOSEMICOLON
	CLOSECURLY
	
	chronoOCOLONOCOLONsteadyOUNDERSCOREclockOCOLONOCOLONtimeOUNDERSCOREpoint t1 OASSIGN chronoOCOLONOCOLONsteadyOUNDERSCOREclockOCOLONOCOLONnowOPENBRACKETCLOSEBRACKETOSEMICOLON
	optimizerODOTsetVerboseOPENBRACKETtrueCLOSEBRACKETOSEMICOLON
	optimizerODOTinitializeOptimizationOPENBRACKETCLOSEBRACKETOSEMICOLON
	optimizerODOToptimizeOPENBRACKET10CLOSEBRACKETOSEMICOLON
	chronoOCOLONOCOLONsteadyOUNDERSCOREclockOCOLONOCOLONtimeOUNDERSCOREpoint t2 OASSIGN chronoOCOLONOCOLONsteadyOUNDERSCOREclockOCOLONOCOLONnowOPENBRACKETCLOSEBRACKETOSEMICOLON
	chronoOCOLONOCOLONdurationOGREATdoubleOLESS timeOUNDERSCOREused OASSIGN chronoOCOLONOCOLONdurationOUNDERSCOREcastOGREATchronoOCOLONOCOLONdurationOGREATdoubleOLESSOLESSOPENBRACKETt2 OMINUS t1CLOSEBRACKETOSEMICOLON
	cout OGREATOGREAT "optimization costs timeOCOLON " OGREATOGREAT timeOUNDERSCOREusedODOTcountOPENBRACKETCLOSEBRACKET OGREATOGREAT " secondsODOT" OGREATOGREAT endlOSEMICOLON
	cout OGREATOGREAT "pose estimated by g2o OASSIGNOBACKSLASHn" OGREATOGREAT vertexOUNDERSCOREposeOMINUSOLESSestimateOPENBRACKETCLOSEBRACKETODOTmatrixOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
	pose OASSIGN vertexOUNDERSCOREposeOMINUSOLESSestimateOPENBRACKETCLOSEBRACKETOSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

程序大体上和第6讲的g2o类似。我们首先声明了g2o图优化器，并配置优化求解器和梯度下降方法。然后根据估计到的特征点，将位姿和空间点放到图中。最后调用优化函数进行求解。最后，运行的部分输出如下：

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshOCOMMAcaptionOASSIGN终端输入：CLOSESQUARE
ODOTODIVIDEbuildODIVIDEposeOUNDERSCOREestimationOUNDERSCORE3d2d 1ODOTpng 2ODOTpng 1OUNDERSCOREdepthODOTpng 2OUNDERSCOREdepthODOTpng
OMINUSOMINUS Max dist OCOLON 95ODOT000000 
OMINUSOMINUS Min dist OCOLON 4ODOT000000 
一共找到了79组匹配点
3dOMINUS2d pairsOCOLON 76
solve pnp in opencv cost timeOCOLON 0ODOT000332991 secondsODOT
ROASSIGN
OPENSQUARE0ODOT9978662025826269OCOMMA OMINUS0ODOT05167241613316376OCOMMA 0ODOT03991244360207524OSEMICOLON
0ODOT0505958915956335OCOMMA 0ODOT998339762771668OCOMMA 0ODOT02752769192381471OSEMICOLON
OMINUS0ODOT04126860182960625OCOMMA OMINUS0ODOT025449547736074OCOMMA 0ODOT998823919929363CLOSESQUARE
tOASSIGN
OPENSQUAREOMINUS0ODOT1272259656955879OSEMICOLON
OMINUS0ODOT007507297652615337OSEMICOLON
0ODOT06138584177157709CLOSESQUARE
calling bundle adjustment by gauss newton
iteration 0 costOASSIGN645538ODOT1857253
iteration 1 costOASSIGN12750ODOT239874896
iteration 2 costOASSIGN12301ODOT774589343
iteration 3 costOASSIGN12301ODOT427574651
iteration 4 costOASSIGN12301ODOT426806652
pose by gOMINUSnOCOLON 
0ODOT99786618832  OMINUS0ODOT0516873580423    0ODOT039893448423   OMINUS0ODOT127218696289
0ODOT0506143671126    0ODOT998340854865   0ODOT0274540224544 OMINUS0ODOT00738695798083
OMINUS0ODOT0412462852904  OMINUS0ODOT0253762590968    0ODOT998826706403   0ODOT0617019263823
0                 0                 0                 1
solve pnp by gauss newton cost timeOCOLON 0ODOT000159492 secondsODOT
calling bundle adjustment by g2o
iterationOASSIGN 0	 chi2OASSIGN 413ODOT390599	 timeOASSIGN 2ODOT7291eOMINUS05	 cumTimeOASSIGN 2ODOT7291eOMINUS05	 edgesOASSIGN 76	 schurOASSIGN 0	 lambdaOASSIGN 79ODOT000412	 levenbergIterOASSIGN 1
iterationOASSIGN 1	 chi2OASSIGN 301ODOT367030	 timeOASSIGN 1ODOT47eOMINUS05	 cumTimeOASSIGN 4ODOT1991eOMINUS05	 edgesOASSIGN 76	 schurOASSIGN 0	 lambdaOASSIGN 26ODOT333471	 levenbergIterOASSIGN 1
iterationOASSIGN 2	 chi2OASSIGN 301ODOT365779	 timeOASSIGN 1ODOT7794eOMINUS05	 cumTimeOASSIGN 5ODOT9785eOMINUS05	 edgesOASSIGN 76	 schurOASSIGN 0	 lambdaOASSIGN 17ODOT555647	 levenbergIterOASSIGN 1
iterationOASSIGN 3	 chi2OASSIGN 301ODOT365779	 timeOASSIGN 1ODOT4875eOMINUS05	 cumTimeOASSIGN 7ODOT466eOMINUS05	 edgesOASSIGN 76	 schurOASSIGN 0	 lambdaOASSIGN 11ODOT703765	 levenbergIterOASSIGN 1
iterationOASSIGN 4	 chi2OASSIGN 301ODOT365779	 timeOASSIGN 1ODOT3132eOMINUS05	 cumTimeOASSIGN 8ODOT7792eOMINUS05	 edgesOASSIGN 76	 schurOASSIGN 0	 lambdaOASSIGN 7ODOT802510	 levenbergIterOASSIGN 1
iterationOASSIGN 5	 chi2OASSIGN 301ODOT365779	 timeOASSIGN 2ODOT0379eOMINUS05	 cumTimeOASSIGN 0ODOT000108171	 edgesOASSIGN 76	 schurOASSIGN 0	 lambdaOASSIGN 41ODOT613386	 levenbergIterOASSIGN 3
iterationOASSIGN 6	 chi2OASSIGN 301ODOT365779	 timeOASSIGN 3ODOT4186eOMINUS05	 cumTimeOASSIGN 0ODOT000142357	 edgesOASSIGN 76	 schurOASSIGN 0	 lambdaOASSIGN 2859650082279ODOT672363	 levenbergIterOASSIGN 8
optimization costs timeOCOLON 0ODOT000763649 secondsODOT
pose estimated by g2o OASSIGN
0ODOT997866202583  OMINUS0ODOT0516724161336   0ODOT0399124436024   OMINUS0ODOT127225965696
0ODOT050595891596    0ODOT998339762772   0ODOT0275276919261 OMINUS0ODOT00750729765631
OMINUS0ODOT04126860183  OMINUS0ODOT0254495477384    0ODOT998823919929   0ODOT0613858417711
0                 0                 0                 1
solve pnp by g2o cost timeOCOLON 0ODOT000923095 secondsODOT
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

从估计结果上看，三者基本一致。从优化时间来看， 我们自己实现的高斯牛顿法以0ODOT15毫秒排在第一，其次是OpenCV的PnP，最后是g2o的实现。尽管如此，三者的用时都在1毫秒以内，这说明位姿估计算法并不耗费计算量。

Bundle Adjustment是一种通用的做法。它可以不限于两幅图像。我们完全可以放入多幅图像匹配到的位姿和空间点进行迭代优化，甚至可以把整个SLAM过程放进来。那种做法规模较大，主要在后端使用，我们会在第10讲再次遇到这个问题。在前端，我们通常考虑局部相机位姿和特征点的小型Bundle Adjustment问题，希望对它进行实时求解和优化。

OBACKSLASHsectionOPENCURLY3D−3D：ICPCLOSECURLY
最后，我们来介绍3D−3D的位姿估计问题。假设我们有一组配对好的3D点（比如我们对两幅RGBOMINUSD图像进行了匹配）：
OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYPCLOSECURLY OASSIGN OBACKSLASHOPENCURLY OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHcdotsOCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREn OBACKSLASHCLOSECURLYOCOMMA OBACKSLASHquad OBACKSLASHbmOPENCURLYPCLOSECURLY' OASSIGN OBACKSLASHOPENCURLY OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCORE1'OCOMMA OBACKSLASHcdotsOCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREn'OBACKSLASHCLOSECURLYOCOMMA
OBACKSLASHCLOSESQUARE
现在，想要找一个欧氏变换ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR，使得OBACKSLASHfootnoteOPENCURLY这个例子和前两章的符号稍有不同。如果把它们关联起来的话，那么把ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiODOLLAR看成第二个图像中的数据，把ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREi'ODOLLAR看成第一个图像中的数据，得到的ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR是一致的。CLOSECURLY：
OBACKSLASHOPENSQUARE
OBACKSLASHforall iOCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREi OASSIGN OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREi' OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLYODOT
OBACKSLASHCLOSESQUARE

这个问题可以用迭代最近点（Iterative Closest Point，ICP）求解。读者应该注意到了，3D−3D位姿估计问题中并没有出现相机模型，也就是说，仅考虑两组3D点之间的变换时，和相机并没有关系。因此，在激光SLAM中也会碰到ICP，不过由于激光数据特征不够丰富，我们无从知道两个点集之间的OBACKSLASHtextbfOPENCURLY匹配关系CLOSECURLY，只能认为距离最近的两个点为同一个，所以这个方法称为迭代最近点。而在视觉中，特征点为我们提供了较好的匹配关系，所以整个问题就变得更简单了。在RGBOMINUSD SLAM中，可以用这种方式估计相机位姿。下文我们用ICP指代OBACKSLASHtextbfOPENCURLY匹配好的CLOSECURLY两组点间的运动估计问题。

和PnP类似，ICP的求解也分为两种方式：利用线性代数的求解（主要是SVD）， 以及利用非线性优化方式的求解（类似于Bundle Adjustment）。下面分别进行介绍。

OBACKSLASHsubsectionOPENCURLYSVD方法CLOSECURLY
首先来看以SVD为代表的代数方法。根据前面描述的ICP问题，我们先定义第ODOLLARiODOLLAR对点的误差项：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCOREi OASSIGN OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREi OMINUS OPENBRACKETOBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREi' OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLY CLOSEBRACKET ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

然后，构建最小二乘问题，求使误差平方和达到极小的ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHmathop OPENCURLYOBACKSLASHmin CLOSECURLYOBACKSLASHlimitsOUNDERSCOREOPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYCLOSECURLY OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLY OBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATnOBACKSLASHOBBOR OPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY' OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHOBBOROHAT2OUNDERSCORE2ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

下面来推导它的求解方法。首先，定义两组点的质心：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYpCLOSECURLY OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLYnCLOSECURLYOBACKSLASHsumOUNDERSCOREOPENCURLYiOASSIGN1CLOSECURLYOHATn OPENBRACKET OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREi CLOSEBRACKETOCOMMA OBACKSLASHquad OBACKSLASHbmOPENCURLYpCLOSECURLY' OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLYnCLOSECURLY OBACKSLASHsumOUNDERSCOREOPENCURLYiOASSIGN1CLOSECURLYOHATn OPENBRACKET OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREi' CLOSEBRACKETODOT 
OBACKSLASHendOPENCURLYequationCLOSECURLY

请注意，质心是没有下标的。随后，在误差函数中做如下的处理：
OBACKSLASHbeginOPENCURLYalignOMULTIPLYCLOSECURLY
OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYllCLOSECURLY
OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OPENCURLYOPENCURLYOPENCURLYOBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOPENCURLY OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY' OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHrightOBACKSLASHOBBORCLOSECURLYOHAT2CLOSECURLYCLOSECURLY  OBAND OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OPENCURLYOPENCURLYOPENCURLYOBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY' OMINUS OBACKSLASHbmOPENCURLYtCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYRpCLOSECURLY' OPLUS OBACKSLASHbmOPENCURLYpCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRpCLOSECURLY'CLOSECURLY OBACKSLASHrightOBACKSLASHOBBORCLOSECURLYOHAT2CLOSECURLYCLOSECURLY OBACKSLASHOBACKSLASH
 OBAND OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OPENCURLYOPENCURLYOPENCURLYOBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY' OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY'CLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRpCLOSECURLY' OMINUS OBACKSLASHbmOPENCURLYtCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHrightOBACKSLASHOBBORCLOSECURLYOHAT2CLOSECURLYCLOSECURLY OBACKSLASHOBACKSLASH
OBAND OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OPENBRACKET OPENCURLYOPENCURLYOBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY' OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY'CLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHrightOBACKSLASHOBBORCLOSECURLYOHAT2CLOSECURLY OPLUS OPENCURLYOPENCURLYOBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRpCLOSECURLY' OMINUS OBACKSLASHbmOPENCURLYtCLOSECURLYCLOSECURLY OBACKSLASHrightOBACKSLASHOBBORCLOSECURLYOHAT2CLOSECURLY OPLUSOBACKSLASHOBACKSLASH
 OBAND OBACKSLASHquad OBACKSLASHquad 2OPENCURLYOPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY' OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY'CLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLYOHATTCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRpCLOSECURLY' OMINUS OBACKSLASHbmOPENCURLYtCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSEBRACKETODOT 
OBACKSLASHendOPENCURLYarrayCLOSECURLY
OBACKSLASHendOPENCURLYalignOMULTIPLYCLOSECURLY

注意到交叉项部分中ODOLLAROBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY' OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY'CLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHrightCLOSEBRACKETODOLLAR在求和之后为零，因此优化目标函数可以简化为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHmathop OPENCURLYOBACKSLASHmin CLOSECURLYOBACKSLASHlimitsOUNDERSCOREOPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYCLOSECURLY J OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OPENCURLYOPENCURLYOBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRCLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREiCLOSECURLY' OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY'CLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHrightOBACKSLASHOBBORCLOSECURLYOHAT2CLOSECURLY OPLUS OPENCURLYOPENCURLYOBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRpCLOSECURLY' OMINUS OBACKSLASHbmOPENCURLYtCLOSECURLYCLOSECURLY OBACKSLASHrightOBACKSLASHOBBORCLOSECURLYOHAT2CLOSECURLY ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

仔细观察左右两项，我们发现左边只和旋转矩阵ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR相关，而右边既有ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR也有ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR，但只和质心相关。只要我们获得了ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR，令第二项为零就能得到ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR。于是，ICP可以分为以下三个步骤求解：

OBACKSLASHbeginOPENCURLYmdframedCLOSECURLY
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 计算两组点的质心位置ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYpCLOSECURLY'ODOLLAR，然后计算每个点的OBACKSLASHtextbfOPENCURLY去质心坐标CLOSECURLY：
	OBACKSLASHOPENSQUARE
	OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREi OASSIGN OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREi OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLYOCOMMA OBACKSLASHquad OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREi' OASSIGN OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREi' OMINUS OBACKSLASHbmOPENCURLYpCLOSECURLY'ODOT
	OBACKSLASHCLOSESQUARE
	OBACKSLASHitem 根据以下优化问题计算旋转矩阵：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
		OBACKSLASHbmOPENCURLYRCLOSECURLYOHATOMULTIPLY OASSIGN OBACKSLASHarg OBACKSLASHmathop OPENCURLYOBACKSLASHmin CLOSECURLYOBACKSLASHlimitsOUNDERSCOREOPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYCLOSECURLY OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OPENCURLYOPENCURLYOBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREi' CLOSECURLY OBACKSLASHrightOBACKSLASHOBBORCLOSECURLYOHAT2CLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	OBACKSLASHitem 根据第2步的ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR计算ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHlabelOPENCURLYeqOCOLONpnpOMINUSsolveOMINUStCLOSECURLY
	OBACKSLASHbmOPENCURLYtCLOSECURLYOHATOMULTIPLY OASSIGN OBACKSLASHbmOPENCURLYpCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLY'ODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
OBACKSLASHendOPENCURLYenumerateCLOSECURLY
OBACKSLASHendOPENCURLYmdframedCLOSECURLY
	
我们看到，只要求出了两组点之间的旋转，平移量是非常容易得到的。所以我们重点关注ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR的计算。展开关于ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR的误差项，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
 OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREi' CLOSECURLY OBACKSLASHrightOBACKSLASHOBBOROHAT2 OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREiOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREi OPLUS OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREiOHATOPENCURLY OBACKSLASHprime OBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY  OBACKSLASHbmOPENCURLYRCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOBACKSLASHprimeOUNDERSCOREi OMINUS 2OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREiOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOBACKSLASHprimeOUNDERSCOREiODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

注意到第一项和ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR无关，第二项由于ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOASSIGNOBACKSLASHbmOPENCURLYICLOSECURLYODOLLAR，亦与ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR无关。因此，实际上优化目标函数变为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OMINUS OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREiOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOBACKSLASHprimeOUNDERSCOREi OASSIGN OBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OMINUSOBACKSLASHmathrmOPENCURLYtrCLOSECURLY OBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREiOHATOPENCURLYOBACKSLASHprimeCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOUNDERSCOREi OBACKSLASHrightCLOSEBRACKET OASSIGN OMINUS OBACKSLASHmathrmOPENCURLYtrCLOSECURLY OBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREiOHATOPENCURLYOBACKSLASHprimeCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOUNDERSCOREi OBACKSLASH OBACKSLASHrightCLOSEBRACKETODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

接下来，我们介绍怎样通过SVD解出上述问题中最优的ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR。关于最优性的证明较为复杂，感兴趣的读者请参考文献OBACKSLASHciteOPENCURLYArun1987OCOMMA PomerleauColasSiegwart2015CLOSECURLY。为了解ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR，先定义矩阵：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYWCLOSECURLY OASSIGN  OBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATn OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREi OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOBACKSLASHprime OBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOUNDERSCOREiODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

ODOLLAROBACKSLASHbmOPENCURLYWCLOSECURLYODOLLAR是一个ODOLLAR3 OBACKSLASHtimes 3ODOLLAR的矩阵，对ODOLLAROBACKSLASHbmOPENCURLYWCLOSECURLYODOLLAR进行SVD分解，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYWCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYU OBACKSLASHSigma VCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

其中，ODOLLAROBACKSLASHbmOPENCURLYOBACKSLASHSigmaCLOSECURLYODOLLAR为奇异值组成的对角矩阵，对角线元素从大到小排列，而ODOLLAROBACKSLASHbmOPENCURLYUCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYVCLOSECURLYODOLLAR为对角矩阵。当ODOLLAROBACKSLASHbmOPENCURLYWCLOSECURLYODOLLAR满秩时，ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR为
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYRCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYUCLOSECURLY OBACKSLASHbmOPENCURLYVCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

解得ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR后，按式OBACKSLASHeqrefOPENCURLYeqOCOLONpnpOMINUSsolveOMINUStCLOSECURLY求解ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR即可。如果此时ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR的行列式为负取，则取ODOLLAROMINUSOBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR作为最优值。

OBACKSLASHsubsectionOPENCURLY非线性优化方法CLOSECURLY
求解ICP的另一种方式是使用非线性优化，以迭代的方式去找最优值。该方法和我们前面讲述的PnP非常相似。以李代数表达位姿时，目标函数可以写成
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHmathop OPENCURLYOBACKSLASHmin CLOSECURLYOBACKSLASHlimitsOUNDERSCOREOPENCURLYOBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLYCLOSECURLY OASSIGN OBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLY2CLOSECURLY OBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHATnOBACKSLASHOBBOR OPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYCLOSECURLYOUNDERSCOREiCLOSECURLY OMINUS OBACKSLASHexp OBACKSLASHleftOPENBRACKET OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLYOHATOBACKSLASHwedge OBACKSLASHrightCLOSEBRACKET OPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYCLOSECURLY'OUNDERSCOREiCLOSECURLY OBACKSLASHrightCLOSEBRACKETCLOSECURLY OBACKSLASHOBBOROHAT2OUNDERSCORE2ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

单个误差项关于位姿的导数在前面已推导，使用李代数扰动模型即可：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHbmOPENCURLYeCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLYOBACKSLASHpartial OBACKSLASHdelta OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLY CLOSECURLYCLOSECURLY OASSIGN  OMINUS OPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOBACKSLASHexp OBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLY OBACKSLASHboldsymbolOPENCURLYOBACKSLASHxiCLOSECURLY OHAT OBACKSLASHwedge CLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYpCLOSECURLYCLOSECURLYOUNDERSCOREiCLOSECURLY'CLOSECURLY OBACKSLASHrightCLOSEBRACKETOHAT OBACKSLASHodot CLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

于是，在非线性优化中只需不断迭代，就能找到极小值。而且，可以证明OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYBarfoot2016CLOSECURLYCLOSECURLY，ICP问题存在唯一解或无穷多解的情况。在唯一解的情况下，只要能找到极小值解，那么OBACKSLASHtextbfOPENCURLY这个极小值就是全局最优值CLOSECURLY——因此不会遇到局部极小而非全局最小的情况。这也意味着ICP求解可以任意选定初始值。这是已匹配点时求解ICP的一大好处。

需要说明的是，我们这里讲的ICP是指已由图像特征给定了匹配的情况下进行位姿估计的问题。在匹配已知的情况下，这个最小二乘问题实际上具有解析解OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYFaugeras1986OCOMMA Horn1987OCOMMA Sharp2002CLOSECURLYCLOSECURLY，所以并没有必要进行迭代优化。ICP的研究者们往往更加关心匹配未知的情况。那么，为什么我们要介绍基于优化的ICP呢？这是因为，某些场合下，例如在RGBOMINUSD SLAM中，一个像素的深度数据可能有，也可能测量不到，所以我们可以混合着使用PnP和ICP优化：对于深度已知的特征点，建模它们的3D−3D误差；对于深度未知的特征点，则建模3D−2D的重投影误差。于是，可以将所有的误差放在同一个问题中考虑，使得求解更加方便。

OBACKSLASHsectionOPENCURLY实践：求解ICPCLOSECURLY
OBACKSLASHsubsectionOPENCURLYSVD方法CLOSECURLY
下面演示一下如何使用SVD及非线性优化来求解ICP。本节我们使用两幅RGBOMINUSD图像，通过特征匹配获取两组3D点，最后用ICP计算它们的位姿变换。由于OpenCV目前还没有计算两组带匹配点的ICP的方法，而且它的原理也并不复杂，所以我们自己来实现一个ICP。
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch7ODIVIDEposeOBACKSLASHOUNDERSCOREestimationOBACKSLASHOUNDERSCORE3d3dODOTcpp（片段）CLOSESQUARE
void poseOUNDERSCOREestimationOUNDERSCORE3d3dOPENBRACKET
const vectorOGREATPoint3fOLESS OBANDpts1OCOMMA
const vectorOGREATPoint3fOLESS OBANDpts2OCOMMA
Mat OBANDROCOMMA Mat OBANDtCLOSEBRACKET OPENCURLY
	Point3f p1OCOMMA p2OSEMICOLON     ODIVIDEODIVIDE center of mass
	int N OASSIGN pts1ODOTsizeOPENBRACKETCLOSEBRACKETOSEMICOLON
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT NOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
		p1 OPLUSOASSIGN pts1OPENSQUAREiCLOSESQUAREOSEMICOLON
		p2 OPLUSOASSIGN pts2OPENSQUAREiCLOSESQUAREOSEMICOLON
	CLOSECURLY
	p1 OASSIGN Point3fOPENBRACKETVec3fOPENBRACKETp1CLOSEBRACKET ODIVIDE NCLOSEBRACKETOSEMICOLON
	p2 OASSIGN Point3fOPENBRACKETVec3fOPENBRACKETp2CLOSEBRACKET ODIVIDE NCLOSEBRACKETOSEMICOLON
	vectorOGREATPoint3fOLESS q1OPENBRACKETNCLOSEBRACKETOCOMMA q2OPENBRACKETNCLOSEBRACKETOSEMICOLON ODIVIDEODIVIDE remove the center
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT NOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
		q1OPENSQUAREiCLOSESQUARE OASSIGN pts1OPENSQUAREiCLOSESQUARE OMINUS p1OSEMICOLON
		q2OPENSQUAREiCLOSESQUARE OASSIGN pts2OPENSQUAREiCLOSESQUARE OMINUS p2OSEMICOLON
	CLOSECURLY
	
	ODIVIDEODIVIDE compute q1OMULTIPLYq2OHATT
	EigenOCOLONOCOLONMatrix3d W OASSIGN EigenOCOLONOCOLONMatrix3dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT NOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
		W OPLUSOASSIGN EigenOCOLONOCOLONVector3dOPENBRACKETq1OPENSQUAREiCLOSESQUAREODOTxOCOMMA q1OPENSQUAREiCLOSESQUAREODOTyOCOMMA q1OPENSQUAREiCLOSESQUAREODOTzCLOSEBRACKET OMULTIPLY EigenOCOLONOCOLONVector3dOPENBRACKETq2OPENSQUAREiCLOSESQUAREODOTxOCOMMA q2OPENSQUAREiCLOSESQUAREODOTyOCOMMA q2OPENSQUAREiCLOSESQUAREODOTzCLOSEBRACKETODOTtransposeOPENBRACKETCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	cout OGREATOGREAT "WOASSIGN" OGREATOGREAT W OGREATOGREAT endlOSEMICOLON
	
	ODIVIDEODIVIDE SVD on W
	EigenOCOLONOCOLONJacobiSVDOGREATEigenOCOLONOCOLONMatrix3dOLESS svdOPENBRACKETWOCOMMA EigenOCOLONOCOLONComputeFullU OBBOR EigenOCOLONOCOLONComputeFullVCLOSEBRACKETOSEMICOLON
	EigenOCOLONOCOLONMatrix3d U OASSIGN svdODOTmatrixUOPENBRACKETCLOSEBRACKETOSEMICOLON
	EigenOCOLONOCOLONMatrix3d V OASSIGN svdODOTmatrixVOPENBRACKETCLOSEBRACKETOSEMICOLON
	
	cout OGREATOGREAT "UOASSIGN" OGREATOGREAT U OGREATOGREAT endlOSEMICOLON
	cout OGREATOGREAT "VOASSIGN" OGREATOGREAT V OGREATOGREAT endlOSEMICOLON
	
	EigenOCOLONOCOLONMatrix3d ROUNDERSCORE OASSIGN U OMULTIPLY OPENBRACKETVODOTtransposeOPENBRACKETCLOSEBRACKETCLOSEBRACKETOSEMICOLON
	if OPENBRACKETROUNDERSCOREODOTdeterminantOPENBRACKETCLOSEBRACKET OGREAT 0CLOSEBRACKET OPENCURLY
		ROUNDERSCORE OASSIGN OMINUSROUNDERSCOREOSEMICOLON
	CLOSECURLY
	EigenOCOLONOCOLONVector3d tOUNDERSCORE OASSIGN EigenOCOLONOCOLONVector3dOPENBRACKETp1ODOTxOCOMMA p1ODOTyOCOMMA p1ODOTzCLOSEBRACKET OMINUS ROUNDERSCORE OMULTIPLY EigenOCOLONOCOLONVector3dOPENBRACKETp2ODOTxOCOMMA p2ODOTyOCOMMA p2ODOTzCLOSEBRACKETOSEMICOLON
	
	ODIVIDEODIVIDE convert to cvOCOLONOCOLONMat
	R OASSIGN OPENBRACKETMatOUNDERSCOREOGREATdoubleOLESSOPENBRACKET3OCOMMA 3CLOSEBRACKET OGREATOGREAT
		ROUNDERSCOREOPENBRACKET0OCOMMA 0CLOSEBRACKETOCOMMA ROUNDERSCOREOPENBRACKET0OCOMMA 1CLOSEBRACKETOCOMMA ROUNDERSCOREOPENBRACKET0OCOMMA 2CLOSEBRACKETOCOMMA
		ROUNDERSCOREOPENBRACKET1OCOMMA 0CLOSEBRACKETOCOMMA ROUNDERSCOREOPENBRACKET1OCOMMA 1CLOSEBRACKETOCOMMA ROUNDERSCOREOPENBRACKET1OCOMMA 2CLOSEBRACKETOCOMMA
		ROUNDERSCOREOPENBRACKET2OCOMMA 0CLOSEBRACKETOCOMMA ROUNDERSCOREOPENBRACKET2OCOMMA 1CLOSEBRACKETOCOMMA ROUNDERSCOREOPENBRACKET2OCOMMA 2CLOSEBRACKET
	CLOSEBRACKETOSEMICOLON
	t OASSIGN OPENBRACKETMatOUNDERSCOREOGREATdoubleOLESSOPENBRACKET3OCOMMA 1CLOSEBRACKET OGREATOGREAT tOUNDERSCOREOPENBRACKET0OCOMMA 0CLOSEBRACKETOCOMMA tOUNDERSCOREOPENBRACKET1OCOMMA 0CLOSEBRACKETOCOMMA tOUNDERSCOREOPENBRACKET2OCOMMA 0CLOSEBRACKETCLOSEBRACKETOSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

ICP的实现方式和前文讲述的是一致的。我们调用Eigen进行SVD，然后计算ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR矩阵。我们输出了匹配后的结果，不过请注意，由于前面的推导是按照ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREi OASSIGN OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREi' OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR进行的，这里的ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR是第二帧到第一帧的变换，与前面PnP部分是相反的。所以在输出结果中，我们同时打印了逆变换：

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshOCOMMAcaptionOASSIGN终端输入：CLOSESQUARE
ODOTODIVIDEbuildODIVIDEposeOUNDERSCOREestimationOUNDERSCORE3d3d 1ODOTpng 2ODOTpng 1OUNDERSCOREdepthODOTpng 2OUNDERSCOREdepthODOTpng
OMINUSOMINUS Max dist OCOLON 95ODOT000000 
OMINUSOMINUS Min dist OCOLON 4ODOT000000 
一共找到了79组匹配点
3dOMINUS3d pairsOCOLON 74
WOASSIGN  11ODOT9404 OMINUS0ODOT567258   1ODOT64182
OMINUS1ODOT79283   4ODOT31299  OMINUS6ODOT57615
3ODOT12791  OMINUS6ODOT55815   10ODOT8576
UOASSIGN  0ODOT474144  OMINUS0ODOT880373 OMINUS0ODOT0114952
OMINUS0ODOT460275  OMINUS0ODOT258979   0ODOT849163
0ODOT750556   0ODOT397334   0ODOT528006
VOASSIGN  0ODOT535211  OMINUS0ODOT844064 OMINUS0ODOT0332488
OMINUS0ODOT434767  OMINUS0ODOT309001    0ODOT84587
0ODOT724242   0ODOT438263   0ODOT532352
ICP via SVD resultsOCOLON 
R OASSIGN OPENSQUARE0ODOT9972395977366739OCOMMA 0ODOT05617039856770099OCOMMA OMINUS0ODOT04855997354553433OSEMICOLON
OMINUS0ODOT05598345194682017OCOMMA 0ODOT9984181427731508OCOMMA 0ODOT005202431117423125OSEMICOLON
0ODOT0487753812298326OCOMMA OMINUS0ODOT002469515369266572OCOMMA 0ODOT9988067198811421CLOSESQUARE
t OASSIGN OPENSQUARE0ODOT1417248739257469OSEMICOLON
OMINUS0ODOT05551033302525193OSEMICOLON
OMINUS0ODOT03119093188273858CLOSESQUARE
ROUNDERSCOREinv OASSIGN OPENSQUARE0ODOT9972395977366739OCOMMA OMINUS0ODOT05598345194682017OCOMMA 0ODOT0487753812298326OSEMICOLON
0ODOT05617039856770099OCOMMA 0ODOT9984181427731508OCOMMA OMINUS0ODOT002469515369266572OSEMICOLON
OMINUS0ODOT04855997354553433OCOMMA 0ODOT005202431117423125OCOMMA 0ODOT9988067198811421CLOSESQUARE
tOUNDERSCOREinv OASSIGN OPENSQUAREOMINUS0ODOT1429199667309695OSEMICOLON
0ODOT04738475446275858OSEMICOLON
0ODOT03832465717628181CLOSESQUARE
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

读者可以比较一下ICP与PnP、对极几何的运动估计结果之间的差异。可以认为，在这个过程中我们使用了越来越多的信息（没有深度—有一个图的深度—有两个图的深度），因此，在深度准确的情况下，得到的估计也将越来越准确。但是，由于Kinect的深度图存在噪声，而且有可能存在数据丢失的情况，我们不得不丢弃一些没有深度数据的特征点。这可能导致ICP的估计不够准确，并且，如果特征点丢弃得太多，可能引起由于特征点太少，无法进行运动估计的情况。

OBACKSLASHsubsectionOPENCURLY非线性优化方法CLOSECURLY
下面考虑用非线性优化来计算ICP。我们依然使用李代数来优化相机位姿。对我们来说，RGBOMINUSD相机每次可以观测到路标点的三维位置，从而产生一个3D观测数据。我们使用上一个实验中的VertexPose，然后定义3DOMINUS3D的一元边：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch7ODIVIDEposeOBACKSLASHOUNDERSCOREestimationOBACKSLASHOUNDERSCORE3d3dODOTcppCLOSESQUARE

ODIVIDEODIVIDEODIVIDE g2o edge
class EdgeProjectXYZRGBDPoseOnly OCOLON public g2oOCOLONOCOLONBaseUnaryEdgeOGREAT3OCOMMA EigenOCOLONOCOLONVector3dOCOMMA VertexPoseOLESS OPENCURLY
	publicOCOLON
	EIGENOUNDERSCOREMAKEOUNDERSCOREALIGNEDOUNDERSCOREOPERATOROUNDERSCORENEWOSEMICOLON
	
	EdgeProjectXYZRGBDPoseOnlyOPENBRACKETconst EigenOCOLONOCOLONVector3d OBANDpointCLOSEBRACKET OCOLON OUNDERSCOREpointOPENBRACKETpointCLOSEBRACKET OPENCURLYCLOSECURLY
	
	virtual void computeErrorOPENBRACKETCLOSEBRACKET override OPENCURLY
		const VertexPose OMULTIPLYpose OASSIGN staticOUNDERSCOREcastOGREATconst VertexPose OMULTIPLYOLESS OPENBRACKET OUNDERSCOREverticesOPENSQUARE0CLOSESQUARE CLOSEBRACKETOSEMICOLON
		OUNDERSCOREerror OASSIGN OUNDERSCOREmeasurement OMINUS poseOMINUSOLESSestimateOPENBRACKETCLOSEBRACKET OMULTIPLY OUNDERSCOREpointOSEMICOLON
	CLOSECURLY
	
	virtual void linearizeOplusOPENBRACKETCLOSEBRACKET override OPENCURLY
		VertexPose OMULTIPLYpose OASSIGN staticOUNDERSCOREcastOGREATVertexPose OMULTIPLYOLESSOPENBRACKETOUNDERSCOREverticesOPENSQUARE0CLOSESQUARECLOSEBRACKETOSEMICOLON
		SophusOCOLONOCOLONSE3d T OASSIGN poseOMINUSOLESSestimateOPENBRACKETCLOSEBRACKETOSEMICOLON
		EigenOCOLONOCOLONVector3d xyzOUNDERSCOREtrans OASSIGN T OMULTIPLY OUNDERSCOREpointOSEMICOLON
		OUNDERSCOREjacobianOplusXiODOTblockOGREAT3OCOMMA 3OLESSOPENBRACKET0OCOMMA 0CLOSEBRACKET OASSIGN OMINUSEigenOCOLONOCOLONMatrix3dOCOLONOCOLONIdentityOPENBRACKETCLOSEBRACKETOSEMICOLON
		OUNDERSCOREjacobianOplusXiODOTblockOGREAT3OCOMMA 3OLESSOPENBRACKET0OCOMMA 3CLOSEBRACKET OASSIGN SophusOCOLONOCOLONSO3dOCOLONOCOLONhatOPENBRACKETxyzOUNDERSCOREtransCLOSEBRACKETOSEMICOLON
	CLOSECURLY
	
	bool readOPENBRACKETistream OBANDinCLOSEBRACKET OPENCURLYCLOSECURLY
	
	bool writeOPENBRACKETostream OBANDoutCLOSEBRACKET const OPENCURLYCLOSECURLY
	
	protectedOCOLON
	EigenOCOLONOCOLONVector3d OUNDERSCOREpointOSEMICOLON
CLOSECURLYOSEMICOLON
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

这是一个一元边，写法类似于前面提到的g2oOCOLONOCOLONEdgeSE3ProjectXYZ，不过观测量从2维变成了3维，内部没有相机模型，并且只关联到一个节点。请读者注意这里雅可比矩阵的书写，它必须与我们前面的推导一致。雅可比矩阵给出了关于相机位姿的导数，是一个ODOLLAR3 OBACKSLASHtimes 6ODOLLAR的矩阵。

调用g2o进行优化的代码是相似的，我们设定好图优化的节点和边即可。这部分代码请读者查看源文件，这里不再列出。现在，来看看优化的结果：

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshOCOMMA captionOASSIGN终端输出：CLOSESQUARE
iterationOASSIGN 0	 chi2OASSIGN 1ODOT811539	 timeOASSIGN 1ODOT7046eOMINUS05	 cumTimeOASSIGN 1ODOT7046eOMINUS05	 edgesOASSIGN 74	 schurOASSIGN 0
iterationOASSIGN 1	 chi2OASSIGN 1ODOT811051	 timeOASSIGN 1ODOT0422eOMINUS05	 cumTimeOASSIGN 2ODOT7468eOMINUS05	 edgesOASSIGN 74	 schurOASSIGN 0
iterationOASSIGN 2	 chi2OASSIGN 1ODOT811050	 timeOASSIGN 9ODOT589eOMINUS06	 cumTimeOASSIGN 3ODOT7057eOMINUS05	 edgesOASSIGN 74	 schurOASSIGN 0
ODOTODOTODOT中间略
iterationOASSIGN 9	 chi2OASSIGN 1ODOT811050	 timeOASSIGN 9ODOT113eOMINUS06	 cumTimeOASSIGN 0ODOT000100604	 edgesOASSIGN 74	 schurOASSIGN 0
optimization costs timeOCOLON 0ODOT000559208 secondsODOT

after optimizationOCOLON
TOASSIGN
0ODOT99724  0ODOT0561704   OMINUS0ODOT04856   0ODOT141725
OMINUS0ODOT0559834   0ODOT998418 0ODOT00520242 OMINUS0ODOT0555103
0ODOT0487754 OMINUS0ODOT0024695   0ODOT998807 OMINUS0ODOT0311913
0          0          0          1
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

我们发现，只迭代一次后总体误差就已经稳定不变，说明仅在一次迭代之后算法即已收敛。从位姿求解的结果可以看出，它和前面SVD给出的位姿结果几乎一模一样，这说明SVD已经给出了优化问题的解析解。所以，本实验中可以认为SVD给出的结果是相机位姿的最优值。

需要说明的是，在本例的ICP中，我们使用了在两个图都有深度读数的特征点。然而事实上，只要其中一个图深度确定，我们就能用类似于PnP的误差方式，把它们也加到优化中来。同时，除了相机位姿之外，将空间点也作为优化变量考虑，亦是一种解决问题的方式。我们应当清楚，实际的求解是非常灵活的，不必拘泥于某种固定的形式。如果同时考虑点和相机，整个问题就变得OBACKSLASHtextbfOPENCURLY更自由CLOSECURLY了，你可能会得到其他的解。比如，可以让相机少转一些角度，而把点多移动一些。这从另一侧面反映出，在Bundle Adjustment里面，我们会希望有尽可能多的约束，因为多次观测会带来更多的信息，使我们能够更准确地估计每个变量。

OBACKSLASHsectionOPENCURLY小结CLOSECURLY
本讲介绍了基于特征点的视觉里程计中的几个重要的问题。包括：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 特征点是如何提取并匹配的。
	OBACKSLASHitem 如何通过2D−2D的特征点估计相机运动。
	OBACKSLASHitem 如何从2D−2D的匹配估计一个点的空间位置。
	OBACKSLASHitem 3D−2D的PnP问题，其线性解法和Bundle Adjustment解法。
	OBACKSLASHitem 3D−3D的ICP问题，其线性解法和Bundle Adjustment解法。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

本讲内容较为丰富，且结合应用了前几讲的基本知识。读者若觉得理解有困难，可以对前面知识稍加回顾。最好亲自做一遍实验，以理解整个运动估计的内容。

需要解释的是，为保证行文流畅，我们省略了大量关于某些特殊情况的讨论。例如，如果在对极几何求解过程中给定的特征点共面，会发生什么情况（这在单应矩阵ODOLLAROBACKSLASHbmOPENCURLYHCLOSECURLYODOLLAR中提到了）？共线又会发生什么情况？在PnP和ICP中若给定这样的解，又会导致什么情况？求解算法能否识别这些特殊的情况，并报告所得的解可能不可靠？能否给出估计的ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR的不确定度？尽管它们都是值得研究和探索的，然而对它们的讨论更适合留到具体的论文中。本书的目标在于广泛的知识覆盖面和基础知识，我们对这些问题暂不展开，同时在工程实现中，这些情况也甚少出现。如果你关心这些少见的情况，可以阅读OBACKSLASHciteOPENCURLYHartley2003CLOSECURLY等论文。

OBACKSLASHsectionOMULTIPLYOPENCURLY习题CLOSECURLY
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 除了本书介绍的ORB特征点外，你还能找到哪些特征点？请说说SIFT或SURF的原理，并对比它们与ORB之间的优劣。
	OBACKSLASHitem 设计程序调用OpenCV中的其他种类特征点。统计在提取1000个特征点时在你的机器上所用的时间。
	OBACKSLASHitemOPENSQUAREOBACKSLASHoptionalCLOSESQUARE 我们发现，OpenCV提供的ORB特征点在图像当中分布不够均匀。你是否能够找到或提出让特征点分布更加均匀的方法？
	OBACKSLASHitem 研究FLANN为何能够快速处理匹配问题。除了FLANN之外，还有哪些可以加速匹配的手段？
	OBACKSLASHitem 把演示程序使用的EPnP改成其他PnP方法，并研究它们的工作原理。
	OBACKSLASHitem 在PnP优化中，将第一个相机的观测也考虑进来，程序应如何书写？最后结果会有何变化？
	OBACKSLASHitem 在ICP程序中，将空间点也作为优化变量考虑进来，程序应如何书写？最后结果会有何变化？
	OBACKSLASHitemOPENSQUAREOBACKSLASHoptionalCLOSESQUARE 在特征点匹配过程中，不可避免地会遇到误匹配的情况。如果我们把错误匹配输入到PnP或ICP中，会发生怎样的情况？你能想到哪些避免误匹配的方法？
	OBACKSLASHitemOPENSQUAREOBACKSLASHoptionalCLOSESQUARE 使用Sophus的SE3类，自己设计g2o的节点与边，实现PnP和ICP的优化。
	OBACKSLASHitemOPENSQUAREOBACKSLASHoptionalCLOSESQUARE 在Ceres中实现PnP和ICP的优化。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

OMODULOOBACKSLASHsectionOMULTIPLYOPENCURLY深度滤波器（Depth Filter）CLOSECURLY
OMODULO使用上述线性求解三角化的方法，求得的三维点坐标总是不确定的，多次对同一个点的测量往往会估计出不同的深度。受噪声影响，当基线越短的时候，深度受噪声影响的敏感度就越大。因此我们需要设法去削减这种单次测量求解所包含的误差。深度滤波器通过多次测量同一个地图点，不断地去逼近地图点的真实深度，是一种十分有效的方法。OBACKSLASHciteOPENCURLYvogiatzis2011videoCLOSECURLYOBACKSLASHpar
OMODULO其核心思想是，一个有效的深度测量值ODOLLARdOUNDERSCOREOPENCURLYnCLOSECURLYODOLLAR在真实的深度ODOLLARDODOLLAR附近是呈高斯分布的，而一个无效的测量值ODOLLARdOUNDERSCOREOPENCURLYbadCLOSECURLYODOLLAR在一定深度范围ODOLLAROPENSQUAREDOUNDERSCOREOPENCURLYminCLOSECURLYOCOMMADOUNDERSCOREOPENCURLYmaxCLOSECURLYCLOSESQUAREODOLLAR内均匀分布，测量值有效的概率为ODOLLAROBACKSLASHalphaODOLLAR。用概率分布函数表示就是：
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULOpOPENBRACKETdOUNDERSCOREOPENCURLYnCLOSECURLYOBBORDOCOMMAOBACKSLASHalphaCLOSEBRACKETOASSIGNOBACKSLASHalpha NOPENBRACKETdOUNDERSCOREOPENCURLYnCLOSECURLYOBBORDOCOMMAOBACKSLASHtauOUNDERSCOREOPENCURLYnCLOSECURLYOHATOPENCURLY2CLOSECURLYCLOSEBRACKETOPLUSOPENBRACKET1OMINUSOBACKSLASHalphaCLOSEBRACKETUOPENBRACKETdOUNDERSCOREOPENCURLYbadCLOSECURLYOBBORDOUNDERSCOREOPENCURLYminCLOSECURLYOCOMMADOUNDERSCOREOPENCURLYmaxCLOSECURLYCLOSEBRACKET
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO我们的目标就是设法通过多个测量值ODOLLARdOUNDERSCOREOPENCURLYnCLOSECURLYODOLLAR，逼近真实的深度ODOLLARDODOLLAR。每有一个新的测量值ODOLLARdOUNDERSCOREOPENCURLYnOPLUS1CLOSECURLYODOLLAR进入，概率模型的参数就进行相应的调整。OBACKSLASHpar
OMODULO
OMODULO如果现在一共有N组测量值，假设每一次测量之间相互独立，通过贝叶斯公式可以得到：
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULOpOPENBRACKETDOCOMMAOBACKSLASHalphaOBBORxOUNDERSCOREOPENCURLY1CLOSECURLYOCOMMAxOUNDERSCOREOPENCURLY2CLOSECURLYOCOMMAODOTODOTODOTOCOMMAxOUNDERSCOREOPENCURLYNCLOSECURLYCLOSEBRACKET OBACKSLASHpropto pOPENBRACKETDOCOMMAOBACKSLASHalphaCLOSEBRACKET OBACKSLASHprodOUNDERSCOREOPENCURLYnCLOSECURLYpOPENBRACKETdOUNDERSCOREOPENCURLYnCLOSECURLYOBBORDOCOMMAOBACKSLASHalphaCLOSEBRACKET
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULOODOLLARpOPENBRACKETDOCOMMAOBACKSLASHalphaCLOSEBRACKETODOLLAR是一个先验分布，假设二者相互独立，即有ODOLLARpOPENBRACKETDOCOMMAOBACKSLASHalphaCLOSEBRACKETOASSIGNpOPENBRACKETDCLOSEBRACKETpOPENBRACKETOBACKSLASHalphaCLOSEBRACKETODOLLARODOT
OMODULO
OMODULO现在在模型中引入二进制的隐变量ODOLLARyOUNDERSCOREOPENCURLYnCLOSECURLYODOLLAR，ODOLLARyOUNDERSCOREOPENCURLYnCLOSECURLYOASSIGN1ODOLLAR表示测量值时有效的，反之则无效。于是有：
OMODULOODOLLARODOLLAR
OMODULOpOPENBRACKETdOUNDERSCOREOPENCURLYnCLOSECURLYOBBORDOCOMMAOBACKSLASHalphaOCOMMAyOUNDERSCOREOPENCURLYnCLOSECURLYOASSIGNNOPENBRACKETdOUNDERSCOREOPENCURLYnCLOSECURLYOBBORDOCOMMAOBACKSLASHtauOUNDERSCOREOPENCURLYnCLOSECURLYOHATOPENCURLY2CLOSECURLYCLOSEBRACKETOHATOPENCURLYyOUNDERSCOREOPENCURLYnCLOSECURLYCLOSECURLYUOPENBRACKETxOUNDERSCOREOPENCURLYnCLOSECURLYCLOSEBRACKETOHATOPENCURLY1OMINUSyOUNDERSCOREOPENCURLYnCLOSECURLYCLOSECURLY
OMODULOODOLLARODOLLAR
OMODULOODOLLARODOLLAR
OMODULOpOPENBRACKETyOUNDERSCOREOPENCURLYnCLOSECURLYOBBOROBACKSLASHalphaCLOSEBRACKETOASSIGNOBACKSLASHalphaOHATOPENCURLYyOUNDERSCOREOPENCURLYnCLOSECURLYCLOSECURLYOPENBRACKET1OMINUSOBACKSLASHalphaCLOSEBRACKETOHATOPENCURLY1OMINUSyOUNDERSCOREOPENCURLYnCLOSECURLYCLOSECURLY
OMODULOODOLLARODOLLAR
OMODULO
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULOpOPENBRACKETdOCOMMAyOCOMMADOCOMMAOBACKSLASHalphaCLOSEBRACKETOASSIGNOBACKSLASHprodOUNDERSCOREOPENCURLYnOASSIGN1CLOSECURLYOHATOPENCURLYNCLOSECURLYpOPENBRACKETdOUNDERSCOREOPENCURLYnCLOSECURLYOBBORDOCOMMAOBACKSLASHalphaOCOMMAyOUNDERSCOREOPENCURLYnCLOSECURLYCLOSEBRACKETpOPENBRACKETyOUNDERSCOREOPENCURLYnCLOSECURLYOBBOROBACKSLASHalphaCLOSEBRACKET pOPENBRACKETDCLOSEBRACKETpOPENBRACKETOBACKSLASHalphaCLOSEBRACKET
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULO这时候我们需要近似地去表达后验概率ODOLLARpOPENBRACKETyOCOMMADOCOMMAOBACKSLASHalphaOBBORdCLOSEBRACKETODOLLAR。找一个近似的分布ODOLLARqOPENBRACKETyOCOMMADOCOMMAOBACKSLASHalphaCLOSEBRACKETODOLLAR，与真实的ODOLLARpOPENBRACKETyOCOMMADOCOMMAOBACKSLASHalphaOBBORdCLOSEBRACKETODOLLARKL散度最小。
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULOqOPENBRACKETDOCOMMAOBACKSLASHalphaCLOSEBRACKETOASSIGNOBACKSLASHprodOUNDERSCOREOPENCURLYnOASSIGN1CLOSECURLYOHATOPENCURLYNCLOSECURLYNOPENBRACKETdOUNDERSCOREOPENCURLYnCLOSECURLYOBBORDOCOMMAOBACKSLASHsigmaOHATOPENCURLY2CLOSECURLYCLOSEBRACKETOHATOPENCURLYrOUNDERSCOREOPENCURLYnCLOSECURLYCLOSECURLYOBACKSLASHalphaOHATOPENCURLYSCLOSECURLYOPENBRACKET1OMINUSOBACKSLASHalphaCLOSEBRACKETOHATOPENCURLYNOMINUSSCLOSECURLYpOPENBRACKETDCLOSEBRACKETpOPENBRACKETOBACKSLASHalphaCLOSEBRACKET
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULOODOLLARrOUNDERSCOREOPENCURLYnCLOSECURLYOASSIGNEOUNDERSCOREOPENCURLYyCLOSECURLYOPENSQUAREyOUNDERSCOREOPENCURLYnCLOSECURLYCLOSESQUAREODOLLAR为第ODOLLARnODOLLAR个测量值有效的期望，而ODOLLARSOASSIGNOBACKSLASHsumOUNDERSCOREOPENCURLYnOASSIGN1CLOSECURLYOHATOPENCURLYNCLOSECURLYrOUNDERSCOREOPENCURLYnCLOSECURLYODOLLAR。OBACKSLASHpar
OMODULO
OMODULO这个概率分布函数为一个正态分布与伯努利分布的乘积，由于正态分布的共轭先验函数还是一个正态分布，而伯努利分布的共轭先验是一个Beta函数，于是上式可以转化为：
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULOqOPENBRACKETDOCOMMAOBACKSLASHalphaOBBORaOCOMMAbOCOMMAOBACKSLASHmuOCOMMAOBACKSLASHsigmaOHATOPENCURLY2CLOSECURLYCLOSEBRACKETOASSIGNNOPENBRACKETDOBBOROBACKSLASHmuOCOMMAOBACKSLASHsigmaOHATOPENCURLY2CLOSECURLYCLOSEBRACKETBetaOPENBRACKETOBACKSLASHalphaOBBORaOCOMMAbCLOSEBRACKET
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULO于是后验的更新方程即是OCOLON
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULOqOPENBRACKETDOCOMMAOBACKSLASHalphaOBBORa'OCOMMAb'OCOMMAOBACKSLASHmu'OCOMMAOBACKSLASHsigma'OHATOPENCURLY2CLOSECURLYCLOSEBRACKETOASSIGNpOPENBRACKETxOBBORDOCOMMAOBACKSLASHalphaCLOSEBRACKETqOPENBRACKETDOCOMMAOBACKSLASHalphaOBBORaOCOMMAbOCOMMAOBACKSLASHmuOCOMMAOBACKSLASHsigmaOHATOPENCURLY2CLOSECURLYCLOSEBRACKET
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULO
OMODULO带入前式：
OMODULOOBACKSLASHbeginOPENCURLYeqnarrayCLOSECURLY
OMODULOOBACKSLASHbeginOPENCURLYsplitCLOSECURLY
OMODULOOBANDOPENBRACKETOBACKSLASHalpha NOPENBRACKETdOBBORDOCOMMAOBACKSLASHtauOHATOPENCURLY2CLOSECURLYCLOSEBRACKETOPLUSOPENBRACKET1OMINUSOBACKSLASHalphaCLOSEBRACKETUOPENBRACKETdCLOSEBRACKETCLOSEBRACKETNOPENBRACKETDOBBOROBACKSLASHmuOCOMMAOBACKSLASHsigmaOHATOPENCURLY2CLOSECURLYCLOSEBRACKETBetaOPENBRACKETOBACKSLASHalphaOBBORaOCOMMAbCLOSEBRACKETOBACKSLASHOBACKSLASH
OMODULOOASSIGNOBANDOBACKSLASHfracOPENCURLYaCLOSECURLYOPENCURLYaOPLUSbCLOSECURLYNOPENBRACKETdOBBOROBACKSLASHmuOCOMMAOBACKSLASHsigmaOHATOPENCURLY2CLOSECURLYOPLUSOBACKSLASHtauOHATOPENCURLY2CLOSECURLYCLOSEBRACKETNOPENBRACKETDOBBORmOCOMMAsOHATOPENCURLY2CLOSECURLYCLOSEBRACKETBetaOPENBRACKETOBACKSLASHalphaOBBORaOPLUS1OCOMMAbCLOSEBRACKETOPLUSOBACKSLASHOBACKSLASH
OMODULOOBANDOBACKSLASHfracOPENCURLYbCLOSECURLYOPENCURLYaOPLUSbCLOSECURLYUOPENBRACKETdCLOSEBRACKETNOPENBRACKETDOBBOROBACKSLASHmuOCOMMAOBACKSLASHsigmaOHATOPENCURLY2CLOSECURLYCLOSEBRACKETBetaOPENBRACKETOBACKSLASHalphaOBBORaOCOMMAbOPLUS1CLOSEBRACKET
OMODULOOBACKSLASHendOPENCURLYsplitCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYeqnarrayCLOSECURLY
OMODULO
OMODULO上面式子中ODOLLAROBACKSLASHfracOPENCURLY1CLOSECURLYOPENCURLYsOHATOPENCURLY2CLOSECURLYCLOSECURLYOASSIGNOBACKSLASHfracOPENCURLYOBACKSLASHmuCLOSECURLYOPENCURLYOBACKSLASHsigmaOHATOPENCURLY2CLOSECURLYCLOSECURLYOPLUSOBACKSLASHfracOPENCURLYdCLOSECURLYOPENCURLYOBACKSLASHtauOHATOPENCURLY2CLOSECURLYCLOSECURLYODOLLAROCOMMAODOLLARmOASSIGNsOHATOPENCURLY2CLOSECURLYOPENBRACKETOBACKSLASHfracOPENCURLYOBACKSLASHmuCLOSECURLYOPENCURLYOBACKSLASHsigmaOHATOPENCURLY2CLOSECURLYCLOSECURLYOPLUSOBACKSLASHfracOPENCURLYdCLOSECURLYOPENCURLYOBACKSLASHtauOHATOPENCURLY2CLOSECURLYCLOSECURLYCLOSEBRACKETODOLLAROCOMMAODOLLARCOUNDERSCOREOPENCURLY1CLOSECURLYOASSIGNOBACKSLASHfracOPENCURLYaCLOSECURLYOPENCURLYaOPLUSbCLOSECURLYNOPENBRACKETdOBBOROBACKSLASHmuOCOMMAOBACKSLASHsigmaOHATOPENCURLY2CLOSECURLYOPLUSOBACKSLASHtauOHATOPENCURLY2CLOSECURLYCLOSEBRACKETODOLLAROCOMMA ODOLLARCOUNDERSCOREOPENCURLY2CLOSECURLYOASSIGNOBACKSLASHfracOPENCURLYbCLOSECURLYOPENCURLYaOPLUSbCLOSECURLYUOPENBRACKETdCLOSEBRACKETODOLLAR。
OMODULO
OMODULO采用矩估计的方法，分别估计ODOLLARDODOLLAR和ODOLLAROBACKSLASHalphaODOLLAR的一阶矩和二阶矩，可列入以下方程：
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYeqnarrayCLOSECURLY
OMODULOOBACKSLASHbeginOPENCURLYsplitCLOSECURLY
OMODULOOBANDu'OASSIGNCOUNDERSCOREOPENCURLY1CLOSECURLYmOPLUSCOUNDERSCOREOPENCURLY2CLOSECURLYOBACKSLASHmuOBACKSLASHOBACKSLASH
OMODULOOBANDOBACKSLASHsigma'OHATOPENCURLY2CLOSECURLYOPLUSOBACKSLASHmu'OHATOPENCURLY2CLOSECURLYOASSIGNCOUNDERSCOREOPENCURLY1CLOSECURLYOPENBRACKETsOHATOPENCURLY2CLOSECURLYOPLUSmOHATOPENCURLY2CLOSECURLYCLOSEBRACKETOPLUSCOUNDERSCOREOPENCURLY2CLOSECURLYOPENBRACKETOBACKSLASHsigmaOHATOPENCURLY2CLOSECURLYOPLUSOBACKSLASHmuOHATOPENCURLY2CLOSECURLYCLOSEBRACKETOBACKSLASHOBACKSLASH
OMODULOOBANDOBACKSLASHfracOPENCURLYa'CLOSECURLYOPENCURLYa'OPLUSb'CLOSECURLYOASSIGNCOUNDERSCOREOPENCURLY1CLOSECURLYOBACKSLASHfracOPENCURLYaOPLUS1CLOSECURLYOPENCURLYaOPLUSbOPLUS1CLOSECURLYOPLUSCOUNDERSCOREOPENCURLY2CLOSECURLYOBACKSLASHfracOPENCURLYaCLOSECURLYOPENCURLYaOPLUSbOPLUS1CLOSECURLYOBACKSLASHOBACKSLASH
OMODULOOBANDOBACKSLASHfracOPENCURLYa'OPENBRACKETa'OPLUS1CLOSEBRACKETCLOSECURLYOPENCURLYOPENBRACKETa'OPLUSb'CLOSEBRACKETOPENBRACKETa'OPLUSb'OPLUS1CLOSEBRACKETCLOSECURLYOASSIGNCOUNDERSCOREOPENCURLY1CLOSECURLYOBACKSLASHfracOPENCURLYOPENBRACKETaOPLUS1CLOSEBRACKETOPENBRACKETaOPLUS2CLOSEBRACKETCLOSECURLYOPENCURLYOPENBRACKETaOPLUSbOPLUS1CLOSEBRACKETOPENBRACKETaOPLUSbOPLUS2CLOSEBRACKETCLOSECURLYOPLUSCOUNDERSCOREOPENCURLY2CLOSECURLYOBACKSLASHfracOPENCURLYaOPENBRACKETaOPLUS1CLOSEBRACKETCLOSECURLYOPENCURLYOPENBRACKETaOPLUSbOPLUS1CLOSEBRACKETOPENBRACKETaOPLUSbOPLUS2CLOSEBRACKETCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYsplitCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYeqnarrayCLOSECURLY
OMODULO联立以上式子即可求解出更新后的模型参数ODOLLARa'OCOMMAb'OCOMMAOBACKSLASHsigma'OCOMMAOBACKSLASHmu'ODOLLAR。
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
OMODULO    OBACKSLASHcentering
OMODULO    OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT3OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEsparseCLOSECURLY
OMODULO    OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT3OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEsemidenseCLOSECURLY
OMODULO    OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT3OBACKSLASHlinewidthCLOSESQUAREOPENCURLYvo1ODIVIDEdenseCLOSECURLY
OMODULO    OBACKSLASHcaptionOPENCURLY稀疏地图，半稠密地图及稠密地图CLOSECURLY
OMODULO    OBACKSLASHlabelOPENCURLYfigOCOLONthreemethodsCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYfigureCLOSECURLY