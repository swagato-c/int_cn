OMODULO ONOTModeOCOLONOCOLON "TeXOCOLONUTFOMINUS8"
OMODULO 第二版：增加一个坐标变换的例子
OBACKSLASHchapterOPENCURLY三维空间刚体运动CLOSECURLY
OBACKSLASHlabelOPENCURLYcptOCOLON3CLOSECURLY
OBACKSLASHbeginOPENCURLYmdframedCLOSECURLY  
	OBACKSLASHtextbfOPENCURLY主要目标CLOSECURLY
	OBACKSLASHbeginOPENCURLYenumerateCLOSECURLYOPENSQUARElabelindentOASSIGN0emOCOMMAleftmarginOASSIGN1ODOT5emCLOSESQUARE
		OBACKSLASHitem 理解三维空间的刚体运动描述方式：旋转矩阵、变换矩阵、四元数和欧拉角。
		OBACKSLASHitem 掌握Eigen库的矩阵、几何模块使用方法。
	OBACKSLASHendOPENCURLYenumerateCLOSECURLY
OBACKSLASHendOPENCURLYmdframedCLOSECURLY 

在上一讲中，我们讲解了视觉SLAM的框架与内容。本讲将介绍视觉SLAM的基本问题之一：OBACKSLASHtextbfOPENCURLY如何描述刚体在三维空间中的运动CLOSECURLY？直观上看，我们当然知道这由一次旋转加一次平移组成。平移确实没有太大问题，但旋转的处理是件麻烦事。我们将介绍旋转矩阵、四元数、欧拉角的意义，以及它们是如何运算和转换的。在实践部分，我们将介绍线性代数库Eigen。它提供了COPLUSOPLUS中的矩阵运算，并且它的Geometry模块还提供了四元数等描述刚体运动的结构。Eigen的优化非常完善，但是它的使用方法有一些特殊的地方，我们留到程序中介绍。

OBACKSLASHnewpage
OBACKSLASHincludepdfOPENCURLYresourcesODIVIDEotherODIVIDEch3ODOTpdfCLOSECURLY

OBACKSLASHnewpage

OBACKSLASHsectionOPENCURLY旋转矩阵CLOSECURLY
OBACKSLASHlabelOPENCURLYsecOCOLONrigidMotionCLOSECURLY
OBACKSLASHsubsectionOPENCURLY点和向量，坐标系CLOSECURLY
我们日常生活的空间是三维的，因此我们生来就习惯于三维空间的运动。三维空间由3个轴组成，所以一个空间点的位置可以由3个坐标指定。不过，我们现在要考虑OBACKSLASHtextbfOPENCURLY刚体CLOSECURLY，它不光有位置，还有自身的姿态。相机也可以看成三维空间的刚体，于是位置是指相机在空间中的哪个地方，而姿态则是指相机的朝向。结合起来，我们可以说，“相机正处于空间ODOLLAROPENBRACKET0OCOMMA0OCOMMA0CLOSEBRACKETODOLLAR点处，朝向正前方”这样的话。但是这种自然语言很烦琐，我们更喜欢用数学语言来描述它。

我们从最基本的内容讲起：OBACKSLASHtextbfOPENCURLY点CLOSECURLY和OBACKSLASHtextbfOPENCURLY向量CLOSECURLY。点就是空间当中的基本元素，没有长度，没有体积。把两个点连接起来，就构成了向量。向量可以看成从某点指向另一点的一个箭头。需要提醒读者的是，请不要把向量与它的OBACKSLASHtextbfOPENCURLY坐标CLOSECURLY两个概念混淆。一个向量是空间当中的一样东西，比如说ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR。这里ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR并不需要和若干个实数相关联的。只有当我们指定这个三维空间中的某个OBACKSLASHtextbfOPENCURLY坐标系CLOSECURLY时，才可以谈论该向量在此坐标系下的坐标，也就是找到若干个实数对应这个向量。

用线性代数的知识来说，三维空间中的某个点的坐标也可以用ODOLLAROBACKSLASHmathbbOPENCURLYRCLOSECURLYOHAT3ODOLLAR来描述。怎么描述呢？假设在这个线性空间内，我们找到了该空间的一组OBACKSLASHtextbfOPENCURLY基CLOSECURLYOBACKSLASHfootnoteOPENCURLY以防读者忘记，基就是张成这个空间的一组线性无关的向量，有些书里也叫OBACKSLASHtextbfOPENCURLY基底CLOSECURLY。CLOSECURLYODOLLAROPENBRACKETOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1OCOMMAOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2OCOMMAOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3CLOSEBRACKETODOLLAR，那么，任意向量ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR在这组基下就有一个OBACKSLASHtextbfOPENCURLY坐标CLOSECURLY：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYaCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2CLOSECURLYOCOMMAOPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3CLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREOBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OPENCURLYaOUNDERSCORE1CLOSECURLYOBACKSLASHOBACKSLASH
OPENCURLYaOUNDERSCORE2CLOSECURLYOBACKSLASHOBACKSLASH
OPENCURLYaOUNDERSCORE3CLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN OPENCURLYaOUNDERSCORE1CLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1CLOSECURLY OPLUS OPENCURLYaOUNDERSCORE2CLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2CLOSECURLY OPLUS OPENCURLYaOUNDERSCORE3CLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3CLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
这里ODOLLAROPENBRACKETaOUNDERSCORE1OCOMMAaOUNDERSCORE2OCOMMAaOUNDERSCORE3CLOSEBRACKETOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR称为ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR在此基下的坐标OBACKSLASHfootnoteOPENCURLY本书的向量为列向量，这和一般的数学书籍类似。CLOSECURLY。坐标的具体取值，一是和向量本身有关，二是和坐标系（基）的选取有关。坐标系通常由3个正交的坐标轴组成（尽管也可以有非正交的，但实际中很少见）。例如，给定ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYyCLOSECURLYODOLLAR轴时，ODOLLAROBACKSLASHbmOPENCURLYzCLOSECURLYODOLLAR轴就可以通过右手（或左手）法则由ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLY OBACKSLASHtimes OBACKSLASHbmOPENCURLYyCLOSECURLYODOLLAR定义出来。根据定义方式的不同，坐标系又分为左手系和右手系。左手系的第3个轴与右手系方向相反。大部分3D程序库使用右手系（如OpenGL，3D Max等），也有部分库使用左手系（如Unity，Direct3D等）。

根据基本的线性代数知识，我们可以谈论向量与向量，以及向量与数之间的运算，例如数乘、加法、减法、内积、外积等。数乘和加减法都是相当基本的内容，也符合直观想象。例如，两个向量相加的结果就是把它们各自坐标相加，减法亦然，等等。这里不再赘述。内外积对读者来说可能有些陌生，这里给出它们的运算方式。对于ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYbCLOSECURLY OBACKSLASHin OBACKSLASHmathbbOPENCURLYRCLOSECURLYOHAT3ODOLLAR，通常意义下OBACKSLASHfootnoteOPENCURLY内积也有形式化的法则，但本书只讨论通常的内积。CLOSECURLY的内积可以写成：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYaCLOSECURLY OBACKSLASHcdot OBACKSLASHbmOPENCURLYbCLOSECURLY OASSIGN OPENCURLY OBACKSLASHbmOPENCURLYaCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOBACKSLASHbmOPENCURLYbCLOSECURLY OASSIGN OBACKSLASHsumOBACKSLASHlimitsOUNDERSCOREOPENCURLYi OASSIGN 1CLOSECURLYOHAT3 OPENCURLYOPENCURLYaOUNDERSCOREiCLOSECURLYOPENCURLYbOUNDERSCOREiCLOSECURLYCLOSECURLY  OASSIGN OBACKSLASHleftOBBOR OBACKSLASHbmOPENCURLYaCLOSECURLY OBACKSLASHrightOBBOROBACKSLASHleftOBBOR OBACKSLASHbmOPENCURLYbCLOSECURLY OBACKSLASHrightOBBOROBACKSLASHcos OBACKSLASHleftOBACKSLASHlangle OPENCURLYOBACKSLASHbmOPENCURLYaCLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYbCLOSECURLYCLOSECURLY OBACKSLASHrightOBACKSLASHrangle ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
其中ODOLLAROBACKSLASHleftOBACKSLASHlangle OPENCURLYOBACKSLASHbmOPENCURLYaCLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYbCLOSECURLYCLOSECURLY OBACKSLASHrightOBACKSLASHrangleODOLLAR指向量ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR的夹角。内积也可以描述向量间的投影关系。而外积则是这个样子：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONcrossCLOSECURLY
OBACKSLASHbmOPENCURLYaCLOSECURLY OBACKSLASHtimes OBACKSLASHbmOPENCURLYbCLOSECURLY OASSIGN OBACKSLASHleftOBACKSLASHOBBOR OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1 OBAND OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2 OBAND OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3 OBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLYaOUNDERSCORE1CLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYaOUNDERSCORE2CLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYaOUNDERSCORE3CLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLYbOUNDERSCORE1CLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYbOUNDERSCORE2CLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYbOUNDERSCORE3CLOSECURLYCLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightOBACKSLASHOBBOR OASSIGN OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OPENCURLYaOUNDERSCORE2CLOSECURLYOPENCURLYbOUNDERSCORE3CLOSECURLY OMINUS OPENCURLYaOUNDERSCORE3CLOSECURLYOPENCURLYbOUNDERSCORE2CLOSECURLYOBACKSLASHOBACKSLASH
OPENCURLYaOUNDERSCORE3CLOSECURLYOPENCURLYbOUNDERSCORE1CLOSECURLY OMINUS OPENCURLYaOUNDERSCORE1CLOSECURLYOPENCURLYbOUNDERSCORE3CLOSECURLYOBACKSLASHOBACKSLASH
OPENCURLYaOUNDERSCORE1CLOSECURLYOPENCURLYbOUNDERSCORE2CLOSECURLY OMINUS OPENCURLYaOUNDERSCORE2CLOSECURLYOPENCURLYbOUNDERSCORE1CLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	0OBANDOPENCURLY OMINUS OPENCURLYaOUNDERSCORE3CLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYaOUNDERSCORE2CLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLYaOUNDERSCORE3CLOSECURLYCLOSECURLYOBAND0OBANDOPENCURLY OMINUS OPENCURLYaOUNDERSCORE1CLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLY OMINUS OPENCURLYaOUNDERSCORE2CLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYaOUNDERSCORE1CLOSECURLYCLOSECURLYOBAND0
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUARE OBACKSLASHbmOPENCURLYbCLOSECURLY OBACKSLASHbuildrel OBACKSLASHDelta OBACKSLASHover OASSIGN OPENCURLY OBACKSLASHbmOPENCURLYaCLOSECURLYOHAT OBACKSLASHwedge CLOSECURLY OBACKSLASHbmOPENCURLYbCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

外积的结果是一个向量，它的方向垂直于这两个向量，大小为 ODOLLAROBACKSLASHleftOBBOR OBACKSLASHbmOPENCURLYaCLOSECURLY OBACKSLASHrightOBBOROBACKSLASHleftOBBOR OBACKSLASHbmOPENCURLYbCLOSECURLY OBACKSLASHrightOBBOROBACKSLASHsin OBACKSLASHleftOBACKSLASHlangle OPENCURLYOBACKSLASHbmOPENCURLYaCLOSECURLYOCOMMAOBACKSLASHbmOPENCURLYbCLOSECURLYCLOSECURLY OBACKSLASHrightOBACKSLASHrangle ODOLLAR，是两个向量张成的四边形的有向面积。对于外积运算，我们引入ODOLLAROHAT OBACKSLASHwedgeODOLLAR符号，把ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR写成一个矩阵。事实上是一个OBACKSLASHtextbfOPENCURLY反对称矩阵CLOSECURLY（SkewOMINUSsymmetric matrix）OBACKSLASHfootnoteOPENCURLY反对称矩阵ODOLLAROBACKSLASHbmOPENCURLYACLOSECURLYODOLLAR满足ODOLLAROBACKSLASHbmOPENCURLYACLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOASSIGNOMINUSOBACKSLASHbmOPENCURLYACLOSECURLYODOLLAR。CLOSECURLY，你可以将ODOLLAROHAT OBACKSLASHwedgeODOLLAR记成一个反对称符号。这样就把外积ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLY OBACKSLASHtimes OBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR写成了矩阵与向量的乘法ODOLLAROPENCURLY OBACKSLASHbmOPENCURLYaCLOSECURLYOHAT OBACKSLASHwedge CLOSECURLY OBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR，把它变成了线性运算。这个符号将在后文经常用到，请记住它，并且此符号是一个一一映射，意味着任意向量都对应着唯一的一个反对称矩阵，反之亦然：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYaCLOSECURLYOHATOBACKSLASHwedge OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	0OBANDOPENCURLY OMINUS OPENCURLYaOUNDERSCORE3CLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYaOUNDERSCORE2CLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLYaOUNDERSCORE3CLOSECURLYCLOSECURLYOBAND0OBANDOPENCURLY OMINUS OPENCURLYaOUNDERSCORE1CLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLY OMINUS OPENCURLYaOUNDERSCORE2CLOSECURLYCLOSECURLYOBANDOPENCURLYOPENCURLYaOUNDERSCORE1CLOSECURLYCLOSECURLYOBAND0
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

同时，需要提醒读者的是，向量和加减法、内外积，即使在不谈论它们的坐标时也可以计算。例如，虽然内积在有坐标时，可以用两个向量的分量乘积之和表达，但是即使不知道它们的坐标时，也可以通过长度和夹角来计算二者的内积。所以两个向量的内积结果和坐标系的选取是无关的。

OMODULO我们还能用外积表示向量的OBACKSLASHtextbfOPENCURLY旋转CLOSECURLY。
OMODULO
OMODULO为什么外积可以表示旋转呢？
OMODULO
OMODULO考虑两个不平行的向量ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR，我们要描述从ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR到ODOLLAROBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR之间是如何旋转的，如OBACKSLASHautorefOPENCURLYfigOCOLONrotationOfVectorCLOSECURLY所示。我们可以用一个向量来描述三维空间中两个向量的旋转关系。在右手法则下，我们用右手的4个指头从ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR转向ODOLLAROBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR，大拇指朝向就是旋转向量的方向，事实上也是ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLY OBACKSLASHtimes OBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR的方向。它的大小则由ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR的夹角决定。通过这种方式，我们构造了从ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR到ODOLLAROBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR的一个旋转向量。这个向量同样位于三维空间中，在此坐标系下，可以用3个实数来描述。
OMODULO
OMODULOOBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
OMODULO	OBACKSLASHcentering
OMODULO	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1ODOT0OBACKSLASHtextwidthCLOSESQUAREOPENCURLYrigidMotionODIVIDEaxisODOTpdfCLOSECURLY
OMODULO	OBACKSLASHcaptionOPENCURLY左右手系的区别与向量间的旋转。ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR到ODOLLAROBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR的旋转可以由向量ODOLLAROBACKSLASHbmOPENCURLYwCLOSECURLYODOLLAR来描述。CLOSECURLY
OMODULO	OBACKSLASHlabelOPENCURLYfigOCOLONrotationOfVectorCLOSECURLY
OMODULOOBACKSLASHendOPENCURLYfigureCLOSECURLY

OBACKSLASHsubsectionOPENCURLY坐标系间的欧氏变换CLOSECURLY
我们经常会在实际场景中定义各种各样的坐标系。在机器人学中，你会给每一个连杆和关节都定义它们的坐标系；在3D作图时，我们也会定义每一个长方体、圆柱体的坐标系。如果考虑运动的机器人，那么常见的做法是设定一个惯性坐标系（或者叫世界坐标系），可以认为它是固定不动的，例如OBACKSLASHautorefOPENCURLYfigOCOLONaxisTransformCLOSECURLY中的ODOLLARxOUNDERSCOREWOCOMMA yOUNDERSCOREWOCOMMA zOUNDERSCOREWODOLLAR定义的坐标系。同时，相机或机器人则是一个移动坐标系，例如ODOLLARxOUNDERSCORECOCOMMA yOUNDERSCORECOCOMMA zOUNDERSCORECODOLLAR定义的坐标系。我们可能会问：相机视野中某个向量ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYODOLLAR，它在相机坐标系下的坐标为ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREcODOLLAR，而在世界坐标系下看，它的坐标为ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREwODOLLAR，那么，这两个坐标之间是如何转换的呢？这时，就需要先得到该点针对机器人坐标系的坐标值，再根据机器人位姿OBACKSLASHtextbfOPENCURLY变换CLOSECURLY到世界坐标系中。我们需要一种数学手段来描述这个变换关系，稍后我们会看到，可以用一个矩阵ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR来描述它。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT7OBACKSLASHtextwidthCLOSESQUAREOPENCURLYrigidMotionODIVIDEaxisTransformODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLY坐标变换。对于同一个向量ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYODOLLAR，它在世界坐标系下的坐标ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREwODOLLAR和在相机坐标系下的坐标ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREcODOLLAR是不同的。这个变换关系由变换矩阵ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR来描述。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONaxisTransformCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

直观上看，两个坐标系之间的运动由一个旋转加上一个平移组成，这种运动称为OBACKSLASHtextbfOPENCURLY刚体运动CLOSECURLY。相机运动就是一个刚体运动。刚体运动过程中，同一个向量在各个坐标系下的长度和夹角都不会发生变化。想象你把手机抛到空中，在它落地摔碎之前OBACKSLASHfootnoteOPENCURLY请不要付诸实践。CLOSECURLY，只可能有空间位置和姿态的不同，而它自己的长度、各个面的角度等性质不会有任何变化。手机并不会像橡皮那样一会儿被挤扁，一会儿被拉长。此时，我们说手机坐标系到世界坐标之间，相差了一个OBACKSLASHtextbfOPENCURLY欧氏变换CLOSECURLY（Euclidean Transform）。

欧氏变换由旋转和平移组成。我们首先考虑旋转。设某个单位正交基ODOLLAROPENBRACKETOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1OCOMMAOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2OCOMMAOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3CLOSEBRACKETODOLLAR经过一次旋转变成了ODOLLAROPENBRACKETOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1'OCOMMA OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2'OCOMMA OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3'CLOSEBRACKETODOLLAR。那么，对于同一个向量ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR（该向量并没有随着坐标系的旋转而发生运动），它在两个坐标系下的坐标为ODOLLAROPENSQUAREaOUNDERSCORE1OCOMMAaOUNDERSCORE2OCOMMAaOUNDERSCORE3CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR和ODOLLAROPENSQUAREa'OUNDERSCORE1OCOMMA a'OUNDERSCORE2OCOMMA a'OUNDERSCORE3CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR。因为向量本身没变，根据坐标的定义，有：

OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHleftOPENSQUARE OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1OCOMMAOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2OCOMMAOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3 OBACKSLASHrightCLOSESQUAREOBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OPENCURLYaOUNDERSCORE1CLOSECURLYOBACKSLASHOBACKSLASH
OPENCURLYaOUNDERSCORE2CLOSECURLYOBACKSLASHOBACKSLASH
OPENCURLYaOUNDERSCORE3CLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN OBACKSLASHleftOPENSQUARE OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1'OCOMMA OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2'OCOMMA OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3' OBACKSLASHrightCLOSESQUAREOBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
a'OUNDERSCORE1OBACKSLASHOBACKSLASH
a'OUNDERSCORE2OBACKSLASHOBACKSLASH
a'OUNDERSCORE3
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

为了描述两个坐标之间的关系，我们对上述等式的左右两边同时左乘ODOLLAROBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUAREODOLLAR，那么左边的系数就变成了单位矩阵，所以：
OMODULOOBACKSLASHclearpage
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OPENCURLYaOUNDERSCORE1CLOSECURLYOBACKSLASHOBACKSLASH
OPENCURLYaOUNDERSCORE2CLOSECURLYOBACKSLASHOBACKSLASH
OPENCURLYaOUNDERSCORE3CLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1'CLOSECURLY OBAND OPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2'CLOSECURLY OBAND OPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3'CLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1'CLOSECURLY OBAND OPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2'CLOSECURLY OBAND OPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3'CLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE1'CLOSECURLY OBAND OPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE2'CLOSECURLY OBAND OPENCURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3OHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBACKSLASHbmOPENCURLYeCLOSECURLYOUNDERSCORE3'CLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREOBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
aOUNDERSCORE1'OBACKSLASHOBACKSLASH
aOUNDERSCORE2'OBACKSLASHOBACKSLASH
aOUNDERSCORE3'
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OBACKSLASHbuildrel OBACKSLASHDelta OBACKSLASHover OASSIGN OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYaCLOSECURLY'ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
我们把中间的矩阵拿出来，定义成一个矩阵ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR。这个矩阵由两组基之间的内积组成，刻画了旋转前后同一个向量的坐标变换关系。只要旋转是一样的，那么这个矩阵也是一样的。可以说，矩阵ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR描述了旋转本身。因此称为OBACKSLASHtextbfOPENCURLY旋转矩阵CLOSECURLY（Rotation matrix）。同时，该矩阵各分量是两个坐标系基的内积，由于基向量的长度为1，所以实际上是各基向量的夹角之余弦。所以这个矩阵也叫OBACKSLASHtextbfOPENCURLY方向余弦矩阵CLOSECURLY（Direction Cosine matrix）。我们后文统一称呼它为旋转矩阵。

旋转矩阵有一些特别的性质。事实上，它是一个行列式为1的正交矩阵OBACKSLASHfootnoteOPENCURLY正交矩阵即逆为自身转置的矩阵。旋转矩阵的正交性可以直接由定义得出。CLOSECURLYOBACKSLASHfootnoteOPENCURLY行列式为1是人为定义的，实际上只要求它的行列式为ODOLLAROBACKSLASHpm 1ODOLLAR，但行列式为ODOLLAROMINUS1ODOLLAR的称为瑕旋转，即一次旋转加一次反射。CLOSECURLY。反之，行列式为1的正交矩阵也是一个旋转矩阵。所以，可以把ODOLLARnODOLLAR维旋转矩阵的集合定义如下：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHmathrmOPENCURLYSOCLOSECURLYOPENBRACKETnCLOSEBRACKET OASSIGN OBACKSLASHOPENCURLY OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHin OBACKSLASHmathbbOPENCURLYRCLOSECURLYOHATOPENCURLYn OBACKSLASHtimes nCLOSECURLY OBBOR OBACKSLASHbmOPENCURLYR RCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYICLOSECURLYOCOMMA OBACKSLASHmathrmOPENCURLYdetCLOSECURLY OPENBRACKETOBACKSLASHbmOPENCURLYRCLOSECURLYCLOSEBRACKETOASSIGN1 OBACKSLASHCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

ODOLLAROBACKSLASHmathrmOPENCURLYSOCLOSECURLYOPENBRACKETnCLOSEBRACKETODOLLAR是OBACKSLASHtextbfOPENCURLY特殊正交群CLOSECURLY（Special Orthogonal Group）的意思。我们把“群”的内容留到下一讲。这个集合由ODOLLARnODOLLAR维空间的旋转矩阵组成，特别地，ODOLLAROBACKSLASHmathrmOPENCURLYSOCLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR就是指三维空间的旋转。通过旋转矩阵，我们可以直接谈论两个坐标系之间的旋转变换，而不用再从基开始谈起。

由于旋转矩阵为正交矩阵，它的逆（即转置）描述了一个相反的旋转。按照上面的定义方式，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYaCLOSECURLY' OASSIGN OBACKSLASHbmOPENCURLYRCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLY OBACKSLASHbmOPENCURLYaCLOSECURLY OASSIGNOBACKSLASHbmOPENCURLYRCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYaCLOSECURLY ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
显然ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR刻画了一个相反的旋转。

在欧氏变换中，除了旋转之外还有平移。考虑世界坐标系中的向量ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR，经过一次旋转（用ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR描述）和一次平移ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR后，得到了ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLY'ODOLLAR，那么把旋转和平移合到一起，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONRTCLOSECURLY
OBACKSLASHbmOPENCURLYaCLOSECURLY' OASSIGN OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYaCLOSECURLY OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
其中，ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR称为平移向量。相比于旋转，平移部分只需把平移向量加到旋转之后的坐标上，非常简单。通过上式，我们用一个旋转矩阵ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR和一个平移向量ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR完整地描述了一个欧氏空间的坐标变换关系。实际当中，我们会定义坐标系1、坐标系2，那么向量ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR在两个系下坐标为ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYOUNDERSCORE1OCOMMA OBACKSLASHbmOPENCURLYaCLOSECURLYOUNDERSCORE2ODOLLAR，它们之间的关系，按照完整的写法，应该是：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYaCLOSECURLYOUNDERSCORE1 OASSIGN OBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCOREOPENCURLY12CLOSECURLY OBACKSLASHbmOPENCURLYaCLOSECURLYOUNDERSCORE2 OPLUS OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLY12CLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
这里的ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCOREOPENCURLY12CLOSECURLYODOLLAR是指“把坐标系2的向量变换到坐标系1”中。由于向量乘在这个矩阵的右边，它的下标是OBACKSLASHtextbfOPENCURLY从右读到左CLOSECURLY的。这也是本书的习惯写法。坐标变换很容易搞混，特别是存在多个坐标系的情况下。同理，如果我们要表达“从1到2的旋转矩阵”时，就写成ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCOREOPENCURLY21CLOSECURLYODOLLAR。请读者务必清楚这边的记法，因为不同书籍里写法不同，有的会记成左上ODIVIDE下标，而本书写在右侧下标。

关于平移ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLY12CLOSECURLYODOLLAR，它实际对应的是坐标系1原点指向坐标系2原点的向量，OBACKSLASHtextbfOPENCURLY在坐标系1下取的坐标CLOSECURLY，所以我建议读者把它记作“从1到2的向量”。但是反过来的ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLY21CLOSECURLYODOLLAR，即从2指向1的向量OBACKSLASHtextbfOPENCURLY在坐标系2下的坐标CLOSECURLY，却并不等于ODOLLAROMINUSOBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLY12CLOSECURLYODOLLAR，而是和两个系的旋转还有关系OBACKSLASHfootnoteOPENCURLY尽管从向量层面来看，它们确实是反向的关系，但这两个向量的坐标值并不是相反数。你能想清楚这是为什么吗？CLOSECURLY。所以，当初学者问“我的坐标在哪里”这样的问题时，我们需要清楚地说明这句话的含义。这里“我的坐标”实际上指从世界坐标系指向自己坐标系原点的向量，在世界坐标系下取到的坐标。对应到数学符号上，应该是ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLYWCCLOSECURLYODOLLAR的取值。同理，它也不是ODOLLAROMINUSOBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLYCWCLOSECURLYODOLLAR。

OBACKSLASHsubsectionOPENCURLY变换矩阵与齐次坐标CLOSECURLY

式OBACKSLASHeqrefOPENCURLYeqOCOLONRTCLOSECURLY完整地表达了欧氏空间的旋转与平移，不过还存在一个小问题：这里的变换关系不是一个线性关系。假设我们进行了两次变换：ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE1OCOMMAOBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE1ODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE2OCOMMAOBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE2ODOLLAR：

OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYbCLOSECURLY OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE1CLOSECURLY OBACKSLASHbmOPENCURLYaCLOSECURLY OPLUS OPENCURLYOBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE1CLOSECURLYOCOMMA OBACKSLASHquad OBACKSLASHbmOPENCURLYcCLOSECURLY OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE2CLOSECURLY OBACKSLASHbmOPENCURLYbCLOSECURLY OPLUS OPENCURLYOBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE2CLOSECURLYODOT
OBACKSLASHCLOSESQUARE
那么，从ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR到ODOLLAROBACKSLASHbmOPENCURLYcCLOSECURLYODOLLAR的变换为：
OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYcCLOSECURLY OASSIGN OPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE2CLOSECURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOUNDERSCORE1CLOSECURLY OBACKSLASHbmOPENCURLYaCLOSECURLY OPLUS OPENCURLYOBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE1CLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OPENCURLYOBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE2CLOSECURLYODOT
OBACKSLASHCLOSESQUARE
这样的形式在变换多次之后会显得很啰嗦。因此，我们引入齐次坐标和变换矩阵，重写式OBACKSLASHeqrefOPENCURLYeqOCOLONRTCLOSECURLY：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHbmOPENCURLYaCLOSECURLY'OBACKSLASHOBACKSLASH
1
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN 
OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OBACKSLASHbmOPENCURLYRCLOSECURLYOBANDOBACKSLASHbmOPENCURLYtCLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLY0CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLYOBAND1
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUARE
OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHbmOPENCURLYaCLOSECURLYOBACKSLASHOBACKSLASH
1
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE  OBACKSLASHbuildrel OBACKSLASHDelta OBACKSLASHover OASSIGN OBACKSLASHbmOPENCURLYTCLOSECURLY OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OBACKSLASHbmOPENCURLYaCLOSECURLYOBACKSLASHOBACKSLASH
1
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

这是一个数学技巧：我们在一个三维向量的末尾添加ODOLLAR1ODOLLAR，将其变成了四维向量，称为OBACKSLASHtextbfOPENCURLY齐次坐标CLOSECURLY。对于这个四维向量，我们可以把旋转和平移写在一个矩阵里面，使得整个关系变成线性关系。该式中，矩阵ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR称为OBACKSLASHtextbfOPENCURLY变换矩阵（Transform Matrix）CLOSECURLY。
OMODULO
OMODULO稍微说一下齐次坐标。它是射影几何里的概念。通过添加最后一维，我们用4个实数描述了一个三维向量，这显然多了一个自由度，但允许我们把变换写成线性的形式。在齐次坐标中，某个点ODOLLAROBACKSLASHbmOPENCURLYxCLOSECURLYODOLLAR的每个分量同乘一个非零常数ODOLLARkODOLLAR后，OBACKSLASHtextbfOPENCURLY仍然表示同一个点CLOSECURLY。因此，一个点的具体坐标值不是唯一的。如ODOLLAROBACKSLASHleftOPENSQUARE1OCOMMA1OCOMMA1OCOMMA1OBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR和ODOLLAROBACKSLASHleftOPENSQUARE2OCOMMA2OCOMMA2OCOMMA2OBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR是同一个点。但当最后一项不为零时，我们总可以把所有坐标除以最后一项，强制最后一项为1，从而得到一个点唯一的坐标表示（也就是转换成非齐次坐标）：
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULOOBACKSLASHtildeOPENCURLYOBACKSLASHbmOPENCURLYxCLOSECURLYCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE xOCOMMA yOCOMMA zOCOMMAw OBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE xODIVIDEwOCOMMA yODIVIDEwOCOMMA zODIVIDEwOCOMMA 1 OBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY ODOT
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULO这时，忽略掉最后一项，这个点的坐标和欧氏空间就是一样的。

我们暂时用ODOLLAR OBACKSLASHtildeOPENCURLY OBACKSLASHbmOPENCURLYaCLOSECURLY CLOSECURLYODOLLAR表示ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR的齐次坐标。那么依靠齐次坐标和变换矩阵，两次变换的叠加就可以有很好的形式：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHtildeOPENCURLYOBACKSLASHbmOPENCURLYbCLOSECURLYCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCORE1 OBACKSLASHtildeOPENCURLYOBACKSLASHbmOPENCURLYaCLOSECURLYCLOSECURLYOCOMMA OBACKSLASH  OBACKSLASHtildeOPENCURLYOBACKSLASHbmOPENCURLYcCLOSECURLYCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCORE2 OBACKSLASHtildeOPENCURLYOBACKSLASHbmOPENCURLYbCLOSECURLYCLOSECURLY OBACKSLASHquad OBACKSLASHRightarrow OBACKSLASHtildeOPENCURLYOBACKSLASHbmOPENCURLYcCLOSECURLYCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCORE2 OBACKSLASHbmOPENCURLYTOUNDERSCORE1CLOSECURLY OBACKSLASHtildeOPENCURLYOBACKSLASHbmOPENCURLYaCLOSECURLYCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
但是区分齐次和非齐次坐标的符号令我们感到厌烦，因为此处只需要在向量末尾添加1或者去掉1即可OBACKSLASHfootnoteOPENCURLY但齐次坐标的用途不止于此，我们在第7章还会再介绍。CLOSECURLY。所以，在不引起歧义的情况下，以后我们就直接把它写成ODOLLAROBACKSLASHbmOPENCURLYbCLOSECURLYOASSIGN OBACKSLASHbmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR的样子，默认其中进行了齐次坐标的转换OBACKSLASHfootnoteOPENCURLY注意，不进行齐次坐标转换时，这边的乘法在矩阵维度上是不成立的。CLOSECURLY。

关于变换矩阵ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYODOLLAR，它具有比较特别的结构：左上角为旋转矩阵，右侧为平移向量，左下角为ODOLLAROBACKSLASHbmOPENCURLY0CLOSECURLYODOLLAR向量，右下角为1。这种矩阵又称为特殊欧氏群（Special Euclidean Group）：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHmathrmOPENCURLYSECLOSECURLYOPENBRACKET3CLOSEBRACKET OASSIGN OBACKSLASHleftOBACKSLASHOPENCURLY OBACKSLASHbmOPENCURLYTCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OBACKSLASHbmOPENCURLYRCLOSECURLY OBAND OBACKSLASHbmOPENCURLYtCLOSECURLY OBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLY0CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLY OBAND 1
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUARE
OBACKSLASHin OBACKSLASHmathbbOPENCURLYRCLOSECURLYOHATOPENCURLY4 OBACKSLASHtimes 4CLOSECURLY OBBOR OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHin OBACKSLASHmathrmOPENCURLYSOCLOSECURLYOPENBRACKET3CLOSEBRACKETOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLY OBACKSLASHin OBACKSLASHmathbbOPENCURLYRCLOSECURLYOHAT3OBACKSLASHrightOBACKSLASHCLOSECURLY ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

与ODOLLAROBACKSLASHmathrmOPENCURLYSOCLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR一样，求解该矩阵的逆表示一个反向的变换：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OPENCURLY OBACKSLASHbmOPENCURLYTCLOSECURLYOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLYOBANDOPENCURLY OMINUS OPENCURLYOBACKSLASHbmOPENCURLYRCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYOBACKSLASHbmOPENCURLYtCLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLY0CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLYOBAND1
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

同样，我们用ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLY12CLOSECURLYODOLLAR这样的写法来表示从2到1的变换。并且，为了保持符号的简洁，在不引起歧义的情况下，以后不刻意区别齐次坐标与普通坐标的符号，OBACKSLASHtextbfOPENCURLY默认使用的是符合运算法则的那一种CLOSECURLY。例如，当我们写ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYaCLOSECURLYODOLLAR时，使用的是齐次坐标（不然没法计算）。而写ODOLLAROBACKSLASHbmOPENCURLYRaCLOSECURLYODOLLAR时，使用的是非齐次坐标。如果写在一个等式中，就假设齐次坐标到普通坐标的转换，是已经做好了的——因为齐次坐标和非齐次坐标之间的转换事实上非常容易，而在COPLUSOPLUS程序中你可以使用OBACKSLASHtextbfOPENCURLY运算符重载CLOSECURLY来完成这个功能，保证在程序中看到的运算是统一的。

回顾一下：首先，我们介绍了向量及其坐标表示，并介绍了向量间的运算；然后，坐标系之间的运动由欧氏变换描述，它由平移和旋转组成。旋转可以由旋转矩阵ODOLLAROBACKSLASHmathrmOPENCURLYSOCLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR描述，而平移直接由一个ODOLLAROBACKSLASHmathbbOPENCURLYRCLOSECURLYOHAT3ODOLLAR向量描述。最后，如果将平移和旋转放在一个矩阵中，就形成了变换矩阵ODOLLAROBACKSLASHmathrmOPENCURLYSECLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR。

OBACKSLASHsectionOPENCURLY实践：EigenCLOSECURLY
本讲的实践部分有两节。第一部分中，将讲解如何使用Eigen来表示矩阵、向量，随后引申至旋转矩阵与变换矩阵的计算。本节的代码在slambook2ODIVIDEch3ODIVIDEuseEigen中。

EigenOBACKSLASHfootnoteOPENCURLY官方主页：OBACKSLASHurlOPENCURLYhttpOCOLONODIVIDEODIVIDEeigenODOTtuxfamilyODOTorgODIVIDEindexODOTphpOQUESTIONMARKtitleOASSIGNMainOUNDERSCOREPageCLOSECURLY。CLOSECURLY是一个COPLUSOPLUS开源线性代数库。它提供了快速的有关矩阵的线性代数运算，还包括解方程等功能。许多上层的软件库也使用Eigen进行矩阵运算，包括g2o、Sophus等。照应本讲的理论部分，我们来学习一下Eigen的编程。

你的PC上可能还没有安装Eigen。请输入以下命令进行安装：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshOCOMMAcaptionOASSIGN终端输入：CLOSESQUARE
sudo aptOMINUSget install libeigen3OMINUSdev
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

大部分常用的库都已在Ubuntu软件源中提供。以后，若想要安装某个库，不妨先搜索一下Ubuntu的软件源中是否已提供。通过apt命令，我们能够方便地安装Eigen。回顾上一讲的知识，我们知道一个库由头文件和库文件组成。Eigen头文件的默认位置在“ODIVIDEusrODIVIDEincludeODIVIDEeigen3ODIVIDE”中。如果不确定，可以输入以下命令查找：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNshOCOMMAcaptionOASSIGN终端输入：CLOSESQUARE
sudo updatedb
locate eigen3
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY
相比于其他库，Eigen的特殊之处在于，它是一个纯用头文件搭建起来的库（这非常神奇！）。这意味着你只能找到它的头文件，而没有ODOTso或ODOTa那样的二进制文件。在使用时，只需引入Eigen的头文件即可，不需要链接库文件（因为它没有库文件）。下面写一段代码来实际练习一下Eigen的使用：

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch3ODIVIDEuseEigenODIVIDEeigenMatrixODOTcppCLOSESQUARE
OSINGLEHASHinclude OGREATiostreamOLESS
using namespace stdOSEMICOLON

OSINGLEHASHinclude OGREATctimeOLESS
ODIVIDEODIVIDE Eigen 核心部分
OSINGLEHASHinclude OGREATEigenODIVIDECoreOLESS
ODIVIDEODIVIDE 稠密矩阵的代数运算（逆，特征值等）
OSINGLEHASHinclude OGREATEigenODIVIDEDenseOLESS
using namespace EigenOSEMICOLON

OSINGLEHASHdefine MATRIXOUNDERSCORESIZE 50

ODIVIDEOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLY
OMULTIPLY 本程序演示了 Eigen 基本类型的使用
OMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYOMULTIPLYODIVIDE

int mainOPENBRACKETint argcOCOMMA char OMULTIPLYOMULTIPLYargvCLOSEBRACKET OPENCURLY
	ODIVIDEODIVIDE Eigen 中所有向量和矩阵都是EigenOCOLONOCOLONMatrix，它是一个模板类。它的前三个参数为：数据类型，行，列
	ODIVIDEODIVIDE 声明一个2OMULTIPLY3的float矩阵
	MatrixOGREATfloatOCOMMA 2OCOMMA 3OLESS matrixOUNDERSCORE23OSEMICOLON
	
	ODIVIDEODIVIDE 同时，Eigen 通过 typedef 提供了许多内置类型，不过底层仍是EigenOCOLONOCOLONMatrix
	ODIVIDEODIVIDE 例如 Vector3d 实质上是 EigenOCOLONOCOLONMatrixOGREATdoubleOCOMMA 3OCOMMA 1OLESS，即三维向量
	Vector3d vOUNDERSCORE3dOSEMICOLON
	ODIVIDEODIVIDE 这是一样的
	MatrixOGREATfloatOCOMMA 3OCOMMA 1OLESS vdOUNDERSCORE3dOSEMICOLON
	
	ODIVIDEODIVIDE Matrix3d 实质上是 EigenOCOLONOCOLONMatrixOGREATdoubleOCOMMA 3OCOMMA 3OLESS
	Matrix3d matrixOUNDERSCORE33 OASSIGN Matrix3dOCOLONOCOLONZeroOPENBRACKETCLOSEBRACKETOSEMICOLON ODIVIDEODIVIDE初始化为零
	ODIVIDEODIVIDE 如果不确定矩阵大小，可以使用动态大小的矩阵
	MatrixOGREATdoubleOCOMMA DynamicOCOMMA DynamicOLESS matrixOUNDERSCOREdynamicOSEMICOLON
	ODIVIDEODIVIDE 更简单的
	MatrixXd matrixOUNDERSCORExOSEMICOLON
	ODIVIDEODIVIDE 这种类型还有很多，我们不一一列举
	
	ODIVIDEODIVIDE 下面是对Eigen阵的操作
	ODIVIDEODIVIDE 输入数据（初始化）
	matrixOUNDERSCORE23 OGREATOGREAT 1OCOMMA 2OCOMMA 3OCOMMA 4OCOMMA 5OCOMMA 6OSEMICOLON
	ODIVIDEODIVIDE 输出
	cout OGREATOGREAT "matrix 2x3 from 1 to 6OCOLON OBACKSLASHn" OGREATOGREAT matrixOUNDERSCORE23 OGREATOGREAT endlOSEMICOLON
	
	ODIVIDEODIVIDE 用OPENBRACKETCLOSEBRACKET访问矩阵中的元素
	cout OGREATOGREAT "print matrix 2x3OCOLON " OGREATOGREAT endlOSEMICOLON
	for OPENBRACKETint i OASSIGN 0OSEMICOLON i OGREAT 2OSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
		for OPENBRACKETint j OASSIGN 0OSEMICOLON j OGREAT 3OSEMICOLON jOPLUSOPLUSCLOSEBRACKET cout OGREATOGREAT matrixOUNDERSCORE23OPENBRACKETiOCOMMA jCLOSEBRACKET OGREATOGREAT "OBACKSLASHt"OSEMICOLON
		cout OGREATOGREAT endlOSEMICOLON
	CLOSECURLY
	
	ODIVIDEODIVIDE 矩阵和向量相乘（实际上仍是矩阵和矩阵）
	vOUNDERSCORE3d OGREATOGREAT 3OCOMMA 2OCOMMA 1OSEMICOLON
	vdOUNDERSCORE3d OGREATOGREAT 4OCOMMA 5OCOMMA 6OSEMICOLON
	
	ODIVIDEODIVIDE 但是在Eigen里你不能混合两种不同类型的矩阵，像这样是错的
	ODIVIDEODIVIDE MatrixOGREATdoubleOCOMMA 2OCOMMA 1OLESS resultOUNDERSCOREwrongOUNDERSCOREtype OASSIGN matrixOUNDERSCORE23 OMULTIPLY vOUNDERSCORE3dOSEMICOLON
	ODIVIDEODIVIDE 应该显式转换
	MatrixOGREATdoubleOCOMMA 2OCOMMA 1OLESS result OASSIGN matrixOUNDERSCORE23ODOTcastOGREATdoubleOLESSOPENBRACKETCLOSEBRACKET OMULTIPLY vOUNDERSCORE3dOSEMICOLON
	cout OGREATOGREAT "OPENSQUARE1OCOMMA2OCOMMA3OSEMICOLON4OCOMMA5OCOMMA6CLOSESQUAREOMULTIPLYOPENSQUARE3OCOMMA2OCOMMA1CLOSESQUAREOASSIGN" OGREATOGREAT resultODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
	
	MatrixOGREATfloatOCOMMA 2OCOMMA 1OLESS result2 OASSIGN matrixOUNDERSCORE23 OMULTIPLY vdOUNDERSCORE3dOSEMICOLON
	cout OGREATOGREAT "OPENSQUARE1OCOMMA2OCOMMA3OSEMICOLON4OCOMMA5OCOMMA6CLOSESQUAREOMULTIPLYOPENSQUARE4OCOMMA5OCOMMA6CLOSESQUAREOCOLON " OGREATOGREAT result2ODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
	
	ODIVIDEODIVIDE 同样你不能搞错矩阵的维度
	ODIVIDEODIVIDE 试着取消下面的注释，看看Eigen会报什么错
	ODIVIDEODIVIDE EigenOCOLONOCOLONMatrixOGREATdoubleOCOMMA 2OCOMMA 3OLESS resultOUNDERSCOREwrongOUNDERSCOREdimension OASSIGN matrixOUNDERSCORE23ODOTcastOGREATdoubleOLESSOPENBRACKETCLOSEBRACKET OMULTIPLY vOUNDERSCORE3dOSEMICOLON
	
	ODIVIDEODIVIDE 一些矩阵运算
	ODIVIDEODIVIDE 四则运算就不演示了，直接用OPLUSOMINUSOMULTIPLYODIVIDE即可。
	matrixOUNDERSCORE33 OASSIGN Matrix3dOCOLONOCOLONRandomOPENBRACKETCLOSEBRACKETOSEMICOLON      ODIVIDEODIVIDE 随机数矩阵
	cout OGREATOGREAT "random matrixOCOLON OBACKSLASHn" OGREATOGREAT matrixOUNDERSCORE33 OGREATOGREAT endlOSEMICOLON
	cout OGREATOGREAT "transposeOCOLON OBACKSLASHn" OGREATOGREAT matrixOUNDERSCORE33ODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON ODIVIDEODIVIDE 转置
	cout OGREATOGREAT "sumOCOLON " OGREATOGREAT matrixOUNDERSCORE33ODOTsumOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON               ODIVIDEODIVIDE 各元素和
	cout OGREATOGREAT "traceOCOLON " OGREATOGREAT matrixOUNDERSCORE33ODOTtraceOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON           ODIVIDEODIVIDE 迹
	cout OGREATOGREAT "times 10OCOLON OBACKSLASHn" OGREATOGREAT 10 OMULTIPLY matrixOUNDERSCORE33 OGREATOGREAT endlOSEMICOLON         ODIVIDEODIVIDE 数乘
	cout OGREATOGREAT "inverseOCOLON OBACKSLASHn" OGREATOGREAT matrixOUNDERSCORE33ODOTinverseOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON     ODIVIDEODIVIDE 逆
	cout OGREATOGREAT "detOCOLON " OGREATOGREAT matrixOUNDERSCORE33ODOTdeterminantOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON       ODIVIDEODIVIDE 行列式
	
	ODIVIDEODIVIDE 特征值
	ODIVIDEODIVIDE 实对称矩阵可以保证对角化成功
	SelfAdjointEigenSolverOGREATMatrix3dOLESS eigenOUNDERSCOREsolverOPENBRACKETmatrixOUNDERSCORE33ODOTtransposeOPENBRACKETCLOSEBRACKET OMULTIPLY matrixOUNDERSCORE33CLOSEBRACKETOSEMICOLON
	cout OGREATOGREAT "Eigen values OASSIGN OBACKSLASHn" OGREATOGREAT eigenOUNDERSCOREsolverODOTeigenvaluesOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
	cout OGREATOGREAT "Eigen vectors OASSIGN OBACKSLASHn" OGREATOGREAT eigenOUNDERSCOREsolverODOTeigenvectorsOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
	
	ODIVIDEODIVIDE 解方程
	ODIVIDEODIVIDE 我们求解 matrixOUNDERSCORENN OMULTIPLY x OASSIGN vOUNDERSCORENd 这个方程
	ODIVIDEODIVIDE N的大小在前边的宏里定义，它由随机数生成
	ODIVIDEODIVIDE 直接求逆自然是最直接的，但是求逆运算量大
	
	MatrixOGREATdoubleOCOMMA MATRIXOUNDERSCORESIZEOCOMMA MATRIXOUNDERSCORESIZEOLESS matrixOUNDERSCORENN
		OASSIGN MatrixXdOCOLONOCOLONRandomOPENBRACKETMATRIXOUNDERSCORESIZEOCOMMA MATRIXOUNDERSCORESIZECLOSEBRACKETOSEMICOLON
	matrixOUNDERSCORENN OASSIGN matrixOUNDERSCORENN OMULTIPLY matrixOUNDERSCORENNODOTtransposeOPENBRACKETCLOSEBRACKETOSEMICOLON  ODIVIDEODIVIDE 保证半正定
	MatrixOGREATdoubleOCOMMA MATRIXOUNDERSCORESIZEOCOMMA 1OLESS vOUNDERSCORENd OASSIGN MatrixXdOCOLONOCOLONRandomOPENBRACKETMATRIXOUNDERSCORESIZEOCOMMA 1CLOSEBRACKETOSEMICOLON
	
	clockOUNDERSCOREt timeOUNDERSCOREstt OASSIGN clockOPENBRACKETCLOSEBRACKETOSEMICOLON ODIVIDEODIVIDE 计时
	ODIVIDEODIVIDE 直接求逆
	MatrixOGREATdoubleOCOMMA MATRIXOUNDERSCORESIZEOCOMMA 1OLESS x OASSIGN matrixOUNDERSCORENNODOTinverseOPENBRACKETCLOSEBRACKET OMULTIPLY vOUNDERSCORENdOSEMICOLON
	cout OGREATOGREAT "time of normal inverse is "
	     OGREATOGREAT 1000 OMULTIPLY OPENBRACKETclockOPENBRACKETCLOSEBRACKET OMINUS timeOUNDERSCOREsttCLOSEBRACKET ODIVIDE OPENBRACKETdoubleCLOSEBRACKET CLOCKSOUNDERSCOREPEROUNDERSCORESEC OGREATOGREAT "ms" OGREATOGREAT endlOSEMICOLON
	cout OGREATOGREAT "x OASSIGN " OGREATOGREAT xODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
	
	ODIVIDEODIVIDE 通常用矩阵分解来求，例如QR分解，速度会快很多
	timeOUNDERSCOREstt OASSIGN clockOPENBRACKETCLOSEBRACKETOSEMICOLON
	x OASSIGN matrixOUNDERSCORENNODOTcolPivHouseholderQrOPENBRACKETCLOSEBRACKETODOTsolveOPENBRACKETvOUNDERSCORENdCLOSEBRACKETOSEMICOLON
	cout OGREATOGREAT "time of Qr decomposition is "
	     OGREATOGREAT 1000 OMULTIPLY OPENBRACKETclockOPENBRACKETCLOSEBRACKET OMINUS timeOUNDERSCOREsttCLOSEBRACKET ODIVIDE OPENBRACKETdoubleCLOSEBRACKET CLOCKSOUNDERSCOREPEROUNDERSCORESEC OGREATOGREAT "ms" OGREATOGREAT endlOSEMICOLON
	cout OGREATOGREAT "x OASSIGN " OGREATOGREAT xODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
	
	ODIVIDEODIVIDE 对于正定矩阵，还可以用cholesky分解来解方程
	timeOUNDERSCOREstt OASSIGN clockOPENBRACKETCLOSEBRACKETOSEMICOLON
	x OASSIGN matrixOUNDERSCORENNODOTldltOPENBRACKETCLOSEBRACKETODOTsolveOPENBRACKETvOUNDERSCORENdCLOSEBRACKETOSEMICOLON
	cout OGREATOGREAT "time of ldlt decomposition is "
	     OGREATOGREAT 1000 OMULTIPLY OPENBRACKETclockOPENBRACKETCLOSEBRACKET OMINUS timeOUNDERSCOREsttCLOSEBRACKET ODIVIDE OPENBRACKETdoubleCLOSEBRACKET CLOCKSOUNDERSCOREPEROUNDERSCORESEC OGREATOGREAT "ms" OGREATOGREAT endlOSEMICOLON
	cout OGREATOGREAT "x OASSIGN " OGREATOGREAT xODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
	
	return 0OSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

这个例程演示了Eigen矩阵的基本操作与运算。要编译它，需要在CMakeListsODOTtxt里指定Eigen的头文件目录：
OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUAREcaptionOASSIGNslambook2ODIVIDEch3ODIVIDEuseEigenODIVIDECMakeListsODOTtxtCLOSESQUARE
OSINGLEHASH 添加头文件
includeOUNDERSCOREdirectoriesOPENBRACKET "ODIVIDEusrODIVIDEincludeODIVIDEeigen3" CLOSEBRACKET
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

重复一遍，因为Eigen库只有头文件，所以不需要再用targetOBACKSLASHOUNDERSCORElinkOBACKSLASHOUNDERSCORElibraries语句将程序链接到库上。不过，对于其他大部分库，多数时候需要用到链接命令。这里的做法并不见得是最好的，因为其他人可能把Eigen安装在了不同位置，那么就必须手动修改这里的头文件目录。在之后的工作中，我们会使用findOBACKSLASHOUNDERSCOREpackage命令去搜索库，不过在本讲中暂时保持这个样子。编译好这个程序后，运行它，可以看到各矩阵的输出结果。

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUAREcaptionOASSIGN终端输入：CLOSESQUARE
OMODULO buildODIVIDEeigenMatrix
matrix 2x3 from 1 to 6OCOLON 
1 2 3
4 5 6
print matrix 2x3OCOLON 
1	2	3	
4	5	6	
OPENSQUARE1OCOMMA2OCOMMA3OSEMICOLON4OCOMMA5OCOMMA6CLOSESQUAREOMULTIPLYOPENSQUARE3OCOMMA2OCOMMA1CLOSESQUAREOASSIGN10 28
OPENSQUARE1OCOMMA2OCOMMA3OSEMICOLON4OCOMMA5OCOMMA6CLOSESQUAREOMULTIPLYOPENSQUARE4OCOMMA5OCOMMA6CLOSESQUAREOCOLON 32 77
random matrixOCOLON 
0ODOT680375   0ODOT59688 OMINUS0ODOT329554
OMINUS0ODOT211234  0ODOT823295  0ODOT536459
0ODOT566198 OMINUS0ODOT604897 OMINUS0ODOT444451
transposeOCOLON 
0ODOT680375 OMINUS0ODOT211234  0ODOT566198
0ODOT59688  0ODOT823295 OMINUS0ODOT604897
OMINUS0ODOT329554  0ODOT536459 OMINUS0ODOT444451
sumOCOLON 1ODOT61307
traceOCOLON 1ODOT05922
times 10OCOLON 
6ODOT80375   5ODOT9688 OMINUS3ODOT29554
OMINUS2ODOT11234  8ODOT23295  5ODOT36459
5ODOT66198 OMINUS6ODOT04897 OMINUS4ODOT44451
inverseOCOLON 
OMINUS0ODOT198521   2ODOT22739    2ODOT8357
1ODOT00605 OMINUS0ODOT555135  OMINUS1ODOT41603
OMINUS1ODOT62213   3ODOT59308   3ODOT28973
detOCOLON 0ODOT208598
……
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

由于在代码中给出了详细的注释，在此就不一一解释每行语句了。本书中，我们将仅给出几处重要地方的说明（后面的实践部分亦将保持这个风格）。

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 读者最好亲手输入一遍上面的代码（不包括注释）。至少要编译运行一遍上面的程序。
	
	OBACKSLASHitem Kdevelop可能不会提示COPLUSOPLUS成员运算，这是它做得不够完善导致的。请照着上面的内容输入即可，不必理会它是否提示错误。Clion则会完整地给出提示。
	
	OBACKSLASHitem Eigen提供的矩阵和MATLAB很相似，几乎所有的数据都当作矩阵来处理。但是，为了实现更好的效率，在Eigen中需要指定矩阵的大小和类型。对于在编译时期就知道大小的矩阵，处理起来会比动态变化大小的矩阵更快一些。因此，像旋转矩阵、变换矩阵这样的数据，完全可在编译时期确定它们的大小和数据类型。
	
	OBACKSLASHitem Eigen内部的矩阵实现比较复杂，这里不做介绍，我们希望你像使用float、double等内置数据类型那样使用Eigen的矩阵。这应该是符合其设计初衷的。
	
	OBACKSLASHitem Eigen矩阵不支持自动类型提升，这和COPLUSOPLUS的内建数据类型有较大差异。在COPLUSOPLUS程序中，我们可以把一个float数据和double数据相加、相乘，OBACKSLASHtextbfOPENCURLY编译器会自动把数据类型转换为最合适的那种CLOSECURLY。而在Eigen中，出于性能的考虑，必须OBACKSLASHtextbfOPENCURLY显式地CLOSECURLY对矩阵类型进行转换。而如果忘了这样做，Eigen会（不太友好地）提示你一个“YOU MIXED DIFFERENT NUMERIC TYPES ODOTODOTODOT”的编译错误。你可以尝试找一下这条信息出现在错误提示的哪个部分。如果错误信息太长最好保存到一个文件里再找。
	
	OBACKSLASHitem 同理，在计算过程中也需要保证矩阵维数的正确性，否则会出现“YOU MIXED MATRICES OF DIFFERENT SIZES”错误。请不要抱怨这种错误提示方式，对于COPLUSOPLUS模板元编程，能够提示出可以阅读的信息已经是很幸运的了。以后，若发现Eigen出错，你可以直接寻找大写的部分，推测出了什么问题。
	
	OBACKSLASHitem 我们的例程只介绍了基本的矩阵运算。你可以阅读Eigen官网教程：OBACKSLASHOBACKSLASHOPENCURLYOBACKSLASHurlOPENCURLYhttpOCOLONODIVIDEODIVIDEeigenODOTtuxfamilyODOTorgODIVIDEdoxOMINUSdevelODIVIDEmodulesODOThtmlCLOSECURLYCLOSECURLY学习更多的Eigen知识。这里只演示了最简单的部分，能看懂演示程序不等于你已经能够熟练操作Eigen。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

最后一段代码中比较了求逆与求QR分解的运行效率，你可以看看自己机器上的时间差异，两种方法是否有明显的差异？

OBACKSLASHsectionOPENCURLY旋转向量和欧拉角CLOSECURLY
OBACKSLASHsubsectionOPENCURLY旋转向量CLOSECURLY
我们重新回到理论部分。有了旋转矩阵来描述旋转，有了变换矩阵描述一个6自由度的三维刚体运动，是不是已经足够了呢？矩阵表示方式至少有以下几个缺点：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem ODOLLAROBACKSLASHmathrmOPENCURLYSOCLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR的旋转矩阵有9个量，但一次旋转只有3个自由度。因此这种表达方式是冗余的。同理，变换矩阵用16个量表达了6自由度的变换。那么，是否有更紧凑的表示呢？
	OBACKSLASHitem 旋转矩阵自身带有约束：它必须是个正交矩阵，且行列式为1。变换矩阵也是如此。当想要估计或优化一个旋转矩阵ODIVIDE变换矩阵时，这些约束会使得求解变得更困难。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

因此，我们希望有一种方式能够紧凑地描述旋转和平移。例如，用一个三维向量表达旋转，用六维向量表达变换，可行吗？事实上，任意旋转都可以用OBACKSLASHtextbfOPENCURLY一个旋转轴和一个旋转角CLOSECURLY来刻画。于是，我们可以使用一个向量，其方向与旋转轴一致，而长度等于旋转角。这种向量称为OBACKSLASHtextbfOPENCURLY旋转向量CLOSECURLY（或轴角ODIVIDE角轴，AxisOMINUSAngle），只需一个三维向量即可描述旋转。同样，对于变换矩阵，我们使用一个旋转向量和一个平移向量即可表达一次变换。这时的变量维数正好是六维。

考虑某个用ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR表示的旋转。如果用旋转向量来描述，假设旋转轴为一个单位长度的向量ODOLLAROBACKSLASHbmOPENCURLYnCLOSECURLYODOLLAR，角度为ODOLLAROBACKSLASHthetaODOLLAR，那么向量ODOLLAROBACKSLASHtheta OBACKSLASHbmOPENCURLYnCLOSECURLYODOLLAR也可以描述这个旋转。于是，我们要问，两种表达方式之间有什么联系吗？事实上推导它们的转换关系并不难。从旋转向量到旋转矩阵的转换过程由OBACKSLASHtextbfOPENCURLY罗德里格斯公式CLOSECURLY（Rodrigues's Formula ）表明，由于推导过程比较复杂，这里不作描述，只给出转换的结果OBACKSLASHfootnoteOPENCURLY感兴趣的读者请参见OBACKSLASHurlOPENCURLYhttpsOCOLONODIVIDEODIVIDEenODOTwikipediaODOTorgODIVIDEwikiODIVIDERodriguesOBACKSLASHOMODULO27OUNDERSCORErotationOUNDERSCOREformulaCLOSECURLY，事实上下一章会从李代数层面给出一个证明。CLOSECURLY：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONrogriduesCLOSECURLY
OBACKSLASHbmOPENCURLYRCLOSECURLY OASSIGN OBACKSLASHcos OBACKSLASHtheta OBACKSLASHbmOPENCURLYICLOSECURLY OPLUS OBACKSLASHleftOPENBRACKET OPENCURLY1 OMINUS OBACKSLASHcos OBACKSLASHtheta CLOSECURLY OBACKSLASHrightCLOSEBRACKET OBACKSLASHbmOPENCURLYnCLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYnCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OPLUS OBACKSLASHsin OBACKSLASHtheta OPENCURLY OBACKSLASHbmOPENCURLYnCLOSECURLYOHAT OBACKSLASHwedge CLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

符号ODOLLAROHATOBACKSLASHwedgeODOLLAR是向量到反对称的转换符，见式OBACKSLASHeqrefOPENCURLYeqOCOLONcrossCLOSECURLY。反之，我们也可以计算从一个旋转矩阵到旋转向量的转换。对于转角ODOLLAROBACKSLASHthetaODOLLAR，取两边的OBACKSLASHtextbfOPENCURLY迹CLOSECURLYOBACKSLASHfootnoteOPENCURLY求OBACKSLASHtextbfOPENCURLY迹CLOSECURLY（trace）即是求矩阵的对角线元素之和。CLOSECURLY，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYalignedCLOSECURLY
  OBACKSLASHmathrmOPENCURLYtrCLOSECURLY OBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHrightCLOSEBRACKET OBANDOASSIGN OBACKSLASHcos OBACKSLASHtheta OBACKSLASHmathopOPENCURLYCLOSECURLYOBACKSLASHONOTOBACKSLASHmathrmOPENCURLYtrCLOSECURLYOBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYICLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OBACKSLASHleftOPENBRACKET OPENCURLY1 OMINUS OBACKSLASHcos OBACKSLASHtheta CLOSECURLY OBACKSLASHrightCLOSEBRACKET OBACKSLASHmathopOPENCURLYCLOSECURLYOBACKSLASHONOTOBACKSLASHmathrmOPENCURLYtrCLOSECURLY OBACKSLASHleftOPENBRACKET OPENCURLY OBACKSLASHbmOPENCURLYnCLOSECURLY OPENCURLYOBACKSLASHbmOPENCURLYnCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKET OPLUS OBACKSLASHsin OBACKSLASHtheta OBACKSLASHmathopOPENCURLYCLOSECURLYOBACKSLASHONOTOBACKSLASHmathrmOPENCURLYtrCLOSECURLY OPENBRACKETOPENCURLYOBACKSLASHbmOPENCURLYnCLOSECURLYOHAT OBACKSLASHwedge CLOSECURLYCLOSEBRACKETOBACKSLASHOBACKSLASH
OBANDOASSIGN 3OBACKSLASHcos OBACKSLASHtheta  OPLUS OPENBRACKET1 OMINUS OBACKSLASHcos OBACKSLASHtheta CLOSEBRACKETOBACKSLASHOBACKSLASH
OBANDOASSIGN 1 OPLUS 2OBACKSLASHcos OBACKSLASHtheta ODOT
OBACKSLASHendOPENCURLYalignedCLOSECURLY 
OBACKSLASHendOPENCURLYequationCLOSECURLY

因此：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONR2thetaCLOSECURLY
OBACKSLASHtheta OASSIGN OBACKSLASHarccos OPENBRACKET OBACKSLASHfracOPENCURLYOBACKSLASHmathrmOPENCURLYtrCLOSECURLYOPENBRACKETOBACKSLASHbmOPENCURLYRCLOSECURLYCLOSEBRACKET OMINUS 1CLOSECURLYOPENCURLY2CLOSECURLY  CLOSEBRACKET ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

关于转轴ODOLLAROBACKSLASHbmOPENCURLYnCLOSECURLYODOLLAR，由于旋转轴上的向量在旋转后不发生改变，说明：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYnCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYnCLOSECURLYODOT	
OBACKSLASHendOPENCURLYequationCLOSECURLY

因此，转轴ODOLLAROBACKSLASHbmOPENCURLYnCLOSECURLYODOLLAR是矩阵ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR特征值1对应的特征向量。求解此方程，再归一化，就得到了旋转轴。读者也可以从“旋转轴经过旋转之后不变”的几何角度看待这个方程。顺便提一下，这里的两个转换公式在下一讲仍将出现，你会发现它们正是ODOLLAROBACKSLASHmathrmOPENCURLYSOCLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR上李群与李代数的对应关系。

OBACKSLASHsubsectionOPENCURLY欧拉角CLOSECURLY
下面来说说欧拉角。

无论是旋转矩阵、旋转向量，它们虽然能描述旋转，但对我们人类是非常不直观的。当我们看到一个旋转矩阵或旋转向量时，很难想象出这个旋转究竟是什么样的。当它们变换时，我们也不知道物体是向哪个方向在转动。而欧拉角则提供了一种非常直观的方式来描述旋转——它使用了OBACKSLASHtextbfOPENCURLY3个分离的转角CLOSECURLY，把一个旋转分解成3次绕不同轴的旋转。而人类很容易理解绕单个轴旋转的过程。但是，由于分解方式有许多种，所以欧拉角也存在着众多不同的、易于混淆的定义方法。比如说，先绕ODOLLARXODOLLAR轴旋转，再绕ODOLLARYODOLLAR轴，最后绕ODOLLARZODOLLAR轴，就得到了一个ODOLLARXYZODOLLAR轴的旋转。同理，可以定义ODOLLARZYZODOLLAR、ODOLLARZYXODOLLAR等旋转方式。如果讨论得更细一些，还需要区分每次是绕OBACKSLASHtextbfOPENCURLY固定轴CLOSECURLY旋转的，还是绕OBACKSLASHtextbfOPENCURLY旋转之后的轴CLOSECURLY旋转的，这也会给出不一样的定义方式。

这种定义方式上的不确定性带来了很多实用当中的困难，所幸在特定领域内，欧拉角通常有统一的定义方式。你或许在航空、航模中听说过“俯仰角”“偏航角”这些词。欧拉角当中比较常用的一种，便是用“偏航−俯仰−滚转”（yawOMINUSpitchOMINUSroll）3个角度来描述一个旋转。由于它等价于ODOLLARZYXODOLLAR轴的旋转，因此就以ODOLLARZYXODOLLAR为例。假设一个刚体的前方（朝向我们的方向）为ODOLLARXODOLLAR轴，右侧为ODOLLARYODOLLAR轴，上方为ODOLLARZODOLLAR轴，如OBACKSLASHautorefOPENCURLYfigOCOLONeulerAnglesCLOSECURLY所示。那么，ODOLLARZYXODOLLAR转角相当于把任意旋转分解成以下3个轴上的转角：

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 绕物体的ODOLLARZODOLLAR轴旋转，得到偏航角yaw；
	OBACKSLASHitem 绕OBACKSLASHtextbfOPENCURLY旋转之后CLOSECURLY的ODOLLARYODOLLAR轴旋转，得到俯仰角pitch；
	OBACKSLASHitem 绕OBACKSLASHtextbfOPENCURLY旋转之后CLOSECURLY的ODOLLARXODOLLAR轴旋转，得到滚转角roll。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOTtCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN1ODOT0OBACKSLASHtextwidthCLOSESQUAREOPENCURLYrigidMotionODIVIDEeulerAnglesODOTpdfCLOSECURLY
	OBACKSLASHcaptionOPENCURLY欧拉角的旋转示意图。上方为ZYX角定义。下方为pitchOASSIGNODOLLAR90OHATOBACKSLASHcircODOLLAR时，第三次旋转与第一次滚转角相同，使得系统丢失了一个自由度。如果你还没有理解万向锁，可以看看相关视频，理解起来会更方便。CLOSECURLY
	OBACKSLASHlabelOPENCURLYfigOCOLONeulerAnglesCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

此时，可以使用ODOLLAROPENSQUARErOCOMMApOCOMMAyCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR这样一个三维的向量描述任意旋转。这个向量十分直观，我们可以从这个向量想象出旋转的过程。其他的欧拉角亦是通过这种方式，把旋转分解到3个轴上，得到一个三维的向量，只不过选用的轴及顺序不一样。这里介绍的rpy角是比较常用的一种，只有很少的欧拉角种类会有rpy这样脍炙人口的名字。不同的欧拉角是按照旋转轴的顺序来称呼的。例如，rpy角的旋转顺序是ODOLLARZYXODOLLAR。同样，也有ODOLLARXYZOCOMMA ZYZODOLLAR这样的欧拉角——但是它们就没有专门的名字了。值得一提的是，大部分领域在使用欧拉角时都有各自的坐标方向和顺序上的习惯，不一定和我们这里说的相同。

欧拉角的一个重大缺点是会碰到著名的OBACKSLASHtextbfOPENCURLY万向锁问题CLOSECURLY（Gimbal LockOBACKSLASHfootnoteOPENCURLYOBACKSLASHurlOPENCURLYhttpsOCOLONODIVIDEODIVIDEenODOTwikipediaODOTorgODIVIDEwikiODIVIDEGimbalOUNDERSCORElockCLOSECURLY。CLOSECURLY）：在俯仰角为ODOLLAROBACKSLASHpm 90 OHATOBACKSLASHcirc ODOLLAR时，第一次旋转与第三次旋转将使用同一个轴，使得系统丢失了一个自由度（由3次旋转变成了2次旋转）。这被称为奇异性问题，在其他形式的欧拉角中也同样存在。理论上可以证明，只要想用3个实数来表达三维旋转时，都会不可避免地碰到奇异性问题OBACKSLASHfootnoteOPENCURLY旋转向量也有奇异性，发生在转角ODOLLAROBACKSLASHthetaODOLLAR超过ODOLLAR2OBACKSLASHpiODOLLAR而产生周期性时。CLOSECURLY。由于这种原理，欧拉角不适于插值和迭代，往往只用于人机交互中。我们也很少在SLAM程序中直接使用欧拉角表达姿态，同样不会在滤波或优化中使用欧拉角表达旋转（因为它具有奇异性）。不过，若你想验证自己的算法是否有错，转换成欧拉角能够帮你快速分辨结果是否正确。在某些主体主要为2D运动的场合（例如扫地机、自动驾驶车辆），我们也可以把旋转分解成三个欧拉角，然后把其中一个（例如偏航角）拿出来作为定位信息输出。

OBACKSLASHsectionOPENCURLY四元数CLOSECURLY
OBACKSLASHsubsectionOPENCURLY四元数的定义CLOSECURLY
旋转矩阵用9个量描述3自由度的旋转，具有冗余性；欧拉角和旋转向量是紧凑的，但具有奇异性。事实上，我们OBACKSLASHtextbfOPENCURLY找不到不带奇异性的三维向量描述方式CLOSECURLYOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYStuelpnagel1964CLOSECURLYCLOSECURLY。这有点类似于用两个坐标表示地球表面（如经度和纬度），将必定存在奇异性（纬度为ODOLLAROBACKSLASHpm 90OHATOBACKSLASHcircODOLLAR时经度无意义）。

回忆以前学习过的复数。我们用复数集ODOLLAROBACKSLASHmathbbOPENCURLYCCLOSECURLYODOLLAR表示复平面上的向量，而复数的乘法则表示复平面上的旋转：例如，乘上复数ODOLLARiODOLLAR相当于逆时针把一个复向量旋转ODOLLAR90OHATOBACKSLASHcircODOLLAR。类似地，在表达三维空间旋转时，也有一种类似于复数的代数：OBACKSLASHtextbfOPENCURLY四元数CLOSECURLY（Quaternion）。四元数是Hamilton找到的一种扩展的复数。它OBACKSLASHtextbfOPENCURLY既是紧凑的，也没有奇异性CLOSECURLY。如果说缺点，四元数不够直观，其运算稍复杂些。

把四元数与复数类比可以帮助你更快地理解四元数。例如，当我们想要将复平面的向量旋转ODOLLAROBACKSLASHthetaODOLLAR角时，可以给这个复向量乘以ODOLLAROBACKSLASHmathrmOPENCURLYeCLOSECURLYOHATOPENCURLYiOBACKSLASHthetaCLOSECURLYODOLLAR。这是极坐标表示的复数，它也可以写成普通的形式，只要使用欧拉公式即可：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHmathrmOPENCURLYeCLOSECURLYOHATOPENCURLYiOBACKSLASHthetaCLOSECURLY OASSIGN OBACKSLASHcos OBACKSLASHtheta OPLUS i OBACKSLASHsin OBACKSLASHthetaODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
这正是一个单位长度的复数。所以，在二维情况下，旋转可以由OBACKSLASHtextbfOPENCURLY单位复数CLOSECURLY来描述。类似地，我们会看到，三维旋转则可以由OBACKSLASHtextbfOPENCURLY单位四元数CLOSECURLY来描述。

一个四元数ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR拥有一个实部和三个虚部。本书把实部写在前面（也有地方把实部写在后面），像下面这样：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
 OBACKSLASHbmOPENCURLYqCLOSECURLY OASSIGN qOUNDERSCORE0 OPLUS qOUNDERSCORE1 i OPLUS qOUNDERSCORE2 j OPLUS qOUNDERSCORE3 kOCOMMA
OBACKSLASHendOPENCURLYequationCLOSECURLY
其中ODOLLARiOCOMMAjOCOMMAkODOLLAR为四元数的三个虚部。这三个虚部满足以下关系式：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONquaternionVirtualCLOSECURLY
OBACKSLASHleftOBACKSLASHOPENCURLY OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYlCLOSECURLY
OPENCURLYiOHAT2CLOSECURLY OASSIGN OPENCURLYjOHAT2CLOSECURLY OASSIGN OPENCURLYkOHAT2CLOSECURLY OASSIGN  OMINUS 1OBACKSLASHOBACKSLASH
ij OASSIGN kOCOMMAji OASSIGN  OMINUS kOBACKSLASHOBACKSLASH
jk OASSIGN iOCOMMAkj OASSIGN  OMINUS iOBACKSLASHOBACKSLASH
ki OASSIGN jOCOMMAik OASSIGN  OMINUS j
OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightODOT ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
如果把ODOLLARiOCOMMAjOCOMMAkODOLLAR看成三个坐标轴，那么它们与自己的乘法和复数一样，相互之间的乘法和外积一样。有时人们也用一个标量和一个向量来表达四元数：
OBACKSLASHOPENSQUARE
 OBACKSLASHbmOPENCURLYqCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE sOCOMMA OBACKSLASHbmOPENCURLYvCLOSECURLY OBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOCOMMA OBACKSLASHquad sOASSIGNqOUNDERSCORE0 OBACKSLASHin OBACKSLASHmathbbOPENCURLYRCLOSECURLYOCOMMAOBACKSLASHquad OBACKSLASHbmOPENCURLYvCLOSECURLY OASSIGN OPENSQUAREqOUNDERSCORE1OCOMMA qOUNDERSCORE2OCOMMA qOUNDERSCORE3CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHin OBACKSLASHmathbbOPENCURLYRCLOSECURLYOHAT3OCOMMA
OBACKSLASHCLOSESQUARE
这里，ODOLLARsODOLLAR称为四元数的实部，而ODOLLAROBACKSLASHbmOPENCURLYvCLOSECURLYODOLLAR称为它的虚部。如果一个四元数的虚部为ODOLLAROBACKSLASHbmOPENCURLY0CLOSECURLYODOLLAR，称之为OBACKSLASHtextbfOPENCURLY实四元数CLOSECURLY。反之，若它的实部为ODOLLAR0ODOLLAR，则称之为OBACKSLASHtextbfOPENCURLY虚四元数CLOSECURLY。

OMODULO考虑到三维空间需要3个轴，四元数也有3个虚部，那么，一个虚四元数能不能对应到一个空间点呢？事实上我们就是这样做的。

可以用OBACKSLASHtextbfOPENCURLY单位四元数CLOSECURLY表示三维空间中任意一个旋转，不过这种表达方式和复数有着微妙的不同。在复数中，乘以ODOLLARiODOLLAR意味着旋转ODOLLAR90OHATOBACKSLASHcircODOLLAR。这是否意味着四元数中，乘ODOLLARiODOLLAR就是绕ODOLLARiODOLLAR轴旋转ODOLLAR90OHATOBACKSLASHcircODOLLAR？那么，ODOLLARijOASSIGNkODOLLAR是否意味着，先绕ODOLLARiODOLLAR转ODOLLAR90OHATOBACKSLASHcircODOLLAR，再绕ODOLLARjODOLLAR转ODOLLAR90OHATOBACKSLASHcircODOLLAR，就等于绕ODOLLARkODOLLAR转ODOLLAR90OHATOBACKSLASHcircODOLLAR？读者可以找一部手机比划一下——然后你会发现情况并不是这样。正确的情形应该是，乘以ODOLLARiODOLLAR对应着旋转ODOLLAR180OHATOBACKSLASHcircODOLLAR，这样才能保证ODOLLARijOASSIGNkODOLLAR的性质。而ODOLLARiOHAT2OASSIGNOMINUS1ODOLLAR，意味着绕ODOLLARiODOLLAR轴旋转ODOLLAR360OHATOBACKSLASHcircODOLLAR后得到一个相反的东西。这个东西要旋转两周才会和它原先的样子相等。

这似乎有些玄妙了，完整的解释需要引入太多额外的东西，我们还是冷静一下回到眼前。至少，我们知道单位四元数能够表达三维空间的旋转。那么四元数本身有些什么性质，它们互相之间又可以做哪些运算呢？下面我们先考察四元数之间的运算法则。

OBACKSLASHsubsectionOPENCURLY四元数的运算CLOSECURLY
四元数和通常复数一样，可以进行一系列的运算。常见的有四则运算、数乘、求逆、共轭等。下面分别介绍。

现有两个四元数ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREaOCOMMA OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREbODOLLAR，它们的向量表示为ODOLLAROPENSQUAREsOUNDERSCOREaOCOMMA OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREaCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOCOMMA OPENSQUAREsOUNDERSCOREbOCOMMA OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREbCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR，或者原始四元数表示为：
OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREa OASSIGN sOUNDERSCOREaOPLUSxOUNDERSCOREaiOPLUSyOUNDERSCOREajOPLUSzOUNDERSCOREakOCOMMA OBACKSLASHquad OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREb  OASSIGN sOUNDERSCOREbOPLUSxOUNDERSCOREbiOPLUSyOUNDERSCOREbjOPLUSzOUNDERSCOREbkODOT
OBACKSLASHCLOSESQUARE
那么，其运算可表示如下。

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem OPENCURLYOBACKSLASHemphOPENCURLY加法和减法CLOSECURLYCLOSECURLY
	
	四元数ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREaOCOMMA OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREbODOLLAR的加减运算为：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY 	
	OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREa OBACKSLASHpm OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREb OASSIGN OBACKSLASHleftOPENSQUARE sOUNDERSCOREa OBACKSLASHpm sOUNDERSCOREbOCOMMA OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREa OBACKSLASHpm OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREb OBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	OBACKSLASHitemOPENCURLYOBACKSLASHemphOPENCURLY乘法CLOSECURLYCLOSECURLY
	
	乘法是把ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREaODOLLAR的每一项与ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREbODOLLAR的每项相乘，最后相加，虚部要按照式OBACKSLASHeqrefOPENCURLYeqOCOLONquaternionVirtualCLOSECURLY进行。整理可得：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHbeginOPENCURLYalignedCLOSECURLY
	OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREa OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREb OBANDOASSIGN OPENCURLYsOUNDERSCOREaCLOSECURLYOPENCURLYsOUNDERSCOREbCLOSECURLY OMINUS OPENCURLYxOUNDERSCOREaCLOSECURLYOPENCURLYxOUNDERSCOREbCLOSECURLY OMINUS OPENCURLYyOUNDERSCOREaCLOSECURLYOPENCURLYyOUNDERSCOREbCLOSECURLY OMINUS OPENCURLYzOUNDERSCOREaCLOSECURLYOPENCURLYzOUNDERSCOREbCLOSECURLYOBACKSLASHOBACKSLASH
	OBANDOPLUS OBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYsOUNDERSCOREaCLOSECURLYOPENCURLYxOUNDERSCOREbCLOSECURLY OPLUS OPENCURLYxOUNDERSCOREaCLOSECURLYOPENCURLYsOUNDERSCOREbCLOSECURLY OPLUS OPENCURLYyOUNDERSCOREaCLOSECURLYOPENCURLYzOUNDERSCOREbCLOSECURLY OMINUS OPENCURLYzOUNDERSCOREaCLOSECURLYOPENCURLYyOUNDERSCOREbCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETiOBACKSLASHOBACKSLASH
	OBANDOPLUS OBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYsOUNDERSCOREaCLOSECURLYOPENCURLYyOUNDERSCOREbCLOSECURLY OMINUS OPENCURLYxOUNDERSCOREaCLOSECURLYOPENCURLYzOUNDERSCOREbCLOSECURLY OPLUS OPENCURLYyOUNDERSCOREaCLOSECURLYOPENCURLYsOUNDERSCOREbCLOSECURLY OPLUS OPENCURLYzOUNDERSCOREaCLOSECURLYOPENCURLYxOUNDERSCOREbCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETjOBACKSLASHOBACKSLASH
	OBANDOPLUS OBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYsOUNDERSCOREaCLOSECURLYOPENCURLYzOUNDERSCOREbCLOSECURLY OPLUS OPENCURLYxOUNDERSCOREaCLOSECURLYOPENCURLYyOUNDERSCOREbCLOSECURLY OMINUS OPENCURLYyOUNDERSCOREaCLOSECURLYOPENCURLYxOUNDERSCOREbCLOSECURLY OPLUS OPENCURLYzOUNDERSCOREaCLOSECURLYOPENCURLYsOUNDERSCOREbCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETkODOT
	OBACKSLASHendOPENCURLYalignedCLOSECURLY
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	虽然稍为复杂，但形式上是整齐有序的。如果写成向量形式并利用内外积运算，该表达会更加简洁：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREa OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREb OASSIGN OBACKSLASHleftOPENSQUARE sOUNDERSCOREa sOUNDERSCOREb OMINUS OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREaOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREbOCOMMA sOUNDERSCOREaOBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREb OPLUS sOUNDERSCOREbOBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREa OPLUS OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREa OBACKSLASHtimes OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREb OBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	在该乘法定义下，两个实的四元数乘积仍是实的，这与复数也是一致的。然而，注意到，由于最后一项外积的存在，四元数乘法通常是不可交换的，除非ODOLLAROBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREaODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREbODOLLAR在ODOLLAROBACKSLASHmathbbOPENCURLYRCLOSECURLYOHAT3ODOLLAR中共线，此时外积项为零。

	OBACKSLASHitem OPENCURLY OBACKSLASHemphOPENCURLY模长CLOSECURLY CLOSECURLY
		
	四元数的模长定义为
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHOBBOR OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREa OBACKSLASHOBBOR OASSIGN OBACKSLASHsqrtOPENCURLY sOUNDERSCOREaOHAT2 OPLUS xOUNDERSCOREaOHAT2 OPLUS yOUNDERSCOREaOHAT2 OPLUS zOUNDERSCOREaOHAT2 CLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	可以验证，两个四元数乘积的模即为模的乘积。这使得单位四元数相乘后仍是单位四元数。
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHOBBOR OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREa OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREb OBACKSLASHOBBOR OASSIGN OBACKSLASHOBBOROBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREa OBACKSLASHOBBOR OBACKSLASHOBBOR OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREb OBACKSLASHOBBORODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	
	OBACKSLASHitem OPENCURLY OBACKSLASHemphOPENCURLY共轭CLOSECURLY CLOSECURLY
	
	四元数的共轭是把虚部取成相反数：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREaOHATOMULTIPLY OASSIGN sOUNDERSCOREa OMINUS xOUNDERSCOREai OMINUS yOUNDERSCOREaj OMINUS zOUNDERSCOREak OASSIGN OPENSQUAREsOUNDERSCOREaOCOMMA OMINUSOBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCOREaCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	四元数共轭与其本身相乘，会得到一个实四元数，其实部为模长的平方：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOMULTIPLY OBACKSLASHbmOPENCURLYqCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYqCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOMULTIPLY OASSIGN OPENSQUAREsOUNDERSCOREaOHAT2OPLUSOBACKSLASHbmOPENCURLYvCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHbmOPENCURLYvCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLY0CLOSECURLY CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY

	OBACKSLASHitemOPENCURLY OBACKSLASHemphOPENCURLY逆CLOSECURLY CLOSECURLY
	
	一个四元数的逆为
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHlabelOPENCURLYeqOCOLONquaternionInverseCLOSECURLY
	OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOMULTIPLY ODIVIDE OBACKSLASHOBBOR OBACKSLASHbmOPENCURLYqCLOSECURLY OBACKSLASHOBBOR OHAT2ODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	按此定义，四元数和自己的逆的乘积为实四元数ODOLLAROBACKSLASHbmOPENCURLY1CLOSECURLYODOLLAR：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHbmOPENCURLYqCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLY1CLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	
	如果ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR为单位四元数，其逆和共轭就是同一个量。同时，乘积的逆有和矩阵相似的性质：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHleftOPENBRACKET OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREa OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREb OBACKSLASHrightCLOSEBRACKETOHATOPENCURLYOMINUS1CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREbOHATOPENCURLYOMINUS1CLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCOREaOHATOPENCURLYOMINUS1CLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	
	OBACKSLASHitemOPENCURLY OBACKSLASHemphOPENCURLY数乘CLOSECURLY CLOSECURLY
	
	和向量相似，四元数可以与数相乘：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	k OBACKSLASHbmOPENCURLYqCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE ksOCOMMA kOBACKSLASHbmOPENCURLYvCLOSECURLY OBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

OBACKSLASHsubsectionOPENCURLY用四元数表示旋转CLOSECURLY
我们可以用四元数表达对一个点的旋转。假设一个空间三维点ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLY OASSIGN OPENSQUARExOCOMMAyOCOMMAzCLOSESQUAREOBACKSLASHin OBACKSLASHmathbbOPENCURLYRCLOSECURLYOHAT3ODOLLAR，以及一个由单位四元数ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR指定的旋转。三维点ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYODOLLAR经过旋转之后变为ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLY'ODOLLAR。如果使用矩阵描述，那么有ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLY'OASSIGNOBACKSLASHbmOPENCURLYRCLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLYODOLLAR。而如果用四元数描述旋转，它们的关系又如何来表达呢？

首先，把三维空间点用一个虚四元数来描述：
OBACKSLASHOPENSQUARE
OBACKSLASHbmOPENCURLYpCLOSECURLY OASSIGN OPENSQUARE0OCOMMA xOCOMMA yOCOMMA zCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OASSIGN OPENSQUARE0OCOMMA OBACKSLASHbmOPENCURLYvCLOSECURLYCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOT 
OBACKSLASHCLOSESQUARE
相当于把四元数的3个虚部与空间中的3个轴相对应。那么，旋转后的点ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLY'ODOLLAR即可表示为这样的乘积：
OBACKSLASHbeginOPENCURLYequationCLOSECURLYOBACKSLASHlabelOPENCURLYeqOCOLONrotateOMINUSwithOMINUSquaternionCLOSECURLY
OBACKSLASHbmOPENCURLYpCLOSECURLY' OASSIGN OBACKSLASHbmOPENCURLYqCLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
这里的乘法均为四元数乘法，结果也是四元数。最后把ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLY'ODOLLAR的虚部取出，即得旋转之后点的坐标。并且，可以验证（留作习题），计算结果的实部为0，故为纯虚四元数。

OBACKSLASHsubsectionOPENCURLY四元数到其他旋转表示的转换CLOSECURLY
任意单位四元数描述了一个旋转，该旋转亦可用旋转矩阵或旋转向量描述。现在来考察四元数与旋转向量、旋转矩阵之间的转换关系。在此之前，我们要说，四元数乘法也可以写成一种矩阵的乘法。设ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYOASSIGNOPENSQUAREsOCOMMAOBACKSLASHbmOPENCURLYvCLOSECURLYCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR，那么，定义如下的符号ODOLLAROHATOPENCURLYOPLUSCLOSECURLYODOLLAR和ODOLLAROHATOPENCURLYOBACKSLASHoplusCLOSECURLYODOLLAR为OBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHciteOPENCURLYBarfoot2011CLOSECURLYCLOSECURLY：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOPLUSCLOSECURLYOASSIGNOBACKSLASHleftOPENSQUAREOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYccCLOSECURLY
sOBANDOMINUSOBACKSLASHbmOPENCURLYvCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYvCLOSECURLYOBANDsOBACKSLASHbmOPENCURLYICLOSECURLYOPLUSOBACKSLASHbmOPENCURLYvCLOSECURLYOHATOPENCURLYOBACKSLASHwedgeCLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLYOBACKSLASHrightCLOSESQUAREOCOMMAOBACKSLASHquad 
OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOBACKSLASHoplusCLOSECURLYOASSIGN
OBACKSLASHleftOPENSQUAREOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYccCLOSECURLY
s OBAND OMINUSOBACKSLASHbmOPENCURLYvCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OBACKSLASHOBACKSLASH
OBACKSLASHbmOPENCURLYvCLOSECURLY OBAND sOBACKSLASHbmOPENCURLYICLOSECURLYOMINUSOBACKSLASHbmOPENCURLYvCLOSECURLYOHATOPENCURLYOBACKSLASHwedgeCLOSECURLY
OBACKSLASHendOPENCURLYarrayCLOSECURLYOBACKSLASHrightCLOSESQUAREOCOMMA
OBACKSLASHendOPENCURLYequationCLOSECURLY
这两个符号将四元数映射成为一个4ODOLLAROBACKSLASHtimesODOLLAR4的矩阵。于是四元数乘法可以写成矩阵的形式：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE1OHAT OPLUS OPENCURLYOBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE2CLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	sOUNDERSCORE1OBANDOMINUSOBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCORE1OHATTOBACKSLASHOBACKSLASH
	OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCORE1 OBAND sOUNDERSCORE1 OBACKSLASHbmOPENCURLYICLOSECURLY OPLUS OBACKSLASHbmOPENCURLYvCLOSECURLYOUNDERSCORE1OHATOBACKSLASHwedge
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREOBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLYOPENCURLYs OUNDERSCORE2CLOSECURLYCLOSECURLY OBACKSLASHOBACKSLASH
	OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYvCLOSECURLY OUNDERSCORE2CLOSECURLYCLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	OPENCURLY OMINUS OBACKSLASHbmOPENCURLYvCLOSECURLY OUNDERSCORE1OHATTOPENCURLYOBACKSLASHbmOPENCURLYvCLOSECURLY OUNDERSCORE2CLOSECURLY OPLUS OPENCURLYs OUNDERSCORE1CLOSECURLYOPENCURLYs OUNDERSCORE2CLOSECURLYCLOSECURLY OBACKSLASHOBACKSLASH 
	OPENCURLYOPENCURLYs OUNDERSCORE1CLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYvCLOSECURLY OUNDERSCORE2CLOSECURLY OPLUS OPENCURLYs OUNDERSCORE2CLOSECURLYOPENCURLYOBACKSLASHbmOPENCURLYvCLOSECURLY OUNDERSCORE1CLOSECURLY OPLUS OBACKSLASHbmOPENCURLYvCLOSECURLY OUNDERSCORE1OHAT OBACKSLASHwedge OPENCURLYOBACKSLASHbmOPENCURLYvCLOSECURLY OUNDERSCORE2CLOSECURLYCLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE1 OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE2
OBACKSLASHendOPENCURLYequationCLOSECURLY
同理亦可证：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE1 OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE2 OASSIGN OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE1OHATOPENCURLYOPLUSCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE2 OASSIGN OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE2OHATOPENCURLYOBACKSLASHoplusCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE1ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

然后，考虑使用四元数对空间点进行旋转的问题。根据前面的说法，有：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYsplitCLOSECURLY
OBACKSLASHbmOPENCURLYpCLOSECURLY' OBANDOASSIGN OBACKSLASHbmOPENCURLYqCLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLY OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPLUS OBACKSLASHbmOPENCURLYpCLOSECURLYOHATOPLUS OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOMINUS1CLOSECURLY OBACKSLASHOBACKSLASH
OBANDOASSIGN OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPLUS OBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLYOPENCURLYOMINUS1CLOSECURLYOHATOPENCURLYOBACKSLASHoplusCLOSECURLYCLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLYODOT
OBACKSLASHendOPENCURLYsplitCLOSECURLY
OBACKSLASHendOPENCURLYequationCLOSECURLY
代入两个符号对应的矩阵，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLYOBACKSLASHlabelOPENCURLYeqOCOLONquaternionOMINUStoOMINUSrotationOMINUSmatrixOMINUSderiveCLOSECURLY
OPENCURLYOBACKSLASHbmOPENCURLYqCLOSECURLYOHAT OPLUS CLOSECURLYOPENCURLYOBACKSLASHleftOPENBRACKET OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYqCLOSECURLYOHATOPENCURLY OMINUS 1CLOSECURLYCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSEBRACKETOHAT OBACKSLASHoplus CLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	sOBANDOMINUSOBACKSLASHbmOPENCURLYvCLOSECURLYOHATTOBACKSLASHOBACKSLASH
	OBACKSLASHbmOPENCURLYvCLOSECURLYOBANDsOBACKSLASHbmOPENCURLYICLOSECURLYOPLUSOBACKSLASHbmOPENCURLYvCLOSECURLYOHATOBACKSLASHwedge 
	OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUAREOBACKSLASHleftOPENSQUAREOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	sOBANDOPENCURLYOBACKSLASHbmOPENCURLYvCLOSECURLY OHATTCLOSECURLYOBACKSLASHOBACKSLASH
	OPENCURLY OMINUS OBACKSLASHbmOPENCURLYvCLOSECURLY CLOSECURLYOBANDOPENCURLYsOBACKSLASHbmOPENCURLYICLOSECURLY OPLUS OBACKSLASHbmOPENCURLYvCLOSECURLY OHAT OBACKSLASHwedge CLOSECURLY
	OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUARE OASSIGN OBACKSLASHleftOPENSQUARE OBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
	1OBANDOBACKSLASHbmOPENCURLY0CLOSECURLY OBACKSLASHOBACKSLASH
	OBACKSLASHbmOPENCURLY0CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOBANDOBACKSLASHbmOPENCURLYvCLOSECURLYOBACKSLASHbmOPENCURLYvCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OPLUS OPENCURLYsOHAT2CLOSECURLY OBACKSLASHbmOPENCURLYICLOSECURLY OPLUS 2sOBACKSLASHbmOPENCURLYvCLOSECURLY OHAT OBACKSLASHwedge OPLUS OPENCURLYOPENBRACKETOBACKSLASHbmOPENCURLYvCLOSECURLY OHAT OBACKSLASHwedgeCLOSEBRACKETCLOSECURLYOHAT2 
	OBACKSLASHendOPENCURLYarrayCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
因为ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLY'ODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYODOLLAR都是虚四元数，那么事实上该矩阵的右下角即给出了OBACKSLASHtextbfOPENCURLY从四元数到旋转矩阵CLOSECURLY的变换关系：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYRCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYvCLOSECURLY OBACKSLASHbmOPENCURLYvCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OPLUS OPENCURLYsOHAT2CLOSECURLY OBACKSLASHbmOPENCURLYICLOSECURLY OPLUS 2sOBACKSLASHbmOPENCURLYvCLOSECURLY OHAT OBACKSLASHwedge OPLUS OPENCURLYOPENBRACKETOBACKSLASHbmOPENCURLYvCLOSECURLY OHAT OBACKSLASHwedgeCLOSEBRACKETCLOSECURLYOHAT2ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
为了得到四元数到旋转向量的转换公式，对上式两侧求迹，得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYalignedCLOSECURLY
OBACKSLASHmathrmOPENCURLYtrCLOSECURLYOPENBRACKETOBACKSLASHbmOPENCURLYRCLOSECURLYCLOSEBRACKET OBANDOASSIGN OBACKSLASHmathrmOPENCURLYtrCLOSECURLYOPENBRACKETOBACKSLASHbmOPENCURLYvCLOSECURLYOBACKSLASHbmOPENCURLYvCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY OPLUS 3sOHAT2 OPLUS 2s OBACKSLASHcdot 0 OPLUS OBACKSLASHmathrmOPENCURLYtrCLOSECURLYOPENBRACKETOPENBRACKETOBACKSLASHbmOPENCURLYvCLOSECURLYOHATOBACKSLASHwedgeCLOSEBRACKETOHAT2CLOSEBRACKET OBACKSLASHOBACKSLASH
OBANDOASSIGN vOUNDERSCORE1OHAT2OPLUSvOUNDERSCORE2OHAT2OPLUSvOUNDERSCORE3sOHAT2 OPLUS 3sOHAT2 OMINUS 2OPENBRACKETvOUNDERSCORE1OHAT2OPLUSvOUNDERSCORE2OHAT2OPLUSvOUNDERSCORE3OHAT2CLOSEBRACKET OBACKSLASHOBACKSLASH
OBANDOASSIGN OPENBRACKET1OMINUSsOHAT2CLOSEBRACKET OPLUS 3sOHAT2 OMINUS2OPENBRACKET1OMINUSsOHAT2CLOSEBRACKETOBACKSLASHOBACKSLASH
OBANDOASSIGN 4sOHAT2 OMINUS1ODOT
OBACKSLASHendOPENCURLYalignedCLOSECURLY
OBACKSLASHendOPENCURLYequationCLOSECURLY
又由式OBACKSLASHeqrefOPENCURLYeqOCOLONR2thetaCLOSECURLY得：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbeginOPENCURLYalignedCLOSECURLY
OBACKSLASHtheta OBANDOASSIGN OBACKSLASHarccosOPENBRACKETOBACKSLASHfracOPENCURLYOBACKSLASHmathrmOPENCURLYtrCLOSECURLYOPENBRACKETOBACKSLASHbmOPENCURLYRCLOSECURLYOMINUS1CLOSEBRACKETCLOSECURLYOPENCURLY2CLOSECURLYCLOSEBRACKET OBACKSLASHOBACKSLASH
OBANDOASSIGNOBACKSLASHarccosOPENBRACKET2sOHAT2OMINUS1CLOSEBRACKETODOT
OBACKSLASHendOPENCURLYalignedCLOSECURLY
OBACKSLASHendOPENCURLYequationCLOSECURLY
即
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHcos OBACKSLASHtheta OASSIGN2sOHAT2OMINUS1OASSIGN2 OBACKSLASHcosOHAT2 OBACKSLASHfracOPENCURLYOBACKSLASHthetaCLOSECURLYOPENCURLY2CLOSECURLY OMINUS1OCOMMA
OBACKSLASHendOPENCURLYequationCLOSECURLY
所以：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHtheta OASSIGN 2 OBACKSLASHarccos sODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
至于旋转轴，如果在式OBACKSLASHeqrefOPENCURLYeqOCOLONquaternionOMINUStoOMINUSrotationOMINUSmatrixOMINUSderiveCLOSECURLY中用ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR的虚部代替ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYODOLLAR，易知ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR的虚部组成的向量在旋转时是不动的，即构成旋转轴。于是只要将它除掉它的模长，即得。总而言之，四元数到旋转向量的转换公式可列写如下：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHlabelOPENCURLYeqOCOLONrotationVector2QuaternionCLOSECURLY
OBACKSLASHbeginOPENCURLYcasesCLOSECURLY
OBACKSLASHtheta  OASSIGN 2OBACKSLASHarccos OPENCURLYqOUNDERSCORE0CLOSECURLYOBACKSLASHOBACKSLASH
OPENCURLYOBACKSLASHleftOPENSQUARE OPENCURLYOPENCURLYnOUNDERSCORExCLOSECURLYOCOMMAOPENCURLYnOUNDERSCOREyCLOSECURLYOCOMMAOPENCURLYnOUNDERSCOREzCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLY OASSIGN OPENCURLYOPENCURLYOPENCURLYOBACKSLASHleftOPENSQUARE OPENCURLYOPENCURLYqOUNDERSCORE1CLOSECURLYOCOMMAOPENCURLYqOUNDERSCORE2CLOSECURLYOCOMMAOPENCURLYqOUNDERSCORE3CLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUARECLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLYODIVIDEOPENCURLYOBACKSLASHsin OBACKSLASHfracOPENCURLYOBACKSLASHtheta CLOSECURLYOPENCURLY2CLOSECURLYCLOSECURLY
OBACKSLASHendOPENCURLYcasesCLOSECURLY ODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY

至于如何从其他方式转换到四元数，只须把上述步骤倒过来处理即可。在实际编程中，程序库通常会为我们准备好各种形式之间的转换。无论是四元数、旋转矩阵还是轴角，它们都可以用来描述同一个旋转。我们应该在实际中选择最为方便的形式，而不必拘泥于某种特定的形式。在随后的实践和习题中，我们会演示各种表达方式之间的转换，以加深读者的印象。


OMODULO
OMODULO从旋转向量到四元数的转换方式已在式OBACKSLASHeqrefOPENCURLYeqOCOLONrotationVector2QuaternionCLOSECURLY中给出。因此，现在看来把四元数转换为矩阵的最直观方法，是先把四元数ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR转换为轴角ODOLLAROBACKSLASHthetaODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYnCLOSECURLYODOLLAR，然后再根据罗德里格斯公式转换为矩阵。不过那样要计算一个ODOLLAROBACKSLASHarccosODOLLAR函数，代价较大。实际上这个计算是可以通过一定的技巧绕过的。这里省略推导过程，直接给出四元数到旋转矩阵的转换方式。
OMODULO
OMODULO这种表达方式和旋转矩阵、旋转向量有什么关系呢？我们不妨先来看旋转向量。假设某个旋转是绕单位向量ODOLLAROBACKSLASHbmOPENCURLYnCLOSECURLYOASSIGNOBACKSLASHleftOPENSQUARE nOUNDERSCORExOCOMMA nOUNDERSCOREyOCOMMA nOUNDERSCOREz OBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR进行了角度为ODOLLAROBACKSLASHthetaODOLLAR的旋转，那么这个旋转的四元数形式为
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULOOBACKSLASHlabelOPENCURLYeqOCOLONntheta2quaternionCLOSECURLY
OMODULOOBACKSLASHbmOPENCURLYqCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OBACKSLASHcos OBACKSLASHfracOPENCURLYOBACKSLASHthetaCLOSECURLYOPENCURLY2CLOSECURLYOCOMMA nOUNDERSCOREx OBACKSLASHsin OBACKSLASHfracOPENCURLYOBACKSLASHthetaCLOSECURLYOPENCURLY2CLOSECURLYOCOMMA nOUNDERSCOREy OBACKSLASHsin OBACKSLASHfracOPENCURLYOBACKSLASHthetaCLOSECURLYOPENCURLY2CLOSECURLYOCOMMA nOUNDERSCOREz OBACKSLASHsin OBACKSLASHfracOPENCURLYOBACKSLASHthetaCLOSECURLYOPENCURLY2CLOSECURLYOBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY ODOT
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULO反之，亦可从单位四元数中计算出对应旋转轴与夹角：
OMODULO
OMODULO
OMODULO这个式子给了我们一种微妙的“转了一半”的感觉。同样，对式OBACKSLASHeqrefOPENCURLYeqOCOLONntheta2quaternionCLOSECURLY的ODOLLAROBACKSLASHthetaODOLLAR加上ODOLLAR2OBACKSLASHpiODOLLAR，我们得到一个相同的旋转，但此时对应的四元数变成了ODOLLAROMINUSOBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR。因此，在四元数中，OBACKSLASHtextbfOPENCURLY任意的旋转都可以由两个互为相反数的四元数表示CLOSECURLY。同理，取ODOLLAROBACKSLASHthetaODOLLAR为ODOLLAR0ODOLLAR，则得到一个没有任何旋转的实四元数：
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULOOBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE0 OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLY OBACKSLASHpm 1OCOMMA0OCOMMA0OCOMMA0CLOSECURLY OBACKSLASHrightCLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLY ODOT
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULO设四元数ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLY OASSIGN qOUNDERSCORE0OPLUSqOUNDERSCORE1iOPLUSqOUNDERSCORE2jOPLUSqOUNDERSCORE3kODOLLAR，对应的旋转矩阵ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR为
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULOOBACKSLASHbmOPENCURLYRCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
OMODULO	 OPENCURLY1 OMINUS 2qOUNDERSCORE2OHAT2 OMINUS 2qOUNDERSCORE3OHAT2CLOSECURLYOBANDOPENCURLY2OPENCURLYqOUNDERSCORE1CLOSECURLYOPENCURLYqOUNDERSCORE2CLOSECURLY OMINUS 2OPENCURLYqOUNDERSCORE0CLOSECURLYOPENCURLYqOUNDERSCORE3CLOSECURLYCLOSECURLYOBANDOPENCURLY2OPENCURLYqOUNDERSCORE1CLOSECURLYOPENCURLYqOUNDERSCORE3CLOSECURLY OPLUS 2OPENCURLYqOUNDERSCORE0CLOSECURLYOPENCURLYqOUNDERSCORE2CLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
OMODULO	 OPENCURLY2OPENCURLYqOUNDERSCORE1CLOSECURLYOPENCURLYqOUNDERSCORE2CLOSECURLY OPLUS 2OPENCURLYqOUNDERSCORE0CLOSECURLYOPENCURLYqOUNDERSCORE3CLOSECURLYCLOSECURLYOBANDOPENCURLY1 OMINUS 2qOUNDERSCORE1OHAT2 OMINUS 2qOUNDERSCORE3OHAT2CLOSECURLYOBANDOPENCURLY2OPENCURLYqOUNDERSCORE2CLOSECURLYOPENCURLYqOUNDERSCORE3CLOSECURLY OMINUS 2OPENCURLYqOUNDERSCORE0CLOSECURLYOPENCURLYqOUNDERSCORE1CLOSECURLYCLOSECURLYOBACKSLASHOBACKSLASH
OMODULO	 OPENCURLY2OPENCURLYqOUNDERSCORE1CLOSECURLYOPENCURLYqOUNDERSCORE3CLOSECURLY OMINUS 2OPENCURLYqOUNDERSCORE0CLOSECURLYOPENCURLYqOUNDERSCORE2CLOSECURLYCLOSECURLYOBANDOPENCURLY2OPENCURLYqOUNDERSCORE2CLOSECURLYOPENCURLYqOUNDERSCORE3CLOSECURLY OPLUS 2OPENCURLYqOUNDERSCORE0CLOSECURLYOPENCURLYqOUNDERSCORE1CLOSECURLYCLOSECURLYOBANDOPENCURLY1 OMINUS 2qOUNDERSCORE1OHAT2 OMINUS 2qOUNDERSCORE2OHAT2CLOSECURLY
OMODULO OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULO反之，由旋转矩阵到四元数的转换如下。假设矩阵为ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYOASSIGNOBACKSLASHOPENCURLY mOUNDERSCOREOPENCURLYijCLOSECURLYOBACKSLASHCLOSECURLYOCOMMA iOCOMMA j OBACKSLASHin OBACKSLASHleftOPENSQUARE 1OCOMMA 2OCOMMA3 OBACKSLASHrightCLOSESQUARE ODOLLAR，其对应的四元数ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR由下式给出：
OMODULOOBACKSLASHbeginOPENCURLYequationCLOSECURLY
OMODULOOPENCURLYqOUNDERSCORE0CLOSECURLY OASSIGN OBACKSLASHfracOPENCURLYOPENCURLYOBACKSLASHsqrt OPENCURLYOBACKSLASHmathrmOPENCURLYtrCLOSECURLYOPENBRACKETRCLOSEBRACKET OPLUS 1CLOSECURLY CLOSECURLYCLOSECURLYOPENCURLY2CLOSECURLYOCOMMAOPENCURLYqOUNDERSCORE1CLOSECURLY OASSIGN OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYmOUNDERSCOREOPENCURLY23CLOSECURLYCLOSECURLY OMINUS OPENCURLYmOUNDERSCOREOPENCURLY32CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLY4OPENCURLYqOUNDERSCORE0CLOSECURLYCLOSECURLYCLOSECURLYOCOMMAOPENCURLYqOUNDERSCORE2CLOSECURLY OASSIGN OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYmOUNDERSCOREOPENCURLY31CLOSECURLYCLOSECURLY OMINUS OPENCURLYmOUNDERSCOREOPENCURLY13CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLY4OPENCURLYqOUNDERSCORE0CLOSECURLYCLOSECURLYCLOSECURLYOCOMMAOPENCURLYqOUNDERSCORE3CLOSECURLY OASSIGN OBACKSLASHfracOPENCURLYOPENCURLYOPENCURLYmOUNDERSCOREOPENCURLY12CLOSECURLYCLOSECURLY OMINUS OPENCURLYmOUNDERSCOREOPENCURLY21CLOSECURLYCLOSECURLYCLOSECURLYCLOSECURLYOPENCURLYOPENCURLY4OPENCURLYqOUNDERSCORE0CLOSECURLYCLOSECURLYCLOSECURLYODOT
OMODULOOBACKSLASHendOPENCURLYequationCLOSECURLY
OMODULO
OMODULO值得一提的是，由于ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYOMINUSqCLOSECURLYODOLLAR表示同一个旋转，事实上一个ODOLLAROBACKSLASHbmOPENCURLYRCLOSECURLYODOLLAR对应的四元数表示并不是唯一的。同时，除了上面给出的转换方式之外，还存在其他几种计算方法，而本书都省略了。实际编程中，当ODOLLARqOUNDERSCORE0ODOLLAR接近0时，其余3个分量会非常大，导致解不稳定，此时我们再考虑使用其他的方式进行转换。

OBACKSLASHsectionOPENCURLYOBACKSLASHtextsuperscriptOPENCURLYOBACKSLASHttfamily OMULTIPLYCLOSECURLY相似、仿射、射影变换CLOSECURLY
除了欧氏变换之外，3D空间还存在其他几种变换方式，只不过欧氏变换是最简单的。它们一部分和测量几何有关，因为在之后的讲解中可能会提到，所以先罗列出来。欧氏变换保持了向量的长度和夹角，相当于我们把一个刚体原封不动地进行了移动或旋转，不改变它自身的样子。其他几种变换则会改变它的外形。它们都拥有类似的矩阵表示。

OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem OPENCURLYOBACKSLASHemphOPENCURLY相似变换CLOSECURLYCLOSECURLY
	
	相似变换比欧氏变换多了一个自由度，它允许物体进行均匀缩放，其矩阵表示为
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCORES OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
		OPENCURLYs OBACKSLASHbmOPENCURLYRCLOSECURLYCLOSECURLYOBAND OBACKSLASHbmOPENCURLYtCLOSECURLYOBACKSLASHOBACKSLASH
		OPENCURLYOPENCURLY OBACKSLASHbmOPENCURLY0CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLYOBAND1
		OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	
	注意到旋转部分多了一个缩放因子ODOLLARsODOLLAR，表示我们在对向量旋转之后，可以在ODOLLARxOCOMMAyOCOMMAzODOLLAR三个坐标上进行均匀缩放。由于含有缩放，相似变换不再保持图形的面积不变。你可以想象一个边长为1的立方体通过相似变换后，变成边长为10的样子（但仍然是立方体）。三维相似变换的集合也叫做OBACKSLASHtextbfOPENCURLY相似变换群CLOSECURLY，记作ODOLLAROBACKSLASHmathrmOPENCURLYSimCLOSECURLYOPENBRACKET3CLOSEBRACKETODOLLAR。
	
	OBACKSLASHitem OPENCURLY OBACKSLASHemphOPENCURLY仿射变换CLOSECURLY CLOSECURLY
	
	仿射变换的矩阵形式如下：
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREA OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
		OBACKSLASHbmOPENCURLYACLOSECURLY OBAND OBACKSLASHbmOPENCURLYtCLOSECURLYOBACKSLASHOBACKSLASH
		OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLY0CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLY OBAND 1
		OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	
	与欧氏变换不同的是，仿射变换只要求ODOLLAROBACKSLASHbmOPENCURLYACLOSECURLYODOLLAR是一个可逆矩阵，而不必是正交矩阵。仿射变换也叫正交投影。经过仿射变换之后，立方体就不再是方的了，但是各个面仍然是平行四边形。
	
	OBACKSLASHitemOPENCURLY OBACKSLASHemphOPENCURLY射影变换CLOSECURLY CLOSECURLY
	
	射影变换是最一般的变换，它的矩阵形式为
	
	OBACKSLASHbeginOPENCURLYequationCLOSECURLY
	OPENCURLYOBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREPCLOSECURLY OASSIGN OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
		OBACKSLASHbmOPENCURLYACLOSECURLY OBAND OBACKSLASHbmOPENCURLYtCLOSECURLYOBACKSLASHOBACKSLASH
		OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYaCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLY OBAND v
		OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOT
	OBACKSLASHendOPENCURLYequationCLOSECURLY
	
	它的左上角为可逆矩阵ODOLLAROBACKSLASHbmOPENCURLYACLOSECURLYODOLLAR，右上角为平移ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR，左下角为缩放ODOLLAROBACKSLASHbmOPENCURLYaCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR。由于采用了齐次坐标，当ODOLLARv OBACKSLASHneq 0ODOLLAR时，我们可以对整个矩阵除以ODOLLARvODOLLAR得到一个右下角为1的矩阵； 否则得到右下角为ODOLLAR0ODOLLAR的矩阵。因此，2D的射影变换一共有8个自由度，3D则共有15个自由度。射影变换是现在讲过的变换中，形式最为一般的。从真实世界到相机照片的变换可以看成一个射影变换。读者可以想象一个原本方形的地板砖，在照片当中是什么样子：首先，它不再是方形的。由于近大远小的关系，它甚至不是平行四边形，而是一个不规则的四边形。
OBACKSLASHendOPENCURLYenumerateCLOSECURLY

OBACKSLASHautorefOPENCURLYtableOCOLONcommonOMINUStransformCLOSECURLY总结了目前讲到的几种变换的性质。注意在“不变性质”中，从上到下是有包含关系的。例如，欧氏变换除了保体积之外，也具有保平行、相交等性质。

OBACKSLASHbeginOPENCURLYtableCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
	OBACKSLASHcentering
	OBACKSLASHcaptionOPENCURLY常见变换性质比较CLOSECURLY
	OBACKSLASHlabelOPENCURLYtableOCOLONcommonOMINUStransformCLOSECURLY
	OBACKSLASHbeginOPENCURLYtabuCLOSECURLYOPENCURLYcOBBORcOBBORcOBBORcCLOSECURLY
		OBACKSLASHtoprule
		变换名称 OBAND 矩阵形式 OBAND 自由度 OBAND 不变性质 OBACKSLASHOBACKSLASH OBACKSLASHmidrule
		欧氏变换 OBACKSLASHruleOPENCURLY0ptCLOSECURLYOPENCURLY20 ptCLOSECURLY OBAND ODOLLAROBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
			OBACKSLASHbmOPENCURLYRCLOSECURLY OBAND OBACKSLASHbmOPENCURLYtCLOSECURLYOBACKSLASHOBACKSLASH
			OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLY0CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLYOBAND1
			OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOLLAR OBAND 6 OBAND 长度、夹角、体积 OBACKSLASHOBACKSLASH 
		相似变换 OBACKSLASHruleOPENCURLY0ptCLOSECURLYOPENCURLY20 ptCLOSECURLYOBAND ODOLLAR OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
			OPENCURLYs OBACKSLASHbmOPENCURLYRCLOSECURLYCLOSECURLYOBAND OBACKSLASHbmOPENCURLYtCLOSECURLYOBACKSLASHOBACKSLASH
			OPENCURLYOPENCURLY OBACKSLASHbmOPENCURLY0CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLYOBAND1
			OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOLLAR OBAND 7 OBAND 体积比 OBACKSLASHOBACKSLASH 
		仿射变换 OBACKSLASHruleOPENCURLY0ptCLOSECURLYOPENCURLY20 ptCLOSECURLYOBAND ODOLLAR OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
			OBACKSLASHbmOPENCURLYACLOSECURLY OBAND OBACKSLASHbmOPENCURLYtCLOSECURLYOBACKSLASHOBACKSLASH
			OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLY0CLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLY OBAND 1
			OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOLLAR   OBAND 12 OBAND 平行性、体积比 OBACKSLASHOBACKSLASH 
		射影变换 OBACKSLASHruleOPENCURLY0ptCLOSECURLYOPENCURLY20 ptCLOSECURLY OBAND ODOLLAR OBACKSLASHleftOPENSQUARE OPENCURLYOBACKSLASHbeginOPENCURLYarrayCLOSECURLYOPENCURLYOMULTIPLYOPENCURLY20CLOSECURLYOPENCURLYcCLOSECURLYCLOSECURLY
			OBACKSLASHbmOPENCURLYACLOSECURLY OBAND OBACKSLASHbmOPENCURLYtCLOSECURLYOBACKSLASHOBACKSLASH
			OPENCURLYOPENCURLYOBACKSLASHbmOPENCURLYaCLOSECURLYOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYCLOSECURLYCLOSECURLY OBAND v
			OBACKSLASHendOPENCURLYarrayCLOSECURLYCLOSECURLY OBACKSLASHrightCLOSESQUAREODOLLAR OBAND 15 OBAND 接触平面的相交和相切 OBACKSLASHruleOPENCURLY0ptCLOSECURLYOPENCURLY20 ptCLOSECURLYOBACKSLASHOBACKSLASH 
		OBACKSLASHbottomrule
	OBACKSLASHendOPENCURLYtabuCLOSECURLY 
OBACKSLASHendOPENCURLYtableCLOSECURLY

我们之后会说到，从真实世界到相机照片的变换是一个射影变换。如果相机的焦距为无穷远，那么这个变换为仿射变换。不过，在详细讲述相机模型之前，我们只要对它们有个大致的印象即可。

OBACKSLASHsectionOPENCURLY实践：Eigen几何模块CLOSECURLY
OBACKSLASHsubsectionOPENCURLYEigen几何模块的数据演示CLOSECURLY
现在，我们来实际演练一下前面讲到的各种旋转表达方式。我们将在Eigen中使用四元数、欧拉角和旋转矩阵，演示它们之间的变换方式。我们还会给出一个可视化程序，帮助读者理解这几个变换的关系。

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch3ODIVIDEuseGeometryODIVIDEuseGeometryODOTcppCLOSESQUARE
OSINGLEHASHinclude OGREATiostreamOLESS
OSINGLEHASHinclude OGREATcmathOLESS
using namespace stdOSEMICOLON

OSINGLEHASHinclude OGREATEigenODIVIDECoreOLESS
OSINGLEHASHinclude OGREATEigenODIVIDEGeometryOLESS

using namespace EigenOSEMICOLON
ODIVIDEODIVIDE 本程序演示了 Eigen 几何模块的使用方法

int mainOPENBRACKETint argcOCOMMA char OMULTIPLYOMULTIPLYargvCLOSEBRACKET OPENCURLY
    ODIVIDEODIVIDE EigenODIVIDEGeometry 模块提供了各种旋转和平移的表示
    ODIVIDEODIVIDE 3D 旋转矩阵直接使用 Matrix3d 或 Matrix3f
    Matrix3d rotationOUNDERSCOREmatrix OASSIGN Matrix3dOCOLONOCOLONIdentityOPENBRACKETCLOSEBRACKETOSEMICOLON
    ODIVIDEODIVIDE 旋转向量使用 AngleAxisOCOMMA 它底层不直接是Matrix，但运算可以当作矩阵（因为重载了运算符）
    AngleAxisd rotationOUNDERSCOREvectorOPENBRACKETMOUNDERSCOREPI ODIVIDE 4OCOMMA Vector3dOPENBRACKET0OCOMMA 0OCOMMA 1CLOSEBRACKETCLOSEBRACKETOSEMICOLON     ODIVIDEODIVIDE沿 Z 轴旋转 45 度
    coutODOTprecisionOPENBRACKET3CLOSEBRACKETOSEMICOLON
    cout OGREATOGREAT "rotation matrix OASSIGNOBACKSLASHn" OGREATOGREAT rotationOUNDERSCOREvectorODOTmatrixOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON   ODIVIDEODIVIDE用matrixOPENBRACKETCLOSEBRACKET转换成矩阵
    ODIVIDEODIVIDE 也可以直接赋值
    rotationOUNDERSCOREmatrix OASSIGN rotationOUNDERSCOREvectorODOTtoRotationMatrixOPENBRACKETCLOSEBRACKETOSEMICOLON
    ODIVIDEODIVIDE 用 AngleAxis 可以进行坐标变换
    Vector3d vOPENBRACKET1OCOMMA 0OCOMMA 0CLOSEBRACKETOSEMICOLON
    Vector3d vOUNDERSCORErotated OASSIGN rotationOUNDERSCOREvector OMULTIPLY vOSEMICOLON
    cout OGREATOGREAT "OPENBRACKET1OCOMMA0OCOMMA0CLOSEBRACKET after rotation OPENBRACKETby angle axisCLOSEBRACKET OASSIGN " OGREATOGREAT vOUNDERSCORErotatedODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
    ODIVIDEODIVIDE 或者用旋转矩阵
    vOUNDERSCORErotated OASSIGN rotationOUNDERSCOREmatrix OMULTIPLY vOSEMICOLON
    cout OGREATOGREAT "OPENBRACKET1OCOMMA0OCOMMA0CLOSEBRACKET after rotation OPENBRACKETby matrixCLOSEBRACKET OASSIGN " OGREATOGREAT vOUNDERSCORErotatedODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
    
    ODIVIDEODIVIDE 欧拉角OCOLON 可以将旋转矩阵直接转换成欧拉角
    Vector3d eulerOUNDERSCOREangles OASSIGN rotationOUNDERSCOREmatrixODOTeulerAnglesOPENBRACKET2OCOMMA 1OCOMMA 0CLOSEBRACKETOSEMICOLON ODIVIDEODIVIDE ZYX顺序，即roll pitch yaw顺序
    cout OGREATOGREAT "yaw pitch roll OASSIGN " OGREATOGREAT eulerOUNDERSCOREanglesODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
    
    ODIVIDEODIVIDE 欧氏变换矩阵使用 EigenOCOLONOCOLONIsometry
    Isometry3d T OASSIGN Isometry3dOCOLONOCOLONIdentityOPENBRACKETCLOSEBRACKETOSEMICOLON       ODIVIDEODIVIDE 虽然称为3d，实质上是4＊4的矩阵
    TODOTrotateOPENBRACKETrotationOUNDERSCOREvectorCLOSEBRACKETOSEMICOLON                   ODIVIDEODIVIDE 按照rotationOUNDERSCOREvector进行旋转
    TODOTpretranslateOPENBRACKETVector3dOPENBRACKET1OCOMMA 3OCOMMA 4CLOSEBRACKETCLOSEBRACKETOSEMICOLON           ODIVIDEODIVIDE 把平移向量设成OPENBRACKET1OCOMMA3OCOMMA4CLOSEBRACKET
    cout OGREATOGREAT "Transform matrix OASSIGN OBACKSLASHn" OGREATOGREAT TODOTmatrixOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
    
    ODIVIDEODIVIDE 用变换矩阵进行坐标变换
    Vector3d vOUNDERSCOREtransformed OASSIGN T OMULTIPLY vOSEMICOLON                              ODIVIDEODIVIDE 相当于ROMULTIPLYvOPLUSt
    cout OGREATOGREAT "v tranformed OASSIGN " OGREATOGREAT vOUNDERSCOREtransformedODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
    
    ODIVIDEODIVIDE 对于仿射和射影变换，使用 EigenOCOLONOCOLONAffine3d 和 EigenOCOLONOCOLONProjective3d 即可，略
    
    ODIVIDEODIVIDE 四元数
    ODIVIDEODIVIDE 可以直接把AngleAxis赋值给四元数，反之亦然
    Quaterniond q OASSIGN QuaterniondOPENBRACKETrotationOUNDERSCOREvectorCLOSEBRACKETOSEMICOLON
    cout OGREATOGREAT "quaternion from rotation vector OASSIGN " OGREATOGREAT qODOTcoeffsOPENBRACKETCLOSEBRACKETODOTtransposeOPENBRACKETCLOSEBRACKET
    OGREATOGREAT endlOSEMICOLON   ODIVIDEODIVIDE 请注意coeffs的顺序是OPENBRACKETxOCOMMAyOCOMMAzOCOMMAwCLOSEBRACKETOCOMMAw为实部，前三者为虚部
    ODIVIDEODIVIDE 也可以把旋转矩阵赋给它
    q OASSIGN QuaterniondOPENBRACKETrotationOUNDERSCOREmatrixCLOSEBRACKETOSEMICOLON
    cout OGREATOGREAT "quaternion from rotation matrix OASSIGN " OGREATOGREAT qODOTcoeffsOPENBRACKETCLOSEBRACKETODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
    ODIVIDEODIVIDE 使用四元数旋转一个向量，使用重载的乘法即可
    vOUNDERSCORErotated OASSIGN q OMULTIPLY vOSEMICOLON ODIVIDEODIVIDE 注意数学上是qvqOHATOPENCURLYOMINUS1CLOSECURLY
    cout OGREATOGREAT "OPENBRACKET1OCOMMA0OCOMMA0CLOSEBRACKET after rotation OASSIGN " OGREATOGREAT vOUNDERSCORErotatedODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
    ODIVIDEODIVIDE 用常规向量乘法表示，则应该如下计算
    cout OGREATOGREAT "should be equal to " OGREATOGREAT OPENBRACKETq OMULTIPLY QuaterniondOPENBRACKET0OCOMMA 1OCOMMA 0OCOMMA 0CLOSEBRACKET OMULTIPLY qODOTinverseOPENBRACKETCLOSEBRACKETCLOSEBRACKETODOTcoeffsOPENBRACKETCLOSEBRACKETODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
    
    return 0OSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

Eigen中对各种形式的表达方式总结如下。请注意每种类型都有单精度和双精度两种数据类型，而且和之前一样，不能由编译器自动转换。下面以双精度为例，你可以把最后的d改成f，即得到单精度的数据结构。
OBACKSLASHbeginOPENCURLYitemizeCLOSECURLY
	OBACKSLASHitem 旋转矩阵（ODOLLAR3 OBACKSLASHtimes 3ODOLLAR）：EigenOCOLONOCOLONMatrix3d。
	OBACKSLASHitem 旋转向量（ODOLLAR3 OBACKSLASHtimes 1ODOLLAR）：EigenOCOLONOCOLONAngleAxisd。
	OBACKSLASHitem 欧拉角（ODOLLAR3 OBACKSLASHtimes 1ODOLLAR）：EigenOCOLONOCOLONVector3d。
	OBACKSLASHitem 四元数（ODOLLAR4 OBACKSLASHtimes 1ODOLLAR）：EigenOCOLONOCOLONQuaterniond。
	OBACKSLASHitem 欧氏变换矩阵（ODOLLAR4 OBACKSLASHtimes 4ODOLLAR）：EigenOCOLONOCOLONIsometry3d。
	OBACKSLASHitem 仿射变换（ODOLLAR4 OBACKSLASHtimes 4ODOLLAR）：EigenOCOLONOCOLONAffine3d。
	OBACKSLASHitem 射影变换（ODOLLAR4 OBACKSLASHtimes 4ODOLLAR）：EigenOCOLONOCOLONProjective3d。
OBACKSLASHendOPENCURLYitemizeCLOSECURLY

参考代码中对应的CMakeLists即可编译此程序。在这个程序中，演示了如何使用Eigen中的旋转矩阵、旋转向量（AngleAxis）、欧拉角和四元数。我们用这几种旋转方式去旋转一个向量ODOLLAROBACKSLASHbmOPENCURLYvCLOSECURLYODOLLAR，发现结果是一样的（不一样就真是见鬼了）。同时，也演示了如何在程序中转换这几种表达方式。想进一步了解Eigen的几何模块的读者可以参考（OBACKSLASHurlOPENCURLYhttpOCOLONODIVIDEODIVIDEeigenODOTtuxfamilyODOTorgODIVIDEdoxODIVIDEgroupOUNDERSCOREOUNDERSCORETutorialGeometryODOThtmlCLOSECURLY）。

请读者注意，OBACKSLASHtextbfOPENCURLY程序代码通过和数学表示有一些细微的差别CLOSECURLY。例如，通过运算符重载，四元数和三维向量可以直接计算乘法，但在数学上则需要先把向量转成虚四元数，再利用四元数乘法进行计算，同样的情况也适用于变换矩阵乘三维向量的情况。总体而言，程序中的用法会比数学公式更灵活一些。

OBACKSLASHsubsectionOPENCURLY实际的坐标变换例子CLOSECURLY
下面我们举一个小例子来演示坐标变换。

OBACKSLASHnoindent OBACKSLASHtextbfOPENCURLY例子CLOSECURLY OBACKSLASHquad OBACKSLASHemphOPENCURLY设有小萝卜一号和小萝卜二号位于世界坐标系中。记世界坐标系为ODOLLARWODOLLAR，小萝卜们的坐标系为ODOLLARROUNDERSCORE1ODOLLAR和ODOLLARROUNDERSCORE2ODOLLAR。小萝卜一号的位姿为ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE1 OASSIGN OPENSQUARE 0ODOT35OCOMMA 0ODOT2OCOMMA 0ODOT3OCOMMA 0ODOT1 CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE1 OASSIGN OPENSQUARE0ODOT3OCOMMA 0ODOT1OCOMMA 0ODOT1CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR。小萝卜二号的位姿为ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYOUNDERSCORE2 OASSIGN OPENSQUARE OMINUS0ODOT5OCOMMA 0ODOT4OCOMMA OMINUS0ODOT1OCOMMA 0ODOT2 CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYOCOMMA OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCORE2 OASSIGN OPENSQUAREOMINUS0ODOT1OCOMMA 0ODOT5OCOMMA 0ODOT3CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR。这里的ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR和ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR表达的是ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYROUNDERSCOREkOCOMMA WCLOSECURLYOCOMMAkOASSIGN1OCOMMA2ODOLLAR，也就是世界坐标系到相机坐标系的变换关系。现在，小萝卜一号看到某个点在自身的坐标系下坐标为ODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREOPENCURLYROUNDERSCORE1CLOSECURLY OASSIGN OPENSQUARE0ODOT5OCOMMA0OCOMMA0ODOT2CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR，求该向量在小萝卜二号坐标系下的坐标。CLOSECURLY

这是一个非常简单，但又具有代表性的例子。在实际场景中你经常需要在同一个机器人的不同部分，或者不同机器人之间转换坐标。下面我们书写一段程序来演示这个计算。

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch3ODIVIDEexamplesODIVIDEcoordinateTransformODOTcppCLOSESQUARE
OSINGLEHASHinclude OGREATiostreamOLESS
OSINGLEHASHinclude OGREATvectorOLESS
OSINGLEHASHinclude OGREATalgorithmOLESS
OSINGLEHASHinclude OGREATEigenODIVIDECoreOLESS
OSINGLEHASHinclude OGREATEigenODIVIDEGeometryOLESS

using namespace stdOSEMICOLON
using namespace EigenOSEMICOLON

int mainOPENBRACKETint argcOCOMMA charOMULTIPLYOMULTIPLY argvCLOSEBRACKET OPENCURLY
    Quaterniond q1OPENBRACKET0ODOT35OCOMMA 0ODOT2OCOMMA 0ODOT3OCOMMA 0ODOT1CLOSEBRACKETOCOMMA q2OPENBRACKETOMINUS0ODOT5OCOMMA 0ODOT4OCOMMA OMINUS0ODOT1OCOMMA 0ODOT2CLOSEBRACKETOSEMICOLON
    q1ODOTnormalizeOPENBRACKETCLOSEBRACKETOSEMICOLON
    q2ODOTnormalizeOPENBRACKETCLOSEBRACKETOSEMICOLON
    Vector3d t1OPENBRACKET0ODOT3OCOMMA 0ODOT1OCOMMA 0ODOT1CLOSEBRACKETOCOMMA t2OPENBRACKETOMINUS0ODOT1OCOMMA 0ODOT5OCOMMA 0ODOT3CLOSEBRACKETOSEMICOLON
    Vector3d p1OPENBRACKET0ODOT5OCOMMA 0OCOMMA 0ODOT2CLOSEBRACKETOSEMICOLON
    
    Isometry3d T1wOPENBRACKETq1CLOSEBRACKETOCOMMA T2wOPENBRACKETq2CLOSEBRACKETOSEMICOLON
    T1wODOTpretranslateOPENBRACKETt1CLOSEBRACKETOSEMICOLON
    T2wODOTpretranslateOPENBRACKETt2CLOSEBRACKETOSEMICOLON
    
    Vector3d p2 OASSIGN T2w OMULTIPLY T1wODOTinverseOPENBRACKETCLOSEBRACKET OMULTIPLY p1OSEMICOLON
    cout OGREATOGREAT endl OGREATOGREAT p2ODOTtransposeOPENBRACKETCLOSEBRACKET OGREATOGREAT endlOSEMICOLON
    return 0OSEMICOLON
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

程序输出的答案是ODOLLAROPENSQUAREOMINUS0ODOT0309731OCOMMA0ODOT73499OCOMMA0ODOT296108CLOSESQUAREOHATOBACKSLASHmathrmOPENCURLYTCLOSECURLYODOLLAR，计算过程也十分简单，只需计算ODOLLARODOLLAROBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREOPENCURLYROUNDERSCORE2CLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYROUNDERSCORE2OCOMMAWCLOSECURLYOBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYWOCOMMA ROUNDERSCORE1CLOSECURLY OBACKSLASHbmOPENCURLYpCLOSECURLYOUNDERSCOREOPENCURLYROUNDERSCORE1CLOSECURLYODOLLARODOLLAR即可。注意四元数使用之前需要归一化。

OBACKSLASHsectionOPENCURLY可视化演示CLOSECURLY
OBACKSLASHsubsectionOPENCURLY显示运动轨迹CLOSECURLY
如果你是第一次接触旋转和平移这些概念，可能会觉得它们形式看起来很复杂，因为毕竟每种表达方式都可以与其他方式互相转换，而转换公式有时还比较长。不过，虽然旋转矩阵、变换矩阵的数值可能不够直观，但我们可以很容易地把它们画在窗口里面。

本节我们演示两个可视化例子。首先，假设我们通过某种方式记录了一个机器人的运动轨迹，现在想把它画到一个窗口中。假设轨迹文件存储于trajectoryODOTtxt，每一行用下面的格式存储：ODOLLARODOLLAROBACKSLASHmathrmOPENCURLYtimeCLOSECURLYOCOMMA tOUNDERSCORExOCOMMA tOUNDERSCOREyOCOMMA tOUNDERSCOREzOCOMMA qOUNDERSCORExOCOMMA qOUNDERSCOREyOCOMMA qOUNDERSCOREzOCOMMA qOUNDERSCOREwOCOMMAODOLLARODOLLAR其中ODOLLAROBACKSLASHmathrmOPENCURLYtimeCLOSECURLYODOLLAR指该位姿的记录时间，ODOLLAROBACKSLASHbmOPENCURLYtCLOSECURLYODOLLAR为平移，ODOLLAROBACKSLASHbmOPENCURLYqCLOSECURLYODOLLAR为旋转四元数，均是以世界坐标系到机器人坐标系记录。下面我们从文件中读取这些轨迹，并显示到一个窗口中。原则上，如果只是谈论“机器人的位姿”，那么你可以使用ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYWRCLOSECURLYODOLLAR或者ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYRWCLOSECURLYODOLLAR，事实上它们也只差一个逆而已，意味着知道其中一个就可以很轻松地得到另一个。如果你想要存储OBACKSLASHtextbfOPENCURLY机器人的轨迹CLOSECURLY，那么你可以存储所有时刻的ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYWRCLOSECURLYODOLLAR或者ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYRWCLOSECURLYODOLLAR，这并没有太大的差别。

在画轨迹的时候，我们可以把“轨迹”画成一系列点组成的序列，这和我们想象中的“轨迹”比较相似。严格说来，这其实是OBACKSLASHtextbfOPENCURLY机器人（相机）坐标系的原点在世界坐标系中的坐标CLOSECURLY。考虑机器人坐标系的原点，即ODOLLAROBACKSLASHbmOPENCURLYOCLOSECURLYOUNDERSCOREOPENCURLYRCLOSECURLYODOLLAR，那么，此时的ODOLLAROBACKSLASHbmOPENCURLYOCLOSECURLYOUNDERSCOREOPENCURLYWCLOSECURLYODOLLAR就是这个原点在世界坐标系下的坐标：
OBACKSLASHbeginOPENCURLYequationCLOSECURLY
OBACKSLASHbmOPENCURLYOCLOSECURLYOUNDERSCOREOPENCURLYWCLOSECURLY OASSIGN OBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYWRCLOSECURLY OBACKSLASHbmOPENCURLYOCLOSECURLYOUNDERSCORER OASSIGN OBACKSLASHbmOPENCURLYtCLOSECURLYOUNDERSCOREOPENCURLYWRCLOSECURLYODOT
OBACKSLASHendOPENCURLYequationCLOSECURLY
这正是ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYWRCLOSECURLYODOLLAR的平移部分。因此，可以从ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYWRCLOSECURLYODOLLAR中直接看到OBACKSLASHtextbfOPENCURLY相机在何处CLOSECURLY，这也是我们说ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYWRCLOSECURLYODOLLAR更为直观的原因。因此，在可视化程序里，轨迹文件存储了ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYWRCLOSECURLYODOLLAR而不是ODOLLAROBACKSLASHbmOPENCURLYTCLOSECURLYOUNDERSCOREOPENCURLYRWCLOSECURLYODOLLAR。

最后，我们需要一个支持3D绘图的程序库。有许多库都支持3D绘图，比如大家熟悉的matlab，python的matplotlib，OpenGL等。在linux中，一个常见的库是基于OpenGL的Pangolin库OBACKSLASHfootnoteOPENCURLYOBACKSLASHurlOPENCURLYhttpsOCOLONODIVIDEODIVIDEgithubODOTcomODIVIDEstevenlovegroveODIVIDEPangolinCLOSECURLYCLOSECURLY，它在支持OpenGL的绘图操作基础之上还提供了一些GUI的功能。在第二版的书籍中，我们使用git的submodule功能来管理本书依赖的第三方库。读者可以进入3rdparty文件夹中直接安装所需的库，git保证了我和你使用的版本是一致的。

OBACKSLASHbeginOPENCURLYlstlistingCLOSECURLYOPENSQUARElanguageOASSIGNcOPLUSOPLUSOCOMMAcaptionOASSIGNslambook2ODIVIDEch3ODIVIDEexamplesODIVIDEplotTrajectoryODOTcppCLOSESQUARE
OSINGLEHASHinclude OGREATpangolinODIVIDEpangolinODOThOLESS
OSINGLEHASHinclude OGREATEigenODIVIDECoreOLESS
OSINGLEHASHinclude OGREATunistdODOThOLESS

using namespace stdOSEMICOLON
using namespace EigenOSEMICOLON

ODIVIDEODIVIDE path to trajectory file
string trajectoryOUNDERSCOREfile OASSIGN "ODOTODIVIDEexamplesODIVIDEtrajectoryODOTtxt"OSEMICOLON

void DrawTrajectoryOPENBRACKETvectorOGREATIsometry3dOCOMMA EigenOCOLONOCOLONalignedOUNDERSCOREallocatorOGREATIsometry3dOLESSOLESSCLOSEBRACKETOSEMICOLON

int mainOPENBRACKETint argcOCOMMA char OMULTIPLYOMULTIPLYargvCLOSEBRACKET OPENCURLY
    vectorOGREATIsometry3dOCOMMA EigenOCOLONOCOLONalignedOUNDERSCOREallocatorOGREATIsometry3dOLESSOLESS posesOSEMICOLON
    ifstream finOPENBRACKETtrajectoryOUNDERSCOREfileCLOSEBRACKETOSEMICOLON
    if OPENBRACKETONOTfinCLOSEBRACKET OPENCURLY
        cout OGREATOGREAT "cannot find trajectory file at " OGREATOGREAT trajectoryOUNDERSCOREfile OGREATOGREAT endlOSEMICOLON
        return 1OSEMICOLON
    CLOSECURLY
    
    while OPENBRACKETONOTfinODOTeofOPENBRACKETCLOSEBRACKETCLOSEBRACKET OPENCURLY
        double timeOCOMMA txOCOMMA tyOCOMMA tzOCOMMA qxOCOMMA qyOCOMMA qzOCOMMA qwOSEMICOLON
        fin OLESSOLESS time OLESSOLESS tx OLESSOLESS ty OLESSOLESS tz OLESSOLESS qx OLESSOLESS qy OLESSOLESS qz OLESSOLESS qwOSEMICOLON
        Isometry3d TwrOPENBRACKETQuaterniondOPENBRACKETqwOCOMMA qxOCOMMA qyOCOMMA qzCLOSEBRACKETCLOSEBRACKETOSEMICOLON
        TwrODOTpretranslateOPENBRACKETVector3dOPENBRACKETtxOCOMMA tyOCOMMA tzCLOSEBRACKETCLOSEBRACKETOSEMICOLON
        posesODOTpushOUNDERSCOREbackOPENBRACKETTwrCLOSEBRACKETOSEMICOLON
    CLOSECURLY
    cout OGREATOGREAT "read total " OGREATOGREAT posesODOTsizeOPENBRACKETCLOSEBRACKET OGREATOGREAT " pose entries" OGREATOGREAT endlOSEMICOLON
    
    ODIVIDEODIVIDE draw trajectory in pangolin
    DrawTrajectoryOPENBRACKETposesCLOSEBRACKETOSEMICOLON
    return 0OSEMICOLON
CLOSECURLY

void DrawTrajectoryOPENBRACKETvectorOGREATIsometry3dOCOMMA EigenOCOLONOCOLONalignedOUNDERSCOREallocatorOGREATIsometry3dOLESSOLESS posesCLOSEBRACKET OPENCURLY
    ODIVIDEODIVIDE create pangolin window and plot the trajectory
    pangolinOCOLONOCOLONCreateWindowAndBindOPENBRACKET"Trajectory Viewer"OCOMMA 1024OCOMMA 768CLOSEBRACKETOSEMICOLON
    glEnableOPENBRACKETGLOUNDERSCOREDEPTHOUNDERSCORETESTCLOSEBRACKETOSEMICOLON
    glEnableOPENBRACKETGLOUNDERSCOREBLENDCLOSEBRACKETOSEMICOLON
    glBlendFuncOPENBRACKETGLOUNDERSCORESRCOUNDERSCOREALPHAOCOMMA GLOUNDERSCOREONEOUNDERSCOREMINUSOUNDERSCORESRCOUNDERSCOREALPHACLOSEBRACKETOSEMICOLON
    
    pangolinOCOLONOCOLONOpenGlRenderState sOUNDERSCOREcamOPENBRACKET
    pangolinOCOLONOCOLONProjectionMatrixOPENBRACKET1024OCOMMA 768OCOMMA 500OCOMMA 500OCOMMA 512OCOMMA 389OCOMMA 0ODOT1OCOMMA 1000CLOSEBRACKETOCOMMA
    pangolinOCOLONOCOLONModelViewLookAtOPENBRACKET0OCOMMA OMINUS0ODOT1OCOMMA OMINUS1ODOT8OCOMMA 0OCOMMA 0OCOMMA 0OCOMMA 0ODOT0OCOMMA OMINUS1ODOT0OCOMMA 0ODOT0CLOSEBRACKET
    CLOSEBRACKETOSEMICOLON
    
    pangolinOCOLONOCOLONView OBANDdOUNDERSCOREcam OASSIGN pangolinOCOLONOCOLONCreateDisplayOPENBRACKETCLOSEBRACKET
        ODOTSetBoundsOPENBRACKET0ODOT0OCOMMA 1ODOT0OCOMMA 0ODOT0OCOMMA 1ODOT0OCOMMA OMINUS1024ODOT0f ODIVIDE 768ODOT0fCLOSEBRACKET
        ODOTSetHandlerOPENBRACKETnew pangolinOCOLONOCOLONHandler3DOPENBRACKETsOUNDERSCOREcamCLOSEBRACKETCLOSEBRACKETOSEMICOLON
    
    while OPENBRACKETpangolinOCOLONOCOLONShouldQuitOPENBRACKETCLOSEBRACKET OASSIGNOASSIGN falseCLOSEBRACKET OPENCURLY
        glClearOPENBRACKETGLOUNDERSCORECOLOROUNDERSCOREBUFFEROUNDERSCOREBIT OBBOR GLOUNDERSCOREDEPTHOUNDERSCOREBUFFEROUNDERSCOREBITCLOSEBRACKETOSEMICOLON
        dOUNDERSCOREcamODOTActivateOPENBRACKETsOUNDERSCOREcamCLOSEBRACKETOSEMICOLON
        glClearColorOPENBRACKET1ODOT0fOCOMMA 1ODOT0fOCOMMA 1ODOT0fOCOMMA 1ODOT0fCLOSEBRACKETOSEMICOLON
        glLineWidthOPENBRACKET2CLOSEBRACKETOSEMICOLON
        for OPENBRACKETsizeOUNDERSCOREt i OASSIGN 0OSEMICOLON i OGREAT posesODOTsizeOPENBRACKETCLOSEBRACKETOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
            ODIVIDEODIVIDE 画每个位姿的三个坐标轴
            Vector3d Ow OASSIGN posesOPENSQUAREiCLOSESQUAREODOTtranslationOPENBRACKETCLOSEBRACKETOSEMICOLON
            Vector3d Xw OASSIGN posesOPENSQUAREiCLOSESQUARE OMULTIPLY OPENBRACKET0ODOT1 OMULTIPLY Vector3dOPENBRACKET1OCOMMA 0OCOMMA 0CLOSEBRACKETCLOSEBRACKETOSEMICOLON
            Vector3d Yw OASSIGN posesOPENSQUAREiCLOSESQUARE OMULTIPLY OPENBRACKET0ODOT1 OMULTIPLY Vector3dOPENBRACKET0OCOMMA 1OCOMMA 0CLOSEBRACKETCLOSEBRACKETOSEMICOLON
            Vector3d Zw OASSIGN posesOPENSQUAREiCLOSESQUARE OMULTIPLY OPENBRACKET0ODOT1 OMULTIPLY Vector3dOPENBRACKET0OCOMMA 0OCOMMA 1CLOSEBRACKETCLOSEBRACKETOSEMICOLON
            glBeginOPENBRACKETGLOUNDERSCORELINESCLOSEBRACKETOSEMICOLON
            glColor3fOPENBRACKET1ODOT0OCOMMA 0ODOT0OCOMMA 0ODOT0CLOSEBRACKETOSEMICOLON
            glVertex3dOPENBRACKETOwOPENSQUARE0CLOSESQUAREOCOMMA OwOPENSQUARE1CLOSESQUAREOCOMMA OwOPENSQUARE2CLOSESQUARECLOSEBRACKETOSEMICOLON
            glVertex3dOPENBRACKETXwOPENSQUARE0CLOSESQUAREOCOMMA XwOPENSQUARE1CLOSESQUAREOCOMMA XwOPENSQUARE2CLOSESQUARECLOSEBRACKETOSEMICOLON
            glColor3fOPENBRACKET0ODOT0OCOMMA 1ODOT0OCOMMA 0ODOT0CLOSEBRACKETOSEMICOLON
            glVertex3dOPENBRACKETOwOPENSQUARE0CLOSESQUAREOCOMMA OwOPENSQUARE1CLOSESQUAREOCOMMA OwOPENSQUARE2CLOSESQUARECLOSEBRACKETOSEMICOLON
            glVertex3dOPENBRACKETYwOPENSQUARE0CLOSESQUAREOCOMMA YwOPENSQUARE1CLOSESQUAREOCOMMA YwOPENSQUARE2CLOSESQUARECLOSEBRACKETOSEMICOLON
            glColor3fOPENBRACKET0ODOT0OCOMMA 0ODOT0OCOMMA 1ODOT0CLOSEBRACKETOSEMICOLON
            glVertex3dOPENBRACKETOwOPENSQUARE0CLOSESQUAREOCOMMA OwOPENSQUARE1CLOSESQUAREOCOMMA OwOPENSQUARE2CLOSESQUARECLOSEBRACKETOSEMICOLON
            glVertex3dOPENBRACKETZwOPENSQUARE0CLOSESQUAREOCOMMA ZwOPENSQUARE1CLOSESQUAREOCOMMA ZwOPENSQUARE2CLOSESQUARECLOSEBRACKETOSEMICOLON
            glEndOPENBRACKETCLOSEBRACKETOSEMICOLON
        CLOSECURLY
        ODIVIDEODIVIDE 画出连线
        for OPENBRACKETsizeOUNDERSCOREt i OASSIGN 0OSEMICOLON i OGREAT posesODOTsizeOPENBRACKETCLOSEBRACKETOSEMICOLON iOPLUSOPLUSCLOSEBRACKET OPENCURLY
            glColor3fOPENBRACKET0ODOT0OCOMMA 0ODOT0OCOMMA 0ODOT0CLOSEBRACKETOSEMICOLON
            glBeginOPENBRACKETGLOUNDERSCORELINESCLOSEBRACKETOSEMICOLON
            auto p1 OASSIGN posesOPENSQUAREiCLOSESQUAREOCOMMA p2 OASSIGN posesOPENSQUAREi OPLUS 1CLOSESQUAREOSEMICOLON
            glVertex3dOPENBRACKETp1ODOTtranslationOPENBRACKETCLOSEBRACKETOPENSQUARE0CLOSESQUAREOCOMMA p1ODOTtranslationOPENBRACKETCLOSEBRACKETOPENSQUARE1CLOSESQUAREOCOMMA p1ODOTtranslationOPENBRACKETCLOSEBRACKETOPENSQUARE2CLOSESQUARECLOSEBRACKETOSEMICOLON
            glVertex3dOPENBRACKETp2ODOTtranslationOPENBRACKETCLOSEBRACKETOPENSQUARE0CLOSESQUAREOCOMMA p2ODOTtranslationOPENBRACKETCLOSEBRACKETOPENSQUARE1CLOSESQUAREOCOMMA p2ODOTtranslationOPENBRACKETCLOSEBRACKETOPENSQUARE2CLOSESQUARECLOSEBRACKETOSEMICOLON
            glEndOPENBRACKETCLOSEBRACKETOSEMICOLON
        CLOSECURLY
        pangolinOCOLONOCOLONFinishFrameOPENBRACKETCLOSEBRACKETOSEMICOLON
        usleepOPENBRACKET5000CLOSEBRACKETOSEMICOLON   ODIVIDEODIVIDE sleep 5 ms
    CLOSECURLY
CLOSECURLY
OBACKSLASHendOPENCURLYlstlistingCLOSECURLY

该程序演示了如何在Panglin中画出3D的位姿。我们用红、绿、蓝三种颜色画出每个位姿的三个坐标轴（实际上我们计算了各坐标轴的世界坐标），然后用黑色线将轨迹连起来。程序运行结果如OBACKSLASHautorefOPENCURLYfigOCOLONtrajectoryCLOSECURLY所示。

OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
    OBACKSLASHcentering
    OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT8OBACKSLASHtextwidthCLOSESQUAREOPENCURLYrigidMotionODIVIDEtrajectoryODOTpdfCLOSECURLY
    OBACKSLASHcaptionOPENCURLY位姿可视化的结果CLOSECURLY
    OBACKSLASHlabelOPENCURLYfigOCOLONtrajectoryCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY

OBACKSLASHsubsectionOPENCURLY显示相机的位姿CLOSECURLY
OBACKSLASHbeginOPENCURLYfigureCLOSECURLYOPENSQUAREONOThtpCLOSESQUARE
    OBACKSLASHcentering
    OBACKSLASHincludegraphicsOPENSQUAREwidthOASSIGN0ODOT8OBACKSLASHtextwidthCLOSESQUAREOPENCURLYrigidMotionODIVIDEvisualizeGeometryODOTpdfCLOSECURLY
    OBACKSLASHcaptionOPENCURLY旋转矩阵、欧拉角、四元数的可视化程序。CLOSECURLY
    OBACKSLASHlabelOPENCURLYfigOCOLONvisualizeGeometryCLOSECURLY
OBACKSLASHendOPENCURLYfigureCLOSECURLY
除了显示轨迹之外，我们也可以显示3D窗口中相机的位姿。在slambook2ODIVIDEch3ODIVIDEvisualizeGeometry中，我们以可视化的形式演示了相机位姿的各种表达方式（见OBACKSLASHautorefOPENCURLYfigOCOLONvisualizeGeometryCLOSECURLY）。当读者用鼠标操作相机时，左侧的方框里会实时显示相机位姿对应的旋转矩阵、平移、欧拉角和四元数，你可以看看数据是如何变化的。根据我们的经验，除了欧拉角之外，你应该看不出它们直观的含义。然而，尽管旋转矩阵或变换矩阵并不直观，但是将它们可视化地显示出来并没有什么困难。该程序使用Pangolin库作为3D显示库，请参考ReadmeODOTtxt来编译该程序。

OBACKSLASHsectionOMULTIPLYOPENCURLY习题CLOSECURLY
OBACKSLASHbeginOPENCURLYenumerateCLOSECURLY
	OBACKSLASHitem 验证旋转矩阵是正交矩阵。
	OBACKSLASHitemOPENSQUAREOBACKSLASHoptionalCLOSESQUARE 寻找罗德里格斯公式的推导过程并加以理解。
	OBACKSLASHitem 验证四元数旋转某个点后，结果是一个虚四元数（实部为零），所以仍然对应到一个三维空间点，见式OBACKSLASHeqrefOPENCURLYeqOCOLONrotateOMINUSwithOMINUSquaternionCLOSECURLY。
	OBACKSLASHitem 画表总结旋转矩阵、轴角、欧拉角、四元数的转换关系。
	OBACKSLASHitem 假设有一个大的Eigen矩阵，想把它的左上角ODOLLAR3 OBACKSLASHtimes 3ODOLLAR的块取出来，然后赋值为ODOLLAROBACKSLASHbmOPENCURLYICLOSECURLYOUNDERSCOREOPENCURLY3 OBACKSLASHtimes 3CLOSECURLYODOLLAR。请编程实现。
	OBACKSLASHitemOPENSQUAREOBACKSLASHoptionalCLOSESQUARE 一般线性方程ODOLLAROBACKSLASHbmOPENCURLYACLOSECURLY OBACKSLASHbmOPENCURLYxCLOSECURLYOASSIGNOBACKSLASHbmOPENCURLYbCLOSECURLYODOLLAR有哪几种做法？你能在Eigen中实现吗？
OBACKSLASHendOPENCURLYenumerateCLOSECURLY